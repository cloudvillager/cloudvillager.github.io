<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>异常</title>
      <link href="posts/23a3bd72.html"/>
      <url>posts/23a3bd72.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>什么是异常？Java代码在运行时期发生的问题就是异常。</p><p>在Java中，把异常信息封装成了一个类。当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常的根类是Throwable，其下有两个子类：Error与Exception，平常所说的异常指Exception。</p><h2 id="异常的继承体系"><a href="#异常的继承体系" class="headerlink" title="异常的继承体系"></a>异常的继承体系</h2><p>在Java中使用Exception类来描述异常。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103233939.png"></p><p>查看API中Exception的描述，Exception 类及其子类是 Throwable 的一种形式，它用来表示java程序中可能会产生的异常，并要求对产生的异常进行合理的异常处理。</p><p>继续观察，我们可以发现Exception有继承关系，它的父类是Throwable。Throwable是Java 语言中所有错误或异常的超类，即祖宗类。</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103234138.png" style="zoom:80%;" /><p>另外，在异常Exception类中，有一个子类要特殊说明一下，RuntimeException子类，RuntimeException及其它的子类只能在Java程序运行过程中出现。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103234257.png"></p><p>我们再来观察Throwable类，能够发现与异常Exception平级的有一个Error，它是Throwable的子类，它用来表示java程序中可能会产生的严重错误。解决办法只有一个，修改代码避免Error错误的产生。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103234358.png"></p><p><strong>异常继承体系总结：</strong></p><blockquote><p>Throwable: 它是所有错误与异常的超类（祖宗类）</p><blockquote><p>Error 错误</p><p>Exception 编译期异常,进行编译JAVA程序时出现的问题</p><blockquote><p>RuntimeException 运行期异常, JAVA程序运行过程中出现的问题</p></blockquote></blockquote></blockquote><h2 id="异常与错误的区别"><a href="#异常与错误的区别" class="headerlink" title="异常与错误的区别"></a>异常与错误的区别</h2><p><strong>异常</strong>：指程序在编译、运行期间发生了某种异常(XxxException)，我们可以对异常进行具体的处理。若不处理异常，程序将会结束运行。</p><ul><li><p>异常的产生演示如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);<span class="comment">//该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException，由于没有处理异常，导致程序无法继续执行，程序结束。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;over&quot;</span>); <span class="comment">// 由于上面代码发生了异常，此句代码不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>错误</strong>：指程序在运行期间发生了某种错误(XxxError)，Error错误通常没有具体的处理方式，程序将会结束运行。Error错误的发生往往都是系统级别的问题，都是jvm所在系统发生的，并反馈给jvm的。我们无法针对处理，只能修正代码。</p><ul><li><p>错误的产生演示如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">100</span>];<span class="comment">//该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间，导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常的产生过程解析"><a href="#异常的产生过程解析" class="headerlink" title="异常的产生过程解析"></a>异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对给定的数组通过给定的角标获取元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> element = arr[index];</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> num = ArrayTools.getElement(arr,<span class="number">4</span>)</span><br><span class="line">System.out.println(<span class="string">&quot;num=&quot;</span>+num);</span><br><span class="line">System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台会显示</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201104000508.png"></p><p>分析：</p><p>程序正常运行到<code>        int num = ArrayTools.getElement(arr,4)</code>这里，由于没有找到4索引，导致运行发生了异常。java虚拟机能够检测到出现数组的越界问题，</p><p>随后，JVM会做两件事，</p><p>第一件事情：创建了异常的对象，new ArrayIndexOutOfBoundsException(4)</p><p>第二件事情：将异常的对象进行抛出，扔出去理论，抛给方法的调用者</p><p>main接收到了这个异常，main也没有对数组越界异常进行处理，将异常对象继续抛出，抛给main的调用者（JVM）</p><p>当JVM收到异常后做了两件事，</p><p>第一件事：将异常信息以红色字体输出控制台</p><p>第二件事：将程序停止，结束</p><p><strong>注意：一旦异常背抛出了，后面的所有程序，都不再执行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201104001614.png"></p><h2 id="抛出异常关键字throw"><a href="#抛出异常关键字throw" class="headerlink" title="抛出异常关键字throw"></a>抛出异常关键字throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象；</p></li></ol><p>throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p><p><em><font color=red>throw ,在方法内部，抛出异常对象，必须是exception，throw 后面必须写new 对象，必须是异常的对象或者是子类</font></em></p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);</span><br></pre></td></tr></table></figure><hr><p>下面是异常类ArrayIndexOutOfBoundsException与NullPointerException的构造方法</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201104114038.png"></p><p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p><p>编写工具类，提供获取数组指定索引处的元素值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过给定的数组，返回给定的索引对应的元素值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 若程序出了异常，JVM它会打包异常对象并抛出。但是它所提供的信息不够给力。想要更清晰，需要自己抛出异常信息。</span></span><br><span class="line"><span class="comment">         * 下面判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;arr指向的数组不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;错误的角标，&quot;</span> + index + <span class="string">&quot;索引在数组中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;; <span class="comment">//创建数组</span></span><br><span class="line"><span class="keyword">int</span> num = ArrayTools.getElement(<span class="keyword">null</span>,<span class="number">2</span>);<span class="comment">// 调用方法，获取数组中指定索引处元素</span></span><br><span class="line"><span class="comment">//int num = ArrayTools.getElement(arr,5);// 调用方法，获取数组中指定索引处元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;num=&quot;</span>+num);<span class="comment">//打印获取到的元素值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="声明异常关键字throws"><a href="#声明异常关键字throws" class="headerlink" title="声明异常关键字throws"></a>声明异常关键字throws</h2><p>声明：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>声明异常格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>… &#123;   &#125;</span><br></pre></td></tr></table></figure><p>声明异常的代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;show run&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p><p>多个异常的情况，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> NullPointerException, ArrayIndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;arr指向的数组不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;错误的角标，&quot;</span> + index + <span class="string">&quot;索引在数组中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="捕获异常try…catch…finally"><a href="#捕获异常try…catch…finally" class="headerlink" title="捕获异常try…catch…finally"></a>捕获异常try…catch…finally</h2><p>捕获：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理</p><p>捕获异常格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//需要被检测的语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类 变量) &#123; <span class="comment">//参数。</span></span><br><span class="line"><span class="comment">//异常的处理语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//一定会被执行的语句。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//throws ArrayIndexOutOfBoundsException</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">                System.out.println(arr[<span class="number">5</span>]);<span class="comment">// 会抛出ArrayIndexOutOfBoundsException</span></span><br><span class="line">                <span class="comment">//当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123; <span class="comment">//括号中需要定义什么呢？try中抛出的是什么异常，在括号中就定义什么异常类型。</span></span><br><span class="line">                System.out.println(<span class="string">&quot;异常发生了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                arr = <span class="keyword">null</span>; <span class="comment">//把数组指向null，通过垃圾回收器，进行内存垃圾的清除</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行结果&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="try…catch…finally异常处理的组合方式"><a href="#try…catch…finally异常处理的组合方式" class="headerlink" title="try…catch…finally异常处理的组合方式"></a>try…catch…finally异常处理的组合方式</h2><p><strong>try catch finally组合：</strong>检测异常，并传递给catch处理，并在finally中进行资源释放。</p><p><strong>try catch组合</strong> : 对代码进行异常检测，并对检测的异常传递给catch处理。对异常进行捕获处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//不用throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//产生异常，直接捕获处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个try 多个catch组合</strong> : 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//不用throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//产生异常，直接捕获处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XxxException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(YyyException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ZzzException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，<strong>并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理</strong>,如果是平级异常，也就是抛出的异常类之间，没有继承关系，那就没有顺序，上下随便写。</p><p><strong>try finally 组合</strong>: 对代码进行异常检测，检测到异常后因为没有catch，所以一样会被默认jvm抛出。异常是没有捕获处理的。但是功能所开启资源需要进行关闭，所有finally。只为关闭资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//需要throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行时期异常"><a href="#运行时期异常" class="headerlink" title="运行时期异常"></a>运行时期异常</h2><p>异常其实分为编译异常和运行时期异常</p><p>编译异常：调用了抛出异常的方法，不处理编译失败（try/throws）</p><p>运行异常：抛出的异常是RuntimeException类，或者是他的子类</p><hr><p>RuntimeException和他的所有子类异常,都属于运行时期异常。NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常.</p><p>运行异常的特点: 方法中抛出运行时期异常,方法定义中<strong>无需throws声明</strong>,调用者也无需处理此异常</p><p>设计原因：运行异常，不能发生，但是如果发生了，请修改源代码，因为运行代码一旦发生，后面的代码没有执行的意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常在方法重写中细节"><a href="#异常在方法重写中细节" class="headerlink" title="异常在方法重写中细节"></a>异常在方法重写中细节</h2><ol><li><p>子类覆盖父类方法时，如果父类的方法声明异常，<strong>子类只能声明父类异常或者该异常的子类，或者不声明。</strong>（声明不声明都可以）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123; &#125;  <span class="comment">//抛出父类一样的异常</span></span><br><span class="line">        <span class="comment">//public void method() throws NullPointerException&#123; &#125; //抛出父类子异常</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>当父类方法声明多个异常时，子类覆盖时只能声明多个异常的子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span><span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123; &#125;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException</span>&#123; &#125; <span class="comment">//抛出父类异常中的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> ClassCastException </span>&#123; &#125; <span class="comment">//抛出父类异常中的一部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当被覆盖的方法没有异常声明时，子类覆盖时无法声明异常的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; &#125;<span class="comment">//错误的方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：父类中会存在下列这种情况，接口也有这种情况</p><p>问题：接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？</p><p>答：无法进行throws声明，只能catch的捕获。万一问题处理不了呢？catch中继续throw抛出，但是只能将异常转换成RuntimeException子类抛出。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="comment">//无法声明 throws Exception</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//只能捕获处理</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;哥们，你定义的数组arr是空的!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;父方法中没有异常抛出，子类中不能抛出Exception异常&quot;</span>);</span><br><span class="line">                <span class="comment">//我们把异常对象e，采用RuntimeException异常方式抛出</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="异常中常用方法"><a href="#异常中常用方法" class="headerlink" title="异常中常用方法"></a>异常中常用方法</h2><p>在Throwable类中为我们提供了很多操作异常对象的方法，常用的如下：</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201104132631.png"></p><ul><li><p>getMessage方法：返回该异常的详细信息字符串，即异常提示信息</p></li><li><p>toString方法：返回该异常的名称与详细信息字符串</p></li><li><p>printStackTrace：在控制台输出该异常的名称与详细信息字符串、异常出现的代码位置，JVM默认调用方法也是这个方法</p><p>异常的常用方法代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Person p= <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (p==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(“出现空指针异常了，请检查对象是否为<span class="keyword">null</span>”);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">String message = e.getMesage();</span><br><span class="line">System.out.println(message ); </span><br><span class="line"></span><br><span class="line">String result = e.toString();</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>在上述代码中，发现这些异常都是JDK内部定义好的，并且这些异常不好找。书写时也很不方便，那么能不能自己定义异常呢？</p><p>之前的几个异常都是java通过类进行的描述。并将问题封装成对象，异常就是将问题封装成了对象。这些异常不好认，书写也很不方便，能不能定义一个符合我的程序要求的异常名称。既然JDK中是使用类在描述异常信息，那么我们也可以模拟Java的这种机制，我们自己定义异常的信息，异常的名字，让异常更符合自己程序的阅读。准确对自己所需要的异常进行类的描述。</p><h2 id="自定义异常类的定义"><a href="#自定义异常类的定义" class="headerlink" title="自定义异常类的定义"></a>自定义异常类的定义</h2><p>通过阅读异常源代码：发现java中所有的异常类，都是继承Throwable，或者继承Throwable的子类。这样该异常才可以被throw抛出。</p><p>说明这个异常体系具备一个特有的特性：可抛性：即可以被throw关键字操作。</p><p>并且查阅异常子类源码，发现每个异常中都调用了父类的构造方法，把异常描述信息传递给了父类，让父类帮我们进行异常信息的封装。</p><p>例如NullPointerException异常类源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullPointerException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullPointerException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//调用父类构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullPointerException</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);<span class="comment">//调用父类具有异常信息的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们来定义个自己的异常，即自定义异常。</p><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class 异常名 extends Exception&#123; <span class="comment">//或继承RuntimeException</span></span><br><span class="line"><span class="keyword">public</span> 异常名()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> 异常名(String s)&#123; </span><br><span class="line"><span class="keyword">super</span>(s); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>自定义异常继承Exception演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(message);<span class="comment">// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义异常继承RuntimeException演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MyException()&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line">MyException(String message)&#123;</span><br><span class="line"><span class="keyword">super</span>(message);<span class="comment">// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="自定义异常的练习"><a href="#自定义异常的练习" class="headerlink" title="自定义异常的练习"></a>自定义异常的练习</h2><p>定义Person类，包含name与age两个成员变量。</p><p>在Person类的有参数构造方法中，进行年龄范围的判断，若年龄为负数或大于200岁，则抛出NoAgeException异常，异常提示信息“年龄数值非法”。</p><p>要求：在测试类中，调用有参数构造方法，完成Person对象创建，并进行异常的处理。</p><p>自定义异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoAgeException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">NoAgeException() &#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NoAgeException(String message)&#123;</span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">Person(String name,<span class="keyword">int</span> age) <span class="keyword">throws</span> NoAgeException&#123;</span><br><span class="line"><span class="comment">//加入逻辑判断。</span></span><br><span class="line"><span class="keyword">if</span>(age&lt;<span class="number">0</span> || age&gt;<span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoAgeException(age+<span class="string">&quot;,年龄数值非法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Person对象对应的字符串表现形式。覆盖Object中的toString方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person[name=&quot;</span>+name+<span class="string">&quot;,age=&quot;</span>+age+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">20</span>);</span><br><span class="line">System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoAgeException ex)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;年龄异常啦&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，构造函数到底抛出这个NoAgeException是继承Exception呢？还是继承RuntimeException呢？</p><ul><li>继承Exception，必须要throws声明，一声明就告知调用者进行捕获，一旦问题处理了调用者的程序会继续执行。</li><li>继承RuntimeExcpetion,不需要throws声明的，这时调用是不需要编写捕获代码的，因为调用根本就不知道有问题。一旦发生NoAgeException，调用者程序会停掉，并有jvm将信息显示到屏幕，让调用者看到问题，修正代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码块</title>
      <link href="posts/57224242.html"/>
      <url>posts/57224242.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h1><p>局部代码块是定义在方法或语句中</p><p>特点：</p><ul><li>以”{}”划定的代码区域，此时只需要关注作用域的不同即可</li><li>方法和类都是以代码块的方式划定边界的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">         <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块&quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">99</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;代码块之外&quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>​        普通代码块1</p><p>​        代码块之外99</p><h1 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h1><p>构造代码块是定义在类中成员位置的代码块</p><p>特点：</p><ul><li><code>优先于构造方法</code>执行，构造代码块用于执行所有对象均需要的初始化动作</li><li><code>每创建一个对象均会执行一次构造代码块</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//构造代码块</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造代码块执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Person无参数的构造函数执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">System.out.println(<span class="string">&quot;Person（age）参数的构造函数执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>构造代码块执行了</p><p>Person无参数的构造函数执行</p><p>Person（age）参数的构造函数执行”</p><blockquote><p>构造代码块是优先于构造方法，所以就算构造代码块放在后面，他也先执行构造代码块的方法，和顺序没有关系</p></blockquote><h1 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h1><p>静态代码块是定义在成员位置，使用static修饰的代码块。</p><p>特点：</p><ul><li>它<code>优先于主方法执行</code>、<code>优先于构造代码块执行</code>，当以任意形式第一次使用到该类时执行。</li><li>该类不管创建多少对象，静态代码块<code>只执行一次</code>。</li><li>可用于给静态变量赋值，用来给类进行初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">     <span class="comment">//静态代码块</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四大访问权限修饰符</title>
      <link href="posts/f941d9b7.html"/>
      <url>posts/f941d9b7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限，以下表来说明不同权限的访问能力：</p><table><thead><tr><th align="left"></th><th align="center">public</th><th align="center">protected</th><th align="center">default</th><th align="center">private</th></tr></thead><tbody><tr><td align="left">同一类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">同一包中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="left">不同包的子类</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">不同包中的无关类</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>​     归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问</p><ul><li>要想仅能在本类中访问使用private修饰；</li><li>要想本包中的类都可以访问不加修饰符即可；</li><li>要想本包中的类与其他包中的子类可以访问使用protected修饰</li><li>要想所有包中的所有类都可以访问使用public修饰。</li><li>注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名对象与内部类</title>
      <link href="posts/307f30e5.html"/>
      <url>posts/307f30e5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个普通对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();<span class="comment">//这种对象可以反复使用</span></span><br></pre></td></tr></table></figure><p>创建一个匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person();<span class="comment">//这种对象只能使用一次</span></span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><p>创建匿名对象直接使用，没有变量名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person().eat()  <span class="comment">//eat方法被一个没有名字的Person对象调用了。</span></span><br></pre></td></tr></table></figure></li><li><p>匿名对象在没有指定其引用变量时，只能使用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person().eat(); 创建一个匿名对象，调用eat方法</span><br><span class="line"><span class="keyword">new</span> Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象</span><br></pre></td></tr></table></figure></li><li><p>匿名对象可以作为方法接收的参数、方法返回值使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//普通方式</span></span><br><span class="line"><span class="comment">//Person p = new Person();</span></span><br><span class="line"><span class="comment">//return p;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象作为方法返回值</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person p)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用getPerson方法，得到一个Person对象</span></span><br><span class="line">Person person = Demo.getPerson();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用method方法</span></span><br><span class="line">Demo.method(person);</span><br><span class="line"><span class="comment">//匿名对象作为方法接收的参数</span></span><br><span class="line">Demo.method(<span class="keyword">new</span> Person());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ol><li><p>什么是内部类</p><p>将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。</p></li><li><p>什么时候使用内部类</p><p>在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，这时发动机就可以使用内部类来描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 汽车 </span>&#123; <span class="comment">//外部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 发动机 </span>&#123; <span class="comment">//内部类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部类的分类</p><p>内部类分为成员内部类与局部内部类。</p><p>我们定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。在内部类中可以直接访问外部类的所有成员。</p></li></ol><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问</p><ol><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123; </span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 变量名 = <span class="keyword">new</span> 外部类名().new 内部类名();</span><br></pre></td></tr></table></figure></li><li><p>成员内部类代码演示</p><p>定义类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;<span class="comment">//外部类，身体</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> life= <span class="keyword">true</span>; <span class="comment">//生命状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123; <span class="comment">//内部类，心脏</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;心脏噗通噗通的跳&quot;</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;生命状态&quot;</span> + life); <span class="comment">//访问外部类成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建内部类对象</span></span><br><span class="line">Body.Heart bh = <span class="keyword">new</span> Body().<span class="function">new <span class="title">Heart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//调用内部类中的方法</span></span><br><span class="line">bh.jump();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用规则</p><p>内部类，可以使用外部类成员，包括私有</p><p>外部类要使用内部类的成员，必须建立内部类对象</p></li><li><p>成员内部类的同名变量调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//System.out.println(i);//输出3</span></span><br><span class="line">            <span class="comment">//System.out.println(this.i);//输出2</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.i);<span class="comment">//输出1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        in.inner(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问</p><ol><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123; </span><br><span class="line">修饰符 返回值类型 方法名(参数) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">            <span class="comment">//其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问方式</p><p>在外部类方法中，创建内部类对象，进行访问</p></li><li><p>局部内部类代码演示</p><p>定义类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Party</span> </span>&#123;<span class="comment">//外部类，聚会</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">puffBall</span><span class="params">()</span></span>&#123;<span class="comment">// 吹气球方法</span></span><br><span class="line">         <span class="class"><span class="keyword">class</span> <span class="title">Ball</span> </span>&#123;<span class="comment">// 内部类，气球</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">puff</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;气球膨胀了&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//创建内部类对象，调用puff方法</span></span><br><span class="line">        <span class="keyword">new</span> Ball().puff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建外部类对象</span></span><br><span class="line">Party p = <span class="keyword">new</span> Party();</span><br><span class="line"><span class="comment">//调用外部类中的puffBall方法</span></span><br><span class="line">p.puffBall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="内部类的实际使用——匿名内部类"><a href="#内部类的实际使用——匿名内部类" class="headerlink" title="内部类的实际使用——匿名内部类"></a>内部类的实际使用——匿名内部类</h2><h3 id="匿名内部类概念"><a href="#匿名内部类概念" class="headerlink" title="匿名内部类概念"></a>匿名内部类概念</h3><p>内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。</p><p>最常用到的内部类就是匿名内部类，它是局部内部类的一种。</p><p>定义的匿名内部类有两个含义：</p><ul><li>临时定义某一指定类型的子类</li><li>定义后即刻创建刚刚定义的这个子类的对象</li></ul><blockquote><p>概念解读：</p><p>以前我们实现类的时候，都是先定义一个类Fu，然后让Zi继承Fu，然后重现Fu类的抽象方法，接着创建实现类对象在调用重写方法</p><p>而匿名内部类就是用于简化这种问题，一步来完成，将<code>定义实现类</code>，<code>重写方法</code>，<code>建立实现类</code>，合而为一</p></blockquote><h3 id="定义匿名内部类的作用与格式"><a href="#定义匿名内部类的作用与格式" class="headerlink" title="定义匿名内部类的作用与格式"></a>定义匿名内部类的作用与格式</h3><ol><li><p>作用</p><p>匿名内部类是创建某个类型子类对象的快捷方式。</p></li><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类或接口()&#123;</span><br><span class="line"><span class="comment">//进行方法重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已经存在的父类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义并创建该父类的子类对象，并用多态的方式赋值给父类引用变量</span></span><br><span class="line">Person  p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“我吃了”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用eat方法</span></span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure><p>使用匿名对象的方式，将定义子类与创建子类对象两个步骤由一个格式一次完成，。虽然是两个步骤，但是两个步骤是连在一起完成的。</p><p>匿名内部类如果不定义变量引用，则也是匿名对象。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“我吃了”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.eat();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static关键字</title>
      <link href="posts/ce244871.html"/>
      <url>posts/ce244871.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？</p><p>可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。</p><hr><p>概念解读：</p><p>比如有个学生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    String schoolName = “淮南师范学院”;   <span class="comment">//学校名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学生的年龄和姓名可能都不一样，但是学生都属于同一个学校，我们每次创建一个学生的时候，内存就会开辟一个空间，成员变量也会随之进来，，比如创建五个对象，学校名字变量也会创建五次，都是一样的，这就会照成浪费</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201101163257.png"></p><p>解决的方法:</p><p>变量schoolName从堆内存拿出来，放到一个地方去，让所有的学生对象共享一个schoolName变量</p><p>name，age属于对象自己的属性，对象自己特有的数据</p><p>schoolName应该作为对象的共享数据出现</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201101163625.png"></p><p>如何实现对象的共享数据？</p><p>在数据的前面加上static修饰</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol><li><p>被static修饰的成员变量属于类，不属于这个类的某个对象。</p><p><font color = "red">也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量</font></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo d1 = <span class="keyword">new</span> Demo();</span><br><span class="line">        Demo d2 = <span class="keyword">new</span> Demo();</span><br><span class="line">        d1.num = <span class="number">200</span>;</span><br><span class="line">        System.out.println(d1.num); <span class="comment">//结果为200</span></span><br><span class="line">        System.out.println(d2.num); <span class="comment">//结果为200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>被static修饰的成员可以并且建议通过类名直接访问。</p></li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><p>静态内容是优先于对象存在，只能访问静态（原因是因为，生命周期不同，静态优先于非静态存在内存中，静态出现的时候，非静态还没有出现），不能使用this/super（this代表本类引用，静态优于对象，没有对象，this就没有用，super同理）。静态修饰的内容存于静态区。</p></li><li><p>同一个类中，静态成员只能访问静态成员</p></li><li><p>main方法为静态方法仅仅为程序执行入口，它不属于任何一个对象，可以定义在任意类中。</p><blockquote><p>问题：</p><p>static修饰到底什么时候使用，应用场景</p><p>static修饰成员变量，成员方法</p><blockquote><p>成员变量加static，根据具体事物，具体分析问题</p><p>定义事物的时候，多个事物之间是否有共性的数据</p><p>请你将共性的数据定义为静态的成员变量</p></blockquote><blockquote><p>成员方法加static，跟着变量走</p><p>如果方法，没有调用过非静态成员，将方法定义为静态</p></blockquote></blockquote></li><li><p>多态调用中，编译运行都看“=”左边的父类，</p><p> 父类有，编译成功，父类没有，编译失败。</p><p> <strong>运行，静态方法，运行父类中的静态方法</strong></p><p> 运行，非静态方法，运行子类的重写方法</p><p> 成员变量，编译运行全是父类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.printf(<span class="string">&quot;父类的静态方法show&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.printf(<span class="string">&quot;子类的静态方法show&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fu f  =<span class="keyword">new</span> Zi();<span class="comment">//多态调用</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用还是父类的静态方法，原因：静态属于类，不属于对象</span></span><br><span class="line">      <span class="comment">//对象的多态性，静态和对象无关，父类的引用，静态方法</span></span><br><span class="line">        f.show(); <span class="comment">//打印会输出父类的方法show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="定义静态常量"><a href="#定义静态常量" class="headerlink" title="定义静态常量"></a>定义静态常量</h1><p>开发中，我们想在类中定义一个静态常量，通常使用<code>public static final修饰的变量</code>来完成定义。此时变量名用全部大写，多个单词使用下划线连接。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure><p>注意：</p><p>接口中的每个成员变量都默认使用public static final修饰。</p><p>所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值。可以直接用接口名访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方位接口中的静态变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inter.COUNT</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="posts/af55167d.html"/>
      <url>posts/af55167d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？</p><p>要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p>final修饰类不可以被继承，但是可以继承其他类。这种类在使用方式上没有任何变化，包括创建对象，调用方法，和之前没有区别，只是他不能被继承</p><h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。</p><h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><p>final修饰的变量称为常量，这些变量只能赋值一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">i = <span class="number">30</span>; <span class="comment">//赋值报错，final修饰的变量只能赋值一次</span></span><br></pre></td></tr></table></figure><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>final还可以修饰引用变量</p><p>引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">p = p2; <span class="comment">//final修饰的变量p，所记录的地址值不能改变</span></span><br><span class="line">p.name = <span class="string">&quot;小明&quot;</span>;<span class="comment">//可以更改p对象中name属性值</span></span><br></pre></td></tr></table></figure><p>p不能为别的对象，而p对象中的name或age属性值可更改。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">final 修饰成员变量</span></span><br><span class="line"><span class="comment">成员变量，在堆内存，具有默认值</span></span><br><span class="line"><span class="comment">final修饰的成员变量，固定的不是内存的默认值</span></span><br><span class="line"><span class="comment">固定的是，成员变量的手动赋值，绝对不是内存的默认</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果手动不赋值，可以在构造器利用构造器赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以采用手动直接赋值，或者构造器的方法都可以，只要保证，<code>被final修饰的成员变量，只能被赋值一次</code>，<strong>在创建对象前赋值</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】第二章：操作系统基础操作</title>
      <link href="posts/39515ecd.html"/>
      <url>posts/39515ecd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h1><ol><li><p>CPU, I/O, 内存通过总线连接</p></li><li><p>DISK（硬盘）: 存放OS</p><p>BIOS：基本I/O处理系统</p><p>Bootloader: 加载OS到内存中</p></li><li><p>当电脑通电时，段寄存器CS和指令寄存器IP<code>合在一起</code>能够确定一个内存地址，例如CS:IP = 0xf000:fff0。刚开始加电，以x86为例，bios会从0xf000:fff0这个地址开始执行，然后会执行接下来的一系列工作，包括第四点的自检</p></li><li><p>POST(加电自检)，寻找显卡和执行BIOS。(显示器，键盘…是否正常)</p></li><li><p>步骤：</p><ul><li><p>BIOS：将Bootloader从磁盘的磁盘的引导扇区(在硬盘的第一个扇区，也就是512字节)加载到0x7c00，跳转到CS:IP=0000:7c00的内存区域(以便下一步)，这个时候cpu的控制权已经交给Bootloader了</p></li><li><p>Bootloader：将操作系统的代码和数据从硬盘加载到内存中；跳转到操作系统的起始地址，这个时候cpu的控制权已经交给os了</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201031225845.png"></p></li></ul></li><li><p>系统调用：(来源于应用程序)应用程序主动向操作系统发出服务请求</p></li><li><p>异常：(来源于不良的应用程序)非法指令或其它花的处理状态(如：内存出错)</p></li><li><p>中断：(来源于外设)来自不同的硬件设备的计时器和网络的中断</p></li><li><p>为什么应用程序不能直接访问硬件而是通过操作系统？</p><ul><li>计算机运行时，内核是被信任的第三方</li><li>只有内核可以执行特权指令</li><li>为了方便应用程序</li></ul></li><li><p>讨论的问题：操作系统如何设计和实现中断/异常和系统调用；他们三者的区别和特点。</p><ol><li><p>产生的源头：</p><ul><li>中断：外设(键盘/鼠标/网卡/声卡/显卡，可以产生各种事件)</li><li>异常：应用程序意想不到的行为(例：异常，恶意程序，应用程序需要的资源未得到满足)</li><li>系统调用(system call)：应用程序请求操作提供服务(例：打开/关闭/读写文件，发送网络包)</li></ul></li><li><p>处理时间</p><ul><li>中断：异步（当这个事件产生的时候，我们的应用程序不知道他什么时候会产生，无法预测）</li><li>异常：同步</li><li>系统调用：同步或异步</li></ul><blockquote><p>异步同步我没有理解，弹幕上说，异步不可预知，同步可以预知</p></blockquote></li><li><p>响应</p><ul><li>中断：持续，对用户应用程序时透明的（因为操作系统把中断过程完成了，我们感知不到）</li><li>异常：杀死或者重新执行意想不到的应用程序指令</li><li>系统调用：等待和持续</li></ul></li></ol></li></ol><h1 id="中断-异常和系统调用"><a href="#中断-异常和系统调用" class="headerlink" title="中断/异常和系统调用"></a>中断/异常和系统调用</h1><ol><li><p>中断/异常处理机制</p><p>中断是外设的事件</p><p>异常是CPU的事件</p><p>中断/异常迫使CPU访问一些被中断和异常服务访问的功能</p></li><li><p>中断处理机制</p><p>硬件：设置中断标记(CPU初始化)</p><ul><li>将内部/外部事件设置中断标记；</li><li>中断事件的ID(程序访问的中断向量地址)</li></ul><p>软件(操作系统)：</p><ul><li>保存当前处理状态</li><li>中断服务程序处理</li><li>清除中断标记</li><li>恢复之前保存的处理状态</li></ul></li><li><p>异常处理机制</p><p>异常：异常编号</p><ul><li>保存现场</li><li>异常处理：杀死产生异常的程序；重新执行异常指令</li><li>恢复现场</li></ul></li><li><p>系统调用</p><ul><li>一条指令会触发一个系统调用</li><li>程序访问主要是通过高层次的API接口而不是直接进行系统调用。</li><li>通常情况下，存在与每个系统调用相关的序号，系统调用接口根据这些序号来维护表的索引</li><li>系统调用接口调用内核态中预期的系统调用，并返回系统调用的状态和其它任何返回值</li><li>用户不需要知道系统调用是如何实现的，只需要获取API和了解操作新系统将什么作为返回结果。操作系统接口的细节大部分都隐藏在API中，并通过运行程序支持的库来管理</li><li>用户态：应用程序在执行的过程中，CPU执行的特权级的状态(很低，不能访问特殊机器指令和IO)</li><li>内核态：应用程序在执行的过程中，CPU执行的特权级的状态(高，操作系统可以执行CPU任何一条指令)</li><li>系统调用时涉及到特权级从用户态到内核态的转换，应用程序和操作系统有各自的堆栈，这两个变化比函数调用的开销更大，但更安全和可靠。(而程序调用是在一个栈空间实现参数的调用和返回)</li></ul></li><li><p>跨越操作系统边界的开销</p><ul><li><p>在执行时间上的开销超过程序调用</p></li><li><p>开销包括：</p><p>建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销；<br>建立内核堆栈(操作系统和应用程序的堆栈不一样)；<br>验证参数(操作系统会检查数据)；<br>内核态映射到用户态的地址空间，更新页面映射权限(内存拷贝开销)；<br>内核态独立地址空间TLB。</p></li></ul></li></ol><blockquote><p>参考：<a href="https://blog.csdn.net/iwanderu/article/details/103934399">https://blog.csdn.net/iwanderu/article/details/103934399</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口的区别</title>
      <link href="posts/4a128e89.html"/>
      <url>posts/4a128e89.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>举例：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">犬：</span><br><span class="line">    行为：</span><br><span class="line">        吼叫；</span><br><span class="line">        吃饭；</span><br><span class="line">缉毒犬：</span><br><span class="line">    行为：</span><br><span class="line">        吼叫；</span><br><span class="line">        吃饭；</span><br><span class="line">        缉毒；</span><br></pre></td></tr></table></figure></li><li><p>思考</p><p> 由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。</p><p> 可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。</p><p> 代码演示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 缉毒</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 缉毒();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义犬科的这个提醒的共性功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 吃饭();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 吼叫();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，</span></span><br><span class="line"><span class="comment">//由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 缉毒犬 <span class="keyword">extends</span> 犬科 <span class="keyword">implements</span> 缉毒</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 缉毒() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 吃饭() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 吼叫() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 缉毒猪 <span class="keyword">implements</span> 缉毒</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 缉毒() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>通过上面的例子总结：</p><p> <strong>相同点:</strong></p><ul><li><p>都位于继承的顶端,用于被其他类实现或继承;</p></li><li><p>都不能直接实例化对象;</p></li><li><p>都包含抽象方法,其子类都必须覆写这些抽象方法;</p></li></ul><p> <strong>区别:</strong></p><ul><li><p>抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;</p></li><li><p>一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)</p></li><li><p>抽象类是这个事物中应该具备的你内容, 共性</p></li><li><p>接口是这个事物中的额外内容,</p><blockquote><p>抽象类是同一个事物的共性，</p><p>而接口就是额外多出来的功能，他有你没有，你有我没有，并不是大家都有的功能</p></blockquote></li></ul><p> <strong>二者的选用</strong>：</p><ul><li><p>优先选用接口,尽量少用抽象类;</p></li><li><p>需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>instanceof关键字</title>
      <link href="posts/15b3e85e.html"/>
      <url>posts/15b3e85e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java中有个关键字叫<code>instanceof</code>，返回值是true或者false</p><p>它是用来比较引用数据类型的关键字，一个引用类型的变量,是不是这个类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;学生在休息睡觉&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;老师在休息&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，建立一个抽象类Person，定义抽象方法sleep（），再建立学生类与老师类继承Person类，重写抽象方法</p><p>建立对象的时候，利用多态性，可以这样写</p><p><code>Person p = new Student();</code>也可以<code>Person p = new Teacher();</code>，</p><p>而instanceof就可以用来比较这个p是是Student类型对象,还是Teacher类型对象</p><p>写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用变量 <span class="keyword">instanceof</span> 类名</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p <span class="keyword">instanceof</span> Student  <span class="comment">//比较,p是不是Student类型的对象,如果是,intanceof返回true</span></span><br></pre></td></tr></table></figure><p>附上test类代码以及结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = p <span class="keyword">instanceof</span> Student;</span><br><span class="line">System.out.println(b);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> c = p <span class="keyword">instanceof</span> Teacher;        </span><br><span class="line">    System.out.println(c);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中还有前提条件就是，老师和学生一定要继承Person类才可以用instanceof关键字，否则会编译报错</p><p>用代码解释就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再添加一个动物抽象类，测试类中这样写到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">b = p <span class="keyword">instanceof</span> Animal;  <span class="comment">//这样写错误的，编译不能通过</span></span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instanceof比较的两个变量一定要有关系才可以用</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>super关键字</title>
      <link href="posts/f6ea766.html"/>
      <url>posts/f6ea766.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>和this一样，<code>super.</code>的方式，是用来引用父类的变量与方法的</p><p>除此之外，super还可以调用父类的构造方法</p><p> <code>super()</code>调用的是父类的空参数构造</p><p><code>super(参数)</code> 调用的是父类的有参数构造方法</p><p>其中要注意的是，子类的构造方法, 有一个默认添加的构造方法，子类构造方法中的第一行,有一个隐式代码 super()，<font color=brown>（注：这里说一下，子类的<strong>所有构造方法</strong>，无论重载多少个，第一行都是 super()）</font></p><p>即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的构造方法第一行super语句,调用父类的构造方法</p><p>代码理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台会输出<code>父类构造方法</code>字样，意思就是我上面说的那样，子类的构造方法, 有一个默认添加的构造方法，子类构造方法的第一行,有一个隐式代码 super()</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？</p><p>这时是没有的，因为this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。</p><p> super(参数) 与 this(参数) 不能同时在构造方法中存在</p><p>小结论: 无论如何,子类的所有构造方法,直接,间接必须调用到父类构造方法</p><hr><blockquote><p>这里吐槽一下，这些东西我早忘记了….一点印象都没有…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this关键字</title>
      <link href="posts/75f5b5c3.html"/>
      <url>posts/75f5b5c3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>this.的方式</code>，区分局部变量和成员变量同名情况</p><p>除此之外，this还可以在构造方法之间调用，语法格式是<code>this()</code>,而且<strong>只能写在构造方法的第一行</strong></p><p>代码理解：</p><p>创建一个人，出生的时候如果不初始化，默认给一个name和age代码，不是null和0，是指定的数字</p><p>如果不用this，代码可以这样表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getset省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到无论是有参构造器还是无参构造器，两个方法的作用都是给对象的成员变量初始化，所以如果一个方法调用另一个方法，可以使代码减少很多</p><p>正确的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//调用了有参数的构造方法</span></span><br><span class="line"><span class="comment">//参数李四,20传递给了变量name,age</span></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  构造方法,传递String,int</span></span><br><span class="line"><span class="comment"> *  在创建对象的同时为成员变量赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getset省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立对象的时候，如果没有指定参数，就会默认调用无参构造器，其中的<code>this(&quot;李四&quot;,20);</code>调用有参构造，然后给成员变量初始化，就会达到，建立对象的同时给成员变量赋值的效果</p><p>注意：<strong>调用其他构造方法的语句必须<font color=red>定义在构造方法的第一行</font>，原因是初始化动作要最先执行。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于构造方法</title>
      <link href="posts/7b749a13.html"/>
      <url>posts/7b749a13.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>构造方法的作用就是: 在new 的同时对成员变量赋值, 给对象的属性初始化赋值  new Person 对属性 name,age赋值</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限  方法名(参数列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>方法的名字,必须和类的名字完全一致</p><p>构造方法不允许写返回值类型  , void 也不能写</p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>构造方法在new 的时候,自动执行，而且只允许一次</p><p>每个类必须拥有构造方法，不写也有，编译的时候，javac, 会自动检查类中是否有构造方法，如果有,就这样的，如果没有,编译器就会自动添加一个构造方法</p><p> 编译器自动添加的构造方法: public Person(){}</p><p>自己手写了构造方法,编译的时候,不会自动添加构造方法!</p><h1 id="内存详解"><a href="#内存详解" class="headerlink" title="内存详解"></a>内存详解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person的构造方法，拥有参数列表</span></span><br><span class="line">Person(<span class="keyword">int</span> age, String name) &#123;</span><br><span class="line"><span class="comment">// 接受到创建对象时传递进来的值，将值赋给成员属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">set/get省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建Person对象，并明确对象的年龄和姓名</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序最开始，main方法压栈运行，执行<code>Person p = new Person(23, &quot;张三&quot;);</code>,堆内存会出现一块空间给Person，成员变量 跟随对象 创建进入堆内存，并且初始化默认值，0与null,，然后接着<strong>对象会调用自己的构造方法</strong>，构造方法会进入栈内存运行</p><p>构造方法压栈运行，对象会将最初的<code>张三</code>与<code>23</code>传给构造方法，将自己的内存地址传给this关键字，然后赋值成员变量，构造方法运行完成后，弹栈死亡，<strong>构造方法运行结束了，整个对象才算建立完成</strong>，然后p指向对象地址</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201024160045.png"></p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><ol><li>一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的,根据自己需求</li><li>构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。<em>这个应该就是应对考试的，记一下吧</em></li></ol><h1 id="构造方法和一般方法区别"><a href="#构造方法和一般方法区别" class="headerlink" title="构造方法和一般方法区别"></a>构造方法和一般方法区别</h1><ol><li>构造方法在对象创建时就执行了，而且只执行一次。<strong>是对象调用的</strong></li><li>一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。<strong>是我们自己调用的</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态向上与向下转型</title>
      <link href="posts/fc8e9806.html"/>
      <url>posts/fc8e9806.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h1><p>多态中特有的体现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类的引用 变量 = new 子类的对象();</span><br></pre></td></tr></table></figure><p>java是一门强制数据类型的语言，参数运算的数据，保证类型的统一性，</p><p>如果数据类型不一致的时候，只有两种情况，一种是<code>自动类型提升</code>，一种是<code>强制类型转换</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fu f = new Zi();</span><br></pre></td></tr></table></figure><p>这条语句明显左右两边类型不一样，但是编译运行的时候，却不受影响，只有上面说的两种情况，但是我没有参与，也就是强制转换其他类型，它只有一种解释，就是<code>自动类型提升</code>, </p><p>所谓自动类型提升就是，将取值范围小的自动提升为取值范围大的，而引用数据类型没有取值范围这个概念，但是原理都是一样的，范围小的看成是子类，范围大的看成是父类，<code>Fu f = new Zi();</code>这行代码，f就是父类类型，将子类提升为了父类类型，这个提升就是<code>向上转型</code>。</p><p><strong>实际上，当new 子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。</strong></p><p>向上转型的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：Person p = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><p>向上转型只能调用子类和父类的公有内容，这也是多态的一个好处，但是也有弊端，就是不能调用子类的特有方法，但是可以向下转型</p><h1 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h1><p>多态调用，如果要调用子类的特有内容，可以向下转型，父类类型强制转换子类类型，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fu f = <span class="keyword">new</span> Zi();<span class="comment">//多态调用，f向上转型，现在下一步我要调用子类特有方法</span></span><br><span class="line">Zi z = (Zi)f;    <span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><p>一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！</p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类类型的变量;</span><br><span class="line">如:Student stu = (Student) p;  </span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>什么时候使用向上转型</p><p>当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。</p></li><li><p>什么时候使用向下转型</p><p>当要使用子类特有功能时，就需要使用向下转型。</p></li><li><p>向下转型的好处：可以使用子类特有功能。</p></li><li><p>弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。</p><p>如：if( !a instanceof Dog){…}</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态概述以及成员特点</title>
      <link href="posts/47b88999.html"/>
      <url>posts/47b88999.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多态概述"><a href="#多态概述" class="headerlink" title="多态概述"></a>多态概述</h1><p>我理解的多态就是<code>同一种事物的多种形态</code></p><p>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。</p><p>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</p><p>Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。</p><p>如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。</p><h1 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h1><ul><li>父类引用变量可以指向子类对象</li><li>多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。</li><li>在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</li></ul><h1 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h1><ol><li><p>先看成员变量</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 建立一个测试类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(f.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 控制台会显示1,也就是父类的成员变量值，他没有走子类的</p></li><li><p>如果是方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        f.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 控制台会显示zi,也就是子类的重写方法</p></li></ol><blockquote><p>总结</p><ol><li><p>成员变量:</p><p> 编译的时候, 参考父类中有没有这个变量,如果有,编译成功,没有编译失败</p><p> 运行的时候, 运行的是父类中的变量值<br><font color=#b33b63> <strong><em>编译运行全看父类</em></strong></font></p></li></ol><ol start="2"><li><p>成员方法:</p><p>   编译的时候, 参考父类中有没有这个方法,如果有,编译成功,没有编译失败</p><p>   运行的时候, 运行的是子类的重写方法</p><p>   <font color=#b33b63><strong><em>编译看父类，运行看子类</em></strong></font></p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo绑定个人域名</title>
      <link href="posts/d026edc8.html"/>
      <url>posts/d026edc8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h1><ol><li><p>先进入桌面, <code>cd 你的hexo本地目录</code>, <code>cd source</code>, <code>touch CNAME</code>创建CNAME文件，写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shuigwh.cn</span><br></pre></td></tr></table></figure></li><li><p>保存,部署远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li></ol><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>www是<code>xxxx.github.io</code></p><p>@对应的是<code>xxxx.github.io</code>的IP，可以ping拿到IP</p><p>即</p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>记录值</th></tr></thead><tbody><tr><td>www</td><td>CNAME</td><td>xxxx.github.io</td></tr><tr><td>@</td><td>A</td><td>xxx.xxx.xxx.xxx</td></tr></tbody></table><p>然后保存，这个时候等一会就可以访问了，但是只能访问http://的形式</p><p>到远程库的设置里面，<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201023142757.png"></p><p>将这个https勾选，保存即可</p><p>过一会就可以访问https://的形式了</p><blockquote><p>参考：<a href="https://blog.csdn.net/yucicheung/article/details/79560027">https://blog.csdn.net/yucicheung/article/details/79560027</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承，实现总结</title>
      <link href="posts/1eedea8a.html"/>
      <url>posts/1eedea8a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p><code>类与类</code>之间是继承关系，只能单继承，子类自动继承父类的所有数据，即成员变量和方法</p><blockquote><p> 注意：抽象类，其中可以包含抽象方法，也可以包含具体的方法，但是如果有抽象方法，这个类一定是抽象类</p><p> 类继承抽象类，要重写抽象类里面的所有抽象方法</p></blockquote><blockquote><p>接口，里面只能包含常量（默认public static final）与抽象方法(默认public abstract),就算不写修饰符，也就是public static final abstract 这些，也是可以的</p></blockquote></li><li><p><code>类与接口</code>的之间是实现关系(implement)，可以多实现接口，一旦类实现接口，必须要重写接口里面的所有抽象方法</p></li><li><p><code>接口与接口</code>之间是继承(extends)，支持多继承（因为都是抽象方法，所以不像类只能单继承，存在安全隐患）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于接口与继承的理解</title>
      <link href="posts/18276965.html"/>
      <url>posts/18276965.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="继承的弊端"><a href="#继承的弊端" class="headerlink" title="继承的弊端"></a>继承的弊端</h1><p>在Java中，继承不能多继承，也就是一个类只能继承一个类，不能继承多个类，举个列子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bbbb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在来一个类叫C，c同时继承A 和B类，当实例化c的时候，调用父类的function方法时候,这个时候就不知道应该调用那个类中的function方法了，这也是继承的局限性</p><h1 id="接口的好处"><a href="#接口的好处" class="headerlink" title="接口的好处"></a>接口的好处</h1><p>所以就有了接口，Java中，一个类可以实现多个接口，也可以理解同时继承多个接口，但是和继承不同的是，接口里面的方法全是抽象方法，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是两个接口，里面的方法都是一样的，建立一个C类，实现这两个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口要重写里面的抽象方法，由于抽象方法名字都是一样的，所以写一次就可以了，接口的里面的方法全都是抽象的，即使名字一样也不要紧，由实现接口的类自己定，所以它和继承不一样</p><blockquote><p>总结：类的多继承，当多个父类中有相同功能时，子类调用会产生不确定性，所以会存在安全隐患，<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口的多实现，没有安全隐患，原因在于接口中的方法全是抽象，没有主体</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用数据类型传参</title>
      <link href="posts/626c8828.html"/>
      <url>posts/626c8828.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引用数据类型传参会涉及到堆内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        System.out.println(p.name);<span class="comment">//张三</span></span><br><span class="line">        function(p);</span><br><span class="line">        System.out.println(p.name);<span class="comment">//李四</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> statc <span class="keyword">void</span> <span class="title">function</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        p.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序开始运行，main方法先压栈执行，<code>Person p = new Person();</code>堆内存会开辟一块内存空间，Person对象，成员变量name随着对象建立一起进入堆内存，并且赋初值null,此内存地址假设是0x01，c变量会指向堆内存的0x01地址，<code>p.name = &quot;张三&quot;;</code>null被<code>张三</code>覆盖，接着打印p.name,会显示张三</p><p>运行<code>function(p)；</code>,function方法会压栈执行，传参给的其实p中保存的地址，所以function方法中的p也指向堆内存的内存地址0x01,此时两个变量p都指向了同一片内存空间地址，function方法中<code>p.name=&quot;李四&quot;</code>,原来的张三又被李四覆盖，function方法运行完毕，function方法就会弹出栈内存死亡，main方法继续运行<code> System.out.println(p.name);</code>，控制台会显示李四</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021140357.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成员变量和局部变量区别</title>
      <link href="posts/40dd4c9d.html"/>
      <url>posts/40dd4c9d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>定义位置上的区别</p><p>成员变量，定义在类中，方法外</p><p>局部变量，方法内，语句外</p></li><li><p>作用域不同</p><p>成员变量，作用范围是整个类</p><p>局部变量，方法内，语句内</p></li><li><p><font color=green><strong>默认值不同</strong></font></p><p>成员变量有自己的默认值（对象在内存中的理解说过）</p><p><font color = red><strong>局部变量，没有默认值，不赋值不能使用</strong></font></p></li><li><p><font color=green><strong>内存位置不同（对象在内存中的理解说过）</strong></font></p><p>成员变量，跟随对象进入堆内存存储</p><p>局部变量，跟随自己的方法，进入栈内存</p></li><li><p><font color=green><strong>生命周期不同</strong></font></p><p>成员变量，跟随对象，在堆内存中存储，等待JVM（虚拟机）清理          生命周期较长</p><p>局部变量，跟随方法，方法出栈                                                                                    生命周期较短</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象在内存中的理解</title>
      <link href="posts/576f6a89.html"/>
      <url>posts/576f6a89.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中有栈内存和堆内存</p><p><code>栈内存</code>是运行方法用的，<code>堆内存</code>是存储容器用的</p><p><del>一个完整的Java程序如果要运行，先从main方法进行，main先压栈，new出来的对象实力，在堆内存里面</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小汽车在跑&quot;</span>+color+<span class="string">&quot;..&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Car c = <span class="keyword">new</span> Car();</span><br><span class="line">        c.color = <span class="string">&quot;无色&quot;</span>;</span><br><span class="line">        c.count = <span class="number">5</span>;</span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一个完整的Java程序,一个car类，一个测试类</p><p>程序开始运行</p><p>main先压栈，运行第一行代码<code>Car c = new Car();</code>，Java虚拟机会在堆内存开辟一快空间，有了空间，就会有属于自己的内存地址</p><p>例如这个地址是<code>0x001</code>,这块空间是new car 创建的</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021123430.png" style="zoom: 80%;" /><p>对象在对内存创建后，类的成员变量，会跟随对象进入到堆内存中，并且会赋值默认值，这个默认值是更加成员变量的类型而定的，就比如<code>Car c = new Car()</code>,如果后面没有赋值，那么他的成员变量的默认值就是<code>null</code>和<code>0</code>，即下图：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021124434.jpg" style="zoom: 67%;" /><p>这就是<code>new Car();</code>在堆内存中的执行时的示意图</p><p>此时对象就建立完成了，然后Java虚拟机就会将这个对象内存地址传送给引用变量c,c就会指向这片内存空间，即</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021125009.jpg" style="zoom:80%;" /><p>所以，真正的对象是new出来的，而c保存的其实是对象内存的地址，所以，直接把c叫做car类的变量也没有问题</p><p>接着，main开始运行下一条代码，<code>c.color = &quot;无色&quot;;</code>，相应的，堆内存中的<code>null</code>会被<code>无色</code>覆盖，<code>c.count = 5;</code>堆内存中的<code>0</code>会被<code>5</code>覆盖</p><p>当程序执行<code>c.run();</code>，类中的方法run就会进栈执行，虚拟机会再次开辟空间是run方法压栈运行</p><p>run方法中只有一句<code>System.out.println(&quot;小汽车在跑&quot;+color+&quot;..&quot;+count);</code>,其中的color与count可以这样理解，方法run是对象c调用，那么其中的color和count指的就是对象c的成员变量，所以<code>无色</code>和<code>5</code>就会被打印到控制台上，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021131215.jpg" style="zoom: 80%;" /><p>打印完成后，run方法就会结束，run方法就要出栈死亡，这个过程叫弹栈，弹出栈内存死亡，死亡了，内存就会被释放</p><p>main也随即运行完成了，也会弹出栈内存死亡，释放内存</p><p>main死亡之后，变量c将不会再指向堆内存的对象地址，所以这个对象在内存中也会变成垃圾    </p><blockquote><p> 这里要说一下，栈内存中的方法用完了就会释放，空间就会出来了，而堆内存中的对象或者是数组，它自己不会释放，他要等着虚拟机清理，而虚拟机清理垃圾是不需要我们考虑的，它属于自动行为</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---定状同从句</title>
      <link href="posts/c9325fa6.html"/>
      <url>posts/c9325fa6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131032.png"></p><p>以下这些词都可以用同位语从句进行解释</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131122.png" style="zoom:67%;" /><p>例句：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131347.png" style="zoom:80%;" /><blockquote><p>同位语从句有很多连接词，但是百分之99都是that</p></blockquote><h1 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h1><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131753.png" style="zoom: 80%;" /><h2 id="连词"><a href="#连词" class="headerlink" title="连词"></a>连词</h2><h3 id="修饰人-who-whom"><a href="#修饰人-who-whom" class="headerlink" title="修饰人(who/whom)"></a>修饰人(who/whom)</h3><ol><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132039.png" style="zoom:67%;" /></li><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132137.png" style="zoom:67%;" /></li></ol><h3 id="修饰物（that-which）"><a href="#修饰物（that-which）" class="headerlink" title="修饰物（that/which）"></a>修饰物（that/which）</h3><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019140350.png" style="zoom:67%;" /><p>其中that和which不能乱用</p><p>这种情况只能用that，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132706.png" style="zoom:67%;" /><blockquote><p> 先行词就是被修饰的那个名词</p></blockquote><h3 id="修饰句，表示总结（which）"><a href="#修饰句，表示总结（which）" class="headerlink" title="修饰句，表示总结（which）"></a>修饰句，表示总结（which）</h3><p>这种情况只能用which，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132929.png" style="zoom:67%;" /><h4 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h4><p><strong><font color='green'><em>修饰句，表示总结</em></font></strong></p><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019133201.png" style="zoom:67%;" /><p>这就是修饰的前面整句话，所以必须用which，必须用<code>,</code></p><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019134710.png" style="zoom:67%;" /><p>这句话，如果不用定语从句，这句话是这样翻译的：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019134757.png" style="zoom:80%;" /><p>这是两个简单句，完全可以。</p><p>如果用定语从句可以这样</p><p>分析：</p><p><code>这</code>修饰前面的<code>中国的经济正迅速发展</code>这句话，所以是定语从句，所以也可以这样写，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135028.png" style="zoom:80%;" /><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135509.png" style="zoom:67%;" /><h2 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h2><ul><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135729.png" style="zoom:80%;" /></li><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019140523.png" style="zoom: 80%;" /></li></ul><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><blockquote><p>做阅读可能会遇到下面的几个情况</p></blockquote><p><strong><em><font color='green'>介词+which</font></em></strong></p><p>这也是定语从句，翻译方法：</p><ol><li>介词先砍掉，</li><li>然后把介词放到从句里面去</li></ol><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141059.png"></p><p>分析：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141152.png"></p><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141234.png"></p><p>分析：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141333.png" style="zoom:80%;" /><hr><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019142136.png" style="zoom:80%;" /><blockquote><p><font color='brown'><strong>连词如果在定语从句中做宾语是可以省略的</strong></font>，这里要注意，可能阅读会有陷阱</p></blockquote><h1 id="状语从句"><a href="#状语从句" class="headerlink" title="状语从句"></a>状语从句</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019143906.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度云在线视频加速方法</title>
      <link href="posts/9ced7ac.html"/>
      <url>posts/9ced7ac.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>网页版百度网盘视频今天看着有点慢，想加速，搜了一下，防止遗忘，在此记录一下</p></blockquote><p>打开网页版，然后打开控制台，输入以下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">videojs.getPlayers(<span class="string">&quot;video-player&quot;</span>).html5player.tech_.setPlaybackRate(<span class="number">1.5</span>) </span><br></pre></td></tr></table></figure><p>这是1.5倍播放，需要多少，直接在后面改参数就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 实用小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百度网盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---主宾表从句</title>
      <link href="posts/ca22eae1.html"/>
      <url>posts/ca22eae1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="从句概念"><a href="#从句概念" class="headerlink" title="从句概念"></a>从句概念</h1><p>一句话做定语=定语从句</p><p>一句话做宾语=宾语从句</p><p>一句话做表语=表语从句</p><h1 id="主从句之间的连接"><a href="#主从句之间的连接" class="headerlink" title="主从句之间的连接"></a>主从句之间的连接</h1><p>桥梁：连词</p><h2 id="连词一（从句完整）"><a href="#连词一（从句完整）" class="headerlink" title="连词一（从句完整）"></a>连词一（从句完整）</h2><p><strong><em>that/whether/if</em></strong></p><p>从句完整的时候用that连接</p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225156.png" style="zoom:50%;" /><p>有时候也用whether或者if</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225331.png" style="zoom:50%;" /><p>注意，不能使用if的情况</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225431.png" style="zoom:67%;" /><p>所以为了方便，一直用whether就可以了</p><h2 id="连词二（从句缺人）"><a href="#连词二（从句缺人）" class="headerlink" title="连词二（从句缺人）"></a>连词二（从句缺人）</h2><p><strong><em>who/ whom</em></strong></p><ul><li><p>who是在从句中做主语</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225926.png" style="zoom: 80%;" /></li><li><p>whom是在从句中做宾语</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230129.png" style="zoom:80%;" /></li></ul><p>举例：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230343.png" style="zoom:80%;" /><h2 id="连词三（从句缺物）"><a href="#连词三（从句缺物）" class="headerlink" title="连词三（从句缺物）"></a>连词三（从句缺物）</h2><p><strong><em>what</em></strong></p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201018122713.png" style="zoom:67%;" /><h2 id="连词四（从句需状语）"><a href="#连词四（从句需状语）" class="headerlink" title="连词四（从句需状语）"></a>连词四（从句需状语）</h2><p><strong><em>when(时间)/where（地点）/why（原因）/how（方式）</em></strong></p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230758.png" style="zoom: 80%;" /><h1 id="翻译从句的方法"><a href="#翻译从句的方法" class="headerlink" title="翻译从句的方法"></a>翻译从句的方法</h1><p>先把连词放在句子的空缺处，然后从左往右翻译</p><h1 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h1><h2 id="特殊主语从句"><a href="#特殊主语从句" class="headerlink" title="特殊主语从句"></a>特殊主语从句</h2><p>有道题是这样的</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232551.png" style="zoom: 80%;" /><p>这种情况是错误的，出现了两个动词</p><p>解决方法：</p><p>可以加个that</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232717.png"></p><p>但是前面有点长，要避免头重脚轻，把that引动的从句放到后面，前面加个形式主语it</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232847.png"></p><h1 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h1><h2 id="在及物动词后作宾语"><a href="#在及物动词后作宾语" class="headerlink" title="在及物动词后作宾语"></a>在及物动词后作宾语</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233317.png"></p><h2 id="在介词后面作宾语"><a href="#在介词后面作宾语" class="headerlink" title="在介词后面作宾语"></a>在介词后面作宾语</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233423.png"></p><p>宾从例句：</p><p>​    <img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233754.png" style="zoom: 67%;" /></p><h1 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234424.png"></p><p>这是个简单句，不是表语从句</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234452.png"></p><p>表语从句</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234929.png" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---句子成分</title>
      <link href="posts/92acea72.html"/>
      <url>posts/92acea72.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="主语"><a href="#主语" class="headerlink" title="主语"></a>主语</h1><p> 动作发出者</p><h2 id="找主语的方法"><a href="#找主语的方法" class="headerlink" title="找主语的方法"></a>找主语的方法</h2><ol><li>谓语动词的前面</li></ol><h1 id="宾语"><a href="#宾语" class="headerlink" title="宾语"></a>宾语</h1><p>动作承受者  名词类（及物动词后面的全是宾语）</p><p>动词不能直接做宾语，要修改成名词</p><p>动词 —&gt; 名词  的方法</p><pre><code>                                   1. to do                                                        2. doing</code></pre><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015132831.png"></p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015133020.png"></p><h2 id="找宾语的方法："><a href="#找宾语的方法：" class="headerlink" title="找宾语的方法："></a>找宾语的方法：</h2><ol><li>介词后面的</li><li>及物动词后面的</li></ol><h2 id="介宾结构"><a href="#介宾结构" class="headerlink" title="介宾结构"></a>介宾结构</h2><p>介词只能加，名词/doing/宾格，其他都是错的</p><h1 id="表语"><a href="#表语" class="headerlink" title="表语"></a>表语</h1><p>修饰主语, 名词或者形容词类</p><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015170014.png"></p><blockquote><p>改变世界还没有完成，所以用to do </p></blockquote><p>这里为什么要加个the</p><p>the的用法：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015170453.png"></p><h2 id="找表语的方法"><a href="#找表语的方法" class="headerlink" title="找表语的方法"></a>找表语的方法</h2><p>​    系动词后面的</p><p>​    凡是能用be动词替换的，包括be本身，都是主系表结构</p><h1 id="定语"><a href="#定语" class="headerlink" title="定语"></a>定语</h1><p>概念： 修饰名词的</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015171502.png"></p><p>当动词是doing，修饰名词，这个doing代表一个功能</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015171902.png"></p><p>定于可以在前面也可以在后面，当在前面的时候很简单，很短，</p><p>当在后面的时候一般都很复杂，要么是<code>to do</code>要么是<code>介词短语</code></p><h1 id="状语"><a href="#状语" class="headerlink" title="状语"></a>状语</h1><p>修饰形容词，动词，句子</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015172558.png" style="zoom:50%;" /><h1 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a>同位语</h1><p>修饰且等于名词</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015173540.png" style="zoom: 80%;" /><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015174440.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---句子结构</title>
      <link href="posts/5d143ecd.html"/>
      <url>posts/5d143ecd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="三个基本结构"><a href="#三个基本结构" class="headerlink" title="三个基本结构"></a>三个基本结构</h1><ol><li>主谓宾</li><li>主谓</li><li>主系表</li></ol><h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><ol><li><p>及物动词（有对象）</p></li><li><p>不及物动词</p><p>1和2叫实义动词</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014164711.png"></p></li><li><p>系动词（能用be替换）</p><p>​    例如：<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201014160925.png">，<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201014161100.png">，</p><p>​    <strong><em>凡是能用be动词替换的，包括be本身，都是主系表结构</em></strong></p></li><li><p>助词</p><p>时态，情态，否定</p></li></ol><hr><p>及物动词引导主谓宾，不及物动词引导主谓，系动词引导主系表</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014165529.png"></p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014165749.png"></p><p>判断结构</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014170701.png"></p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>可以先将代表修饰的词删掉<img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014170508.png"></p><h1 id="三大特殊结构"><a href="#三大特殊结构" class="headerlink" title="三大特殊结构"></a>三大特殊结构</h1><ol><li><p>主谓宾宾</p></li><li><p>主谓宾补</p></li><li><p>强调句</p><p>1和2  宾宾和宾补可以在中间加个be动词进行连接，可以连接的是宾补，不能的就是宾宾<br><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014173513.png"></p></li></ol><h2 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h2><p>格式：</p><p>​        强调主语：it is  + 人 +   who<br>​        强调状语：it is  + 物 +   that</p><hr><p>强调谁，就把谁放在前面，剩下的部分原封不动放在后面</p><p>举例：</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014174507.png"></p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 提交远程库命令</title>
      <link href="posts/f2b26283.html"/>
      <url>posts/f2b26283.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这几个命令怕以后忘记了，单独开个博文记录一下</p></blockquote><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="添加暂存区"><a href="#添加暂存区" class="headerlink" title="添加暂存区"></a>添加暂存区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;信息&quot;</span></span><br></pre></td></tr></table></figure><h2 id="推送远程库"><a href="#推送远程库" class="headerlink" title="推送远程库"></a>推送远程库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;远程地址&gt;</span><br><span class="line">git branch -M origin main</span><br><span class="line">git push -u origin &lt;main&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="查看本地库状态"><a href="#查看本地库状态" class="headerlink" title="查看本地库状态"></a>查看本地库状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="用于迁移"><a href="#用于迁移" class="headerlink" title="用于迁移"></a>用于迁移</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main //主分支和main分支合并</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git配置与仓库迁移</title>
      <link href="posts/2ad68004.html"/>
      <url>posts/2ad68004.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的账号不要了，上面的仓库需要迁移</p><p>于是….</p><p>就出现了很多问题，下面主要就记录下</p><h2 id="github加速"><a href="#github加速" class="headerlink" title="github加速"></a>github加速</h2><h3 id="有代理"><a href="#有代理" class="headerlink" title="有代理"></a>有代理</h3><p>我用的是v2rayn,查看端口号是<code>10808</code>,然后在<code>C:\Users\UserName\.gitconfig</code>文件添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">    proxy = http://127.0.0.1:10808</span><br><span class="line">[https]</span><br><span class="line">    proxy = http://127.0.0.1:10808</span><br></pre></td></tr></table></figure><p>，当然命令也可以，这里是直接打开文件添加，这是http的方式</p><p>ssh的方式是这样，打开<code>C:\Users\UserName\.ssh</code>,新建<code>config</code>文件填写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyCommand connect -S 127.0.0.1:10808 %h %p</span><br></pre></td></tr></table></figure><h3 id="无代理"><a href="#无代理" class="headerlink" title="无代理"></a>无代理</h3><p>我最先用的就是无代理，网上介绍代理全是ss,v2rayn我以为不可以，后来在一个<a href="https://www.youtube.com/watch?v=hKBhOXlQc4c&ab_channel=%E6%9D%9C%E8%BF%9C%E8%B6%85%E5%AE%98%E6%96%B9%E9%A2%91%E9%81%93">youtube</a>视频评论下残看到的原来端口号不一样</p><p>没有代理就在<code>C:\Windows\System32\drivers\etc</code>中host文件，写这两行</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009144812.png"></p><p>IP地址有时候会变，每次在这里<a href="https://www.ipaddress.com/%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%8B%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%9F%A5%E5%88%B0%E7%9A%84IP%E5%86%99%EF%BC%8C%E8%BF%99%E6%98%AFhttp%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86">https://www.ipaddress.com/查询一下，根据查到的IP写，这是http的方式，然后就可以了</a></p><p>实话实说，感觉利用梯子效果更好，这种改host文件的方法感觉没什么变化</p><h2 id="git的配置"><a href="#git的配置" class="headerlink" title="git的配置"></a>git的配置</h2><h3 id="添加key"><a href="#添加key" class="headerlink" title="添加key"></a>添加key</h3><p>清除之前的公钥和密钥文件，重新生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>一路回车</p><p>生成的公钥添加到github账号上面</p><p>然后验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 你的英文名     <span class="comment">#此英文名不需要跟GitHub账号保持一致</span></span><br><span class="line">git config --global user.email 你的邮箱      <span class="comment">#此邮箱不需要跟GitHub账号保持一致</span></span><br><span class="line">git config --global push.default matching</span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global core.editor <span class="string">&quot;vim&quot;</span></span><br></pre></td></tr></table></figure><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>因为我之前clone下的远程库有之前的地址，我要改一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:xxxxx.git</span><br></pre></td></tr></table></figure><p>master迁移到main分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main </span><br></pre></td></tr></table></figure><p>可以推送新的仓库了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main </span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/148110705?utm_source=qq&amp;utm_medium=social&amp;utm_oi=882705482219917312">https://zhuanlan.zhihu.com/p/148110705?utm_source=qq&amp;utm_medium=social&amp;utm_oi=882705482219917312</a></p><p><a href="https://zhuanlan.zhihu.com/p/48209762">https://zhuanlan.zhihu.com/p/48209762</a></p><p><a href="https://os.51cto.com/art/202009/627539.htm">https://os.51cto.com/art/202009/627539.htm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github图片，jsdelivr加速不能访问</title>
      <link href="posts/ed109295.html"/>
      <url>posts/ed109295.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>百度搜索关于cdn jsdelivr picgo github图床一堆，我这里就不重新写了，主要写遇到的问题，picgo配置好了，也可以正常上传，但是一旦用jsdelivr链接加速就是访问不了，百度上面连接都是这也写的</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn.jsdelivr.net/gh/用户名/仓库名</a></p></blockquote><p> 所以我最初写的也是<br><code>https://cdn.jsdelivr.net/gh/cloudvillager/cloud/img/20201009135759.png</code>看着没有问题，但是就是不对，一直访问是</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009140831.png"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>猜测是和github默认分支改成main的原因</p><p>github这个月开始，新建仓库都是<code>main</code>作为主分支，原来<code>master</code>已经不用了,可能不指定分支，默认访问的就是master</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在用jsdelivr加速的时候，指定一下main分支,格式是</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/%7BGithub%E7%94%A8%E6%88%B7%E5%90%8D%7D/%7BGithub%E4%BB%93%E5%BA%93%E5%90%8D%7D@%7B%E7%89%88%E6%9C%AC%E5%90%8D%7D/%7B%E4%BB%93%E5%BA%93%E4%B8%8B%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%7D">https://cdn.jsdelivr.net/gh/{Github用户名}/{Github仓库名}@{版本名}/{仓库下资源路径}</a></p></blockquote><p>例如： <a href="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009135759.png">https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009135759.png</a></p><p>就可以访问了</p><hr><p>参考：</p><blockquote><p><a href="https://www.dazhuanlan.com/2020/03/26/5e7c9c9250cb8/?__cf_chl_jschl_tk__=ef5bbb49c273a87d67426449fa2defbac0dfa6e7-1602224791-0-AYlVlW0tHM7FK5Qhf5aEkX6pJ7S5DHPQVpmNoGVMhVOnqXxWhsdpPA9auCrFSdnIkctDqUWuxA6FoL7wdAnceIQAR1wGVkhzYKXZPOhD9Yzu4AWYMr40e1N0qT05isp__Jxq01aqydGOL2FNQMogmatShYr3_IFtqmybF0eamnkLMq28fgCsy-DBU91oAt5PTSqqR7oZogV9J8-wNtpyWbH40mAjPVFsBckeQWHVOQNfAQCfnJeXUPTuPWFo50wshnJgyqHYmWrc0VtxXnz2jGaSi08cBy3BmVwnrmBPmKz7fdf1ZiuEElBT-9UmnsejAQ">https://www.dazhuanlan.com/2020/03/26/5e7c9c9250cb8/?__cf_chl_jschl_tk__=ef5bbb49c273a87d67426449fa2defbac0dfa6e7-1602224791-0-AYlVlW0tHM7FK5Qhf5aEkX6pJ7S5DHPQVpmNoGVMhVOnqXxWhsdpPA9auCrFSdnIkctDqUWuxA6FoL7wdAnceIQAR1wGVkhzYKXZPOhD9Yzu4AWYMr40e1N0qT05isp__Jxq01aqydGOL2FNQMogmatShYr3_IFtqmybF0eamnkLMq28fgCsy-DBU91oAt5PTSqqR7oZogV9J8-wNtpyWbH40mAjPVFsBckeQWHVOQNfAQCfnJeXUPTuPWFo50wshnJgyqHYmWrc0VtxXnz2jGaSi08cBy3BmVwnrmBPmKz7fdf1ZiuEElBT-9UmnsejAQ</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> jsdelivr </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 本地拒绝连接远程库问题 错误403</title>
      <link href="posts/9fcda5d2.html"/>
      <url>posts/9fcda5d2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下午本来想推送一下网站的<code>hexo d</code>然后一直报错</p><blockquote><p>On branch master<br>nothing to commit, working tree clean<br>remote: Permission to cloudvillager/cloudvillager.github.io.git denied to shuimqs.<br>fatal: unable to access ‘<a href="https://github.com/cloudvillager/cloudvillager.github.io.git/&#39;">https://github.com/cloudvillager/cloudvillager.github.io.git/&#39;</a>: The requested URL returned error: 403</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>报错信息大概意思就是，我之前登陆 了别的github账户，现在要推送到另一个账户，推不上去，拒绝访问，这不废话嘛，肯定推不了，找了好久，其实吧报错信息往谷歌里面一方，出来的就是答案，和我遇到的情况一样，<a href="https://stackoverflow.com/questions/47465644/github-remote-permission-denied%EF%BC%8C">https://stackoverflow.com/questions/47465644/github-remote-permission-denied，</a> 不过我看不懂，后来这里找到了答案， <a href="https://blog.csdn.net/klxh2009/article/details/76019742%EF%BC%8C">https://blog.csdn.net/klxh2009/article/details/76019742，</a> 然后看这不就是我之前看的那个链接吗，感觉一样，后来发现确实一样。。。</p><p>在看看下面评论都挺好的，再看看，之前那个国外网站是17年，这个csdn是19年发的。。英语太重要了。</p><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201007165000.png"></p><p>就是这里，普通凭据那里，找到<code>  git:https://github.com</code>删除就可以了，然后<code>hexo d</code>就可以推送成功了</p><p>参考：</p><blockquote><p><a href="https://blog.csdn.net/klxh2009/article/details/76019742">https://blog.csdn.net/klxh2009/article/details/76019742</a><br><a href="https://stackoverflow.com/questions/47465644/github-remote-permission-denied">https://stackoverflow.com/questions/47465644/github-remote-permission-denied</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="posts/d87f7e0c.html"/>
      <url>posts/d87f7e0c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>docker adf</p><blockquote><p>afd fasd</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>test</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
