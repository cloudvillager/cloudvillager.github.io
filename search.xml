<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Servlet学习笔记</title>
      <link href="posts/3cd763d6.html"/>
      <url>posts/3cd763d6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Servlet-技术"><a href="#Servlet-技术" class="headerlink" title="Servlet 技术"></a>Servlet 技术</h1><h2 id="什么是-Servlet"><a href="#什么是-Servlet" class="headerlink" title="什么是 Servlet"></a>什么是 Servlet</h2><ol><li>Servlet 是 JavaEE 规范之一。 规范就是接口  </li><li>Servlet 就 JavaWeb 三大组件之一。 三大组件分别是： Servlet 程序、 Filter 过滤器、 Listener 监听器 </li><li>Servlet 是运行在服务器上的一个 java 小程序， 它可以接收客户端发送过来的请求， 并响应数据给客户端。</li></ol><h2 id="手动实现-Servlet-程序"><a href="#手动实现-Servlet-程序" class="headerlink" title="手动实现 Servlet 程序"></a>手动实现 Servlet 程序</h2><ol><li>编写一个类去实现 Servlet 接口  </li><li>实现 service 方法， 处理请求， 并响应数据  </li><li>到 web.xml 中去配置 servlet 程序的访问地址  </li></ol><p>建立一个类，实现Servlet接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * service 方法是专门用来处理请求和响应的</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    ServletException, IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello Servlet 被访问了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在web.xml配置中配置servlet访问地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-name 标签的作用是告诉服务器， 我当前配置的地址给哪个 Servlet 程序使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--url-pattern 标签配置访问地址 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">/ 斜杠在服务器解析的时候， 表示地址为： http://ip:port/工程路径 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">/hello 表示地址为： http://ip:port/工程路径/hello &lt;br/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重启服务器，即可被访问</p><p>其中常见的错误有以下几类</p><ul><li><p>url-pattern 中配置的路径没有以斜杠打头  </p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210408131210.png"></p></li><li><p>servlet-name 配置的值不存在 </p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210408131247.png"></p></li><li><p>servlet-class 标签的全类名配置错误 </p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210408131314.png"></p></li></ul><h2 id="url-地址到-Servlet-程序的访问"><a href="#url-地址到-Servlet-程序的访问" class="headerlink" title="url 地址到 Servlet 程序的访问"></a>url 地址到 Servlet 程序的访问</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210408131415.png"></p><h2 id="Servlet-的生命周期"><a href="#Servlet-的生命周期" class="headerlink" title="Servlet 的生命周期"></a>Servlet 的生命周期</h2><ol><li><p>执行 Servlet 构造器方法 </p></li><li><p>执行 init 初始化方法 </p><p>第一、 二步， 是在第一次访问， 的时候创建 Servlet 程序会调用  </p></li><li><p>执行 service 方法  </p><p>第三步， 每次访问都会调用  </p></li><li><p>执行 destroy 销毁方法  </p><p>第四步， 在 web 工程停止的时候调用 </p></li></ol><h2 id="GET-和-POST-请求的分发处理"><a href="#GET-和-POST-请求的分发处理" class="headerlink" title="GET 和 POST 请求的分发处理"></a>GET 和 POST 请求的分发处理</h2><p>如果我们需要对前台的请求进行判断，然后分发处理，我们可以重写servlet接口中的service方法</p><p>创建一个类，实现servlet接口,重写service方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * service 方法是专门用来处理请求和响应的</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> servletRequest</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> servletResponse</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3 service === Hello Servlet 被访问了&quot;</span>);</span><br><span class="line">        <span class="comment">// 类型转换（因为它有 getMethod()方法）</span></span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="comment">// 获取请求的方式</span></span><br><span class="line">        String method = httpServletRequest.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;GET&quot;</span>.equals(method)) &#123;</span><br><span class="line">            doGet();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;POST&quot;</span>.equals(method)) &#123;</span><br><span class="line">           doPost();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 做 get 请求的操作</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;get 请求&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;get 请求&quot;</span>);</span><br><span class="line">        &#125; /</span><br><span class="line">        **</span><br><span class="line">        * 做 post 请求的操作</span><br><span class="line">        */</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;post 请求&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;post 请求&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过继承-HttpServlet-实现-Servlet-程序"><a href="#通过继承-HttpServlet-实现-Servlet-程序" class="headerlink" title="通过继承 HttpServlet 实现 Servlet 程序"></a>通过继承 HttpServlet 实现 Servlet 程序</h2><p>其实，  我们不用自己单端创建一个servlet类，重写service方法这种方法</p><p>servlet接口有个实现类HttpServlet</p><p>一般在实际项目开发中， 都是使用继承 HttpServlet 类的方式去实现 Servlet 程序。</p><ol><li>编写一个类去继承 HttpServlet 类  </li><li>根据业务需要重写 doGet 或 doPost 方法 </li><li>到 web.xml 中的配置 Servlet 程序的访问地址  </li></ol><p>Servlet 类的代码： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * doGet（） 在 get 请求的时候调用</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,</span></span><br><span class="line"><span class="function">    IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;HelloServlet2 的 doGet 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * doPost（） 在 post 请求的时候调用</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> ServletException</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,</span></span><br><span class="line"><span class="function">    IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;HelloServlet2 的 doPost 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>web.xml 中的配置 ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet2&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;com.atguigu.servlet.HelloServlet2&lt;&#x2F;servlet-class&gt;</span><br><span class="line">&lt;&#x2F;servlet&gt;</span><br><span class="line"></span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">    &lt;servlet-name&gt;HelloServlet2&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;hello2&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;servlet-mapping&gt;</span><br></pre></td></tr></table></figure><h2 id="使用-IDEA-创建-Servlet-程序"><a href="#使用-IDEA-创建-Servlet-程序" class="headerlink" title="使用 IDEA 创建 Servlet 程序"></a>使用 IDEA 创建 Servlet 程序</h2><p>菜单： new -&gt;Servlet 程序  </p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210408132946.png"></p><p>配置 Servlet 的信息：  </p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210408133003.png"></p><blockquote><p>1，那个地方不要勾选，勾选就是3.0版本，就是注解版本的，和我现在学习的不一样</p></blockquote><h2 id="Servlet-类的继承体系"><a href="#Servlet-类的继承体系" class="headerlink" title="Servlet 类的继承体系"></a>Servlet 类的继承体系</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210408133215.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合（三）(map)</title>
      <link href="posts/6ca03685.html"/>
      <url>posts/6ca03685.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><h2 id="Map接口概述"><a href="#Map接口概述" class="headerlink" title="Map接口概述"></a>Map接口概述</h2><p>我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。</p><ul><li>Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li>Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li>Collection中的集合称为单列集合，Map中的集合称为双列集合。</li><li>需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li><li>Map中常用的集合为HashMap集合、LinkedHashMap集合。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116152157.png"></p><h2 id="Map接口中常用集合概述"><a href="#Map接口中常用集合概述" class="headerlink" title="Map接口中常用集合概述"></a>Map接口中常用集合概述</h2><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li>**HashMap&lt;K,V&gt;**：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li>**LinkedHashMap&lt;K,V&gt;**：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li><strong>注意</strong>：Map接口中的集合都有两个泛型变量&lt;K,V&gt;,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量&lt;K,V&gt;的数据类型可以相同，也可以不同。</li></ul><h2 id="Map接口中的常用方法"><a href="#Map接口中的常用方法" class="headerlink" title="Map接口中的常用方法"></a>Map接口中的常用方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116152644.png"></p><ul><li><p>V put(K,V) K 作为键的对象, V作为值的对象 将键值对存储到集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>);</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;b=2, a=1, c=3&#125;</span></span><br></pre></td></tr></table></figure><p>如果存储的是重复的键,会将原有的值,覆盖</p><p>返回值一般情况下返回null</p><p>当存储重复键的时候,会返回被覆盖之前的值</p></li><li><p>V get(K) 通过键对象,获取值对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建集合对象,作为键的对象整数,值的对象存储字符串</span></span><br><span class="line">Map&lt;Integer,String&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">&quot;b&quot;</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">System.out.println(map.get(<span class="number">3</span>));<span class="comment">//c</span></span><br><span class="line"></span><br><span class="line">String value = map.get(<span class="number">4</span>);</span><br><span class="line">System.out.println(value); <span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>如果集合中没有这个键,返回null</p></li><li><p>V remove(K) 移除集合中的键值对,返回被移除之前的值</p></li></ul><h2 id="Map集合遍历键找值方式"><a href="#Map集合遍历键找值方式" class="headerlink" title="Map集合遍历键找值方式"></a>Map集合遍历键找值方式</h2><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>操作步骤：</p><ol><li><p>获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116155812.png"></p></li><li><p>遍历键的Set集合，得到每一个键</p></li><li><p>根据键，获取键所对应的值</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String,Integer&gt;();</span><br><span class="line">map.put(<span class="string">&quot;a&quot;</span>, <span class="number">11</span>);</span><br><span class="line">map.put(<span class="string">&quot;b&quot;</span>, <span class="number">12</span>);</span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">13</span>);</span><br><span class="line">map.put(<span class="string">&quot;d&quot;</span>, <span class="number">14</span>);</span><br></pre></td></tr></table></figure><p>迭代器的做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line">Iterator&lt;String&gt; it = set.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String key = it.next();</span><br><span class="line">    Integer value = map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;....&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增强for的做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(String key : map.keySet())&#123;</span><br><span class="line">    Integer value = map.get(key);</span><br><span class="line">    System.out.println(key+<span class="string">&quot;....&quot;</span>+value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Entry键值对对象"><a href="#Entry键值对对象" class="headerlink" title="Entry键值对对象"></a>Entry键值对对象</h2><p>在Map类设计时，提供了一个嵌套接口：Entry。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116161008.png"></p><p>Entry是Map接口中提供的一个静态内部嵌套接口。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116161034.png"></p><p>getKey()方法：获取Entry对象中的键</p><p>getValue()方法：获取Entry对象中的值</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116161114.png"></p><p>entrySet()方法：用于返回Map集合中所有的键值对(Entry)对象，以Set集合形式返回。</p><h2 id="Map集合遍历键值对方式"><a href="#Map集合遍历键值对方式" class="headerlink" title="Map集合遍历键值对方式"></a>Map集合遍历键值对方式</h2><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p><ol><li><p>获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116161233.png"></p></li><li><p>遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象</p></li><li><p>通过键值对(Entry)对象，获取Entry对象中的键与值。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116161316.png"></p></li></ol><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116161415.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line"><span class="comment">//给map中添加元素</span></span><br><span class="line">map.put(<span class="string">&quot;邓超&quot;</span>, <span class="string">&quot;孙俪&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;李晨&quot;</span>, <span class="string">&quot;范冰冰&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;柳岩&quot;</span>);</span><br><span class="line"><span class="comment">//获取Map中的所有key与value的对应关系</span></span><br><span class="line">Set&lt;Map.Entry&lt;String,String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line"><span class="comment">//遍历Set集合</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;String,String&gt;&gt; it =entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">//得到每一对对应关系</span></span><br><span class="line">    Map.Entry&lt;String,String&gt; entry = it.next();</span><br><span class="line">    <span class="comment">//通过每一对对应关系获取对应的key</span></span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    <span class="comment">//通过每一对对应关系获取对应的value</span></span><br><span class="line">    String value = entry.getValue();</span><br><span class="line">    System.out.println(key+<span class="string">&quot;=&quot;</span>+value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;=========================&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;String, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey()+<span class="string">&quot;=&quot;</span>+entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p><h2 id="HashMap存储自定义类型键值"><a href="#HashMap存储自定义类型键值" class="headerlink" title="HashMap存储自定义类型键值"></a>HashMap存储自定义类型键值</h2><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾上一节的HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用LinkedHashMap集合来存放。</li></ul><h2 id="Hashtable介绍"><a href="#Hashtable介绍" class="headerlink" title="Hashtable介绍"></a>Hashtable介绍</h2><p>Map接口有个实现类 叫Hashtable，底层数据结构是哈希表,特点和HashMap是一样的，Hashtable 是线程安全的集合,运行速度慢，HashMap 线程不安全的集合,运行速度快</p><p>Hashtable命运和Vector是一样的,从JDK1.2开始,被更先进的HashMap取代</p><p>HashMap 允许存储null值,null键</p><p>Hashtable 不允许存储null值,null键</p><p>但是Hashtable他的孩子,子类 Properties 目前依然活跃在开发舞台</p><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>这是JDK1.5新特性，作用是减少开发的代码量</p><p>在导包的过程中我们可以直接导入静态部分，这样某个类的静态成员就可以直接使用了。在源码中经常会出现静态导入。</p><p>静态导入格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> XXX.YYY;   导入后YYY可直接使用。 </span><br></pre></td></tr></table></figure><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.out;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Arrays.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticImportDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">sort(arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型... 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>其实这个书写完全等价与</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型[] 形参名)&#123;  &#125;</span><br></pre></td></tr></table></figure><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p>可变参数,本质就是一个数组</p><hr><p>jdk1.5以后。出现了简化操作。**…** 用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p>如果我们要计算用户输入的数字之和，也可以利用可变参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用一个带有可变参数的方法,传递参数,可以任意</span></span><br><span class="line">    <span class="keyword">int</span> sum = getSum(<span class="number">5</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">56</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">0</span>);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>...a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : a)&#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可变参数的注意事项</p><ol><li>一个方法中,可变参数只能有一个</li><li>可变参数,必须写在参数列表的最后一位</li></ol><h2 id="Collections集合工具类"><a href="#Collections集合工具类" class="headerlink" title="Collections集合工具类"></a>Collections集合工具类</h2><p>Collections是集合工具类，用来对集合进行操作。部分方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116180837.png"></p><ul><li><p>Collections.sort静态方法 对于List集合,进行升序排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;ewrew&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;qwesd&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;Qwesd&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;bv&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;wer&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"><span class="comment">//调用集合工具类的方法sort</span></span><br><span class="line">Collections.sort(list);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li><li><p>Collections.binarySearch静态方法 </p><p>对List集合进行二分搜索,方法参数,传递List集合,传递被查找的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.add(<span class="number">8</span>);</span><br><span class="line">list.add(<span class="number">10</span>);</span><br><span class="line">list.add(<span class="number">15</span>);</span><br><span class="line">list.add(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//调用工具类静态方法binarySearch</span></span><br><span class="line"><span class="keyword">int</span> index = Collections.binarySearch(list, <span class="number">16</span>);</span><br><span class="line">System.out.println(index);</span><br></pre></td></tr></table></figure></li><li><p>Collections.shuffle方法</p><p>对List集合中的元素,进行随机排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">list.add(<span class="number">9</span>);</span><br><span class="line">list.add(<span class="number">11</span>);</span><br><span class="line">list.add(<span class="number">8</span>);</span><br><span class="line">list.add(<span class="number">10</span>);</span><br><span class="line">list.add(<span class="number">15</span>);</span><br><span class="line">list.add(<span class="number">20</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用工具类方法shuffle对集合随机排列</span></span><br><span class="line">Collections.shuffle(list);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li></ul><h2 id="集合嵌套"><a href="#集合嵌套" class="headerlink" title="集合嵌套"></a>集合嵌套</h2><p>集合嵌套并不是一个新的知识点，仅仅是集合内容又是集合，如Collection集合嵌套、Collection集合与Map集合相互嵌套、Map集合嵌套。</p><ul><li><p>ArrayList嵌套 ArrayList</p><p>  ArrayList&lt; ArrayList<String> &gt;</p><p>  Collection&lt; ArrayList<Integer> &gt;</p></li><li><p>Map嵌套 ArrayList</p><p>HashMap&lt;String, ArrayList<Person>&gt;</p><p>ArrayList&lt; HashMap&lt;String, String&gt;&gt;</p></li><li><p>Map集合嵌套</p><p>HashMap&lt;String, HashMap&lt;String,String&gt;&gt;</p><p>HashMap&lt;String, HashMap&lt;Person,String&gt;&gt;</p></li></ul><h2 id="集合继承体系的面向对象思想"><a href="#集合继承体系的面向对象思想" class="headerlink" title="集合继承体系的面向对象思想"></a>集合继承体系的面向对象思想</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116183557.png"></p><ul><li>接口：用来明确所有集合中该具有的功能，相当于在定义集合功能标准；</li><li>抽象类：把多个集合中功能实现方式相同的方法，抽取到抽象类实现，具体集合不再遍写，继承使用即可；</li><li>具体类：继承抽象类，实现接口，重写所有抽象方法，达到具备指定功能的集合。每个具体集合类，根据自身的数据存储结构方式，对接口中的功能方法，进行不同方式的实现。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合(二)(list、set)</title>
      <link href="posts/f28ce7c.html"/>
      <url>posts/f28ce7c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我们掌握了Collection接口的使用后，再来看看Collection接口中的子类，他们都具备那些特性呢？</p><p>接下来，我们一起学习Collection中的常用几个子类（List集合、Set集合）。</p><h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><h2 id="List接口介绍"><a href="#List接口介绍" class="headerlink" title="List接口介绍"></a>List接口介绍</h2><p>查阅API，看List的介绍。有序的 collection（也称为序列）。此接口的用户可以对列表中每个元素的插入位置进行精确地控制。用户可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。与 set 不同，列表通常允许重复的元素。</p><p>看完API，我们总结一下：</p><p>List接口：</p><ul><li><p>它是一个元素存取有序的集合。例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）。</p></li><li><p>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</p></li><li><p>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</p></li></ul><p>List接口的常用子类有：</p><ul><li><p>ArrayList集合</p></li><li><p>LinkedList集合</p></li></ul><h2 id="接口中常用的方法"><a href="#接口中常用的方法" class="headerlink" title="接口中常用的方法"></a>接口中常用的方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115210915.png"></p><p>list接口中的抽象方法，有一部分和他的父接口collection是一样的，我们关注的是list接口自己特有的方法，一般带有索引的方法都是list特有的方法</p><ul><li><p>add(int index, E) 将元素插入到列表的指定索引上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc4&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line"></span><br><span class="line">list.add(<span class="number">1</span>, <span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115211758.png"></p><blockquote><p>这些带有索引的操作,都要防止越界问题</p><p>java.lang.IndexOutOfBoundsException</p></blockquote></li><li><p>E remove(int index) 移除指定索引上的元素 返回被删除之前的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Double&gt; list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">list.add(<span class="number">1.1</span>);</span><br><span class="line">list.add(<span class="number">1.2</span>);</span><br><span class="line">list.add(<span class="number">1.3</span>);</span><br><span class="line">list.add(<span class="number">1.4</span>);</span><br><span class="line"></span><br><span class="line">Double d = list.remove(<span class="number">0</span>);</span><br><span class="line">System.out.println(d);<span class="comment">//1.1</span></span><br><span class="line">System.out.println(list);<span class="comment">//[1.2,1.3,1.4]</span></span><br></pre></td></tr></table></figure></li><li><p>E set(int index, E) 修改指定索引上的元素 返回被修改之前的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">list.add(<span class="number">1</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">Integer i = list.set(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(i);<span class="comment">//1</span></span><br><span class="line">System.out.println(list);<span class="comment">//[5,2,3,4]</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>list集合中遍历有三种方式，由于List集合拥有索引，因此List集合迭代方式除了使用迭代器之外，还可以使用索引进行迭代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">String str = list.get(i);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种就是增强for</p><h3 id="Iterator的并发修改异常"><a href="#Iterator的并发修改异常" class="headerlink" title="Iterator的并发修改异常"></a>Iterator的并发修改异常</h3><p>在list集合迭代元素中，对元素进行判断，一旦条件满足就添加一个新元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;abc4&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//对集合使用迭代器进行获取,获取时候判断集合中是否存在 &quot;abc3&quot;对象</span></span><br><span class="line"><span class="comment">//如果有,添加一个元素 &quot;ABC3&quot;</span></span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    <span class="comment">//对获取出的元素s,进行判断,是不是有&quot;abc3&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;abc3&quot;</span>))&#123;</span><br><span class="line">        list.add(<span class="string">&quot;ABC3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这段代码，程序会出现异常，java.util.ConcurrentModificationException</p><p>这就是迭代器的并发修改异常，就是在遍历的过程中,使用了集合方法修改了集合的长度,这是不允许的</p><h2 id="List集合存储数据的结构"><a href="#List集合存储数据的结构" class="headerlink" title="List集合存储数据的结构"></a>List集合存储数据的结构</h2><p>List接口下有很多个集合，它们存储元素所采用的结构方式是不同的，这样就导致了这些集合有它们各自的特点，供给我们在不同的环境下进行使用。数据存储的常用结构有：堆栈、队列、数组、链表。我们分别来了解一下：</p><ul><li><p>堆栈，采用该结构的集合，对元素的存取有如下的特点</p><ul><li>先进后出</li><li>栈的入口、出口的都是栈的顶端位置</li><li>压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置</li><li>弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li></ul></li><li><p>队列，采用该结构的集合，对元素的存取有如下的特点</p><ul><li>先进先出</li><li>队列的入口、出口各占一侧。</li></ul></li><li><p>数组，采用该结构的集合，对元素的存取有如下的特点</p><ul><li><p>查找元素快：通过索引，可以快速访问指定位置的元素</p></li><li><p>增删元素慢</p><p><strong>指定索引位置增加元素</strong>：需要创建一个新数组，将指定新元素存储在指定索引位置，再把原数组元素根据索引，复制到新数组对应索引的位置。如下图</p><p><strong>指定索引位置删除元素：</strong>需要创建一个新数组，把原数组元素根据索引，复制到新数组对应索引的位置，原数组中指定索引位置元素不复制到新数组中。如下图</p></li></ul><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115215155.png" style="zoom:67%;" /></li><li><p>链表，采用该结构的集合，对元素的存取有如下的特点：</p><ul><li>多个节点之间，通过地址进行连接。</li><li>查找元素慢</li><li>增删元素快</li></ul></li></ul><h2 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h2><p>ArrayList集合数据存储的结构是数组结构。元素增删慢，查找快，由于日常开发中使用最多的功能为查询数据、遍历数据，所以ArrayList是最常用的集合。</p><p>许多程序员开发时非常随意地使用ArrayList完成任何需求，并不严谨，这种用法是不提倡的。</p><h2 id="LinkedList集合"><a href="#LinkedList集合" class="headerlink" title="LinkedList集合"></a>LinkedList集合</h2><p>如果需要用到增删，可以用LinkedList集合</p><p>LinkedList集合数据存储的结构是链表结构。方便元素添加、删除的集合。实际开发中对一个集合元素的添加与删除经常涉及到首尾操作，而LinkedList提供了大量首尾操作的方法。</p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115215906.png" style="zoom:80%;" /><p>LinkedList是List的子类，List中的方法LinkedList都是可以使用，这里就不做详细介绍，我们只需要了解LinkedList的特有方法即可。在开发时，LinkedList集合也可以作为堆栈，队列的结构使用。</p><p>如果需要用子类的特有功能，就不能使用多态调用</p><ul><li><p>addFirst(E) 添加到链表的开头</p></li><li><p>addLast(E) 添加到链表的结尾</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">link.addLast(<span class="string">&quot;heima&quot;</span>);</span><br><span class="line"></span><br><span class="line">link.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;bcd&quot;</span>);</span><br><span class="line"></span><br><span class="line">link.addFirst(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">System.out.println(link);<span class="comment">//[itcast, heima, abc, bcd]</span></span><br></pre></td></tr></table></figure><blockquote><p>容器一开始是空的，heima先添加到里面</p></blockquote></li></ul><ul><li><p>E getFirst() 获取链表的开头</p></li><li><p>E getLast() 获取链表的结尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">  link.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">  link.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">  link.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(!link.isEmpty())&#123; <span class="comment">//使用这两个方法会出现一个异常，NoSuchElementException，就是集合里面没有元素的时候，使用这两个就会出这个异常，可以用if这个方式判断一下，就可以避免</span></span><br><span class="line">      String first = link.getFirst();</span><br><span class="line">      String last = link.getLast();</span><br><span class="line">      System.out.println(first); <span class="comment">//1</span></span><br><span class="line">      System.out.println(last); <span class="comment">//4</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>E removeFirst() 移除并返回链表的开头</p></li><li><p>E removeLast() 移除并返回链表的结尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LinkedList&lt;String&gt; link = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">link.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">link.add(<span class="string">&quot;4&quot;</span>);</span><br><span class="line"></span><br><span class="line">String first = link.removeFirst();</span><br><span class="line">String last = link.removeLast();</span><br><span class="line">System.out.println(first); <span class="comment">//1</span></span><br><span class="line">System.out.println(last);<span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">System.out.println(link);<span class="comment">//[2,3]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Vector集合"><a href="#Vector集合" class="headerlink" title="Vector集合"></a>Vector集合</h2><p>Vector集合数据存储的结构是数组结构，为JDK中最早提供的集合。Vector中提供了一个独特的取出方式，就是枚举Enumeration，它其实就是早期的迭代器。此接口Enumeration的功能与 Iterator 接口的功能是类似的。Vector集合已被ArrayList替代。枚举Enumeration已被迭代器Iterator替代。</p><blockquote><p>这个集合就是介绍下，因为现在已经被取代了，需要知道的就这一点，他是同步的，也就是线程安全的，运行速度慢</p></blockquote><p>Vector常见的方法：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115222308.png"></p><p>Enumeration枚举常见的方法：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115222327.png"></p><p>Vector集合对ArrayList集合使用的对比</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115222354.png"></p><h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><p>学习Collection接口时，记得Collection中可以存放重复元素，也可以不存放重复元素，那么我们知道List中是可以存放重复元素的。那么不重复元素给哪里存放呢？那就是Set接口，它里面的集合，所存储的元素就是不重复的。</p><h2 id="Set接口介绍"><a href="#Set接口介绍" class="headerlink" title="Set接口介绍"></a>Set接口介绍</h2><p>查阅Set集合的API介绍，通过元素的equals方法，来判断是否为重复元素，它是个不包含重复元素的集合。Set集合取出元素的方式可以采用：迭代器，增强for</p><p>Set集合有多个子类，这里我们介绍其中的HashSet、LinkHashSet这两个集合</p><h2 id="HashSet集合介绍"><a href="#HashSet集合介绍" class="headerlink" title="HashSet集合介绍"></a>HashSet集合介绍</h2><p>查阅HashSet集合的API介绍：此类实现Set接口，由哈希表支持（实际上是一个 HashMap集合）。HashSet集合不能保证的迭代顺序与元素存储顺序相同。</p><p>查看hashset的源码会看见</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115223541.png"></p><p>所以学会了Set，也就学会了Map</p><p>HashSet集合，采用哈希表结构存储数据，保证元素唯一性的方式依赖于：hashCode()与equals()方法。</p><hr><p>Set接口实现类特点总结：</p><ul><li>无序集合</li><li>存储和取出的顺序不同</li><li>没有索引</li><li>不存储重复元素</li></ul><hr><p>HashSet集合的自身特点总结：</p><ul><li>底层数据结构是一个哈希表</li><li>存储，取出都比较快</li><li>线程不安全，运行速度块</li></ul><h2 id="HashSet集合存储数据的结构（哈希表）"><a href="#HashSet集合存储数据的结构（哈希表）" class="headerlink" title="HashSet集合存储数据的结构（哈希表）"></a>HashSet集合存储数据的结构（哈希表）</h2><p>哈希表相当于一个数组链表的结合体，为什么哈希表查询速度快呢，因为它是一个数组，为什么哈希表增删也很快呢，因为它是一个链表</p><p>哈希表底层使用的也是数组机制，数组中也存放对象，而这些对象往数组中存放时的位置比较特殊，当需要把这些对象给数组中存放时，那么会根据这些对象的特有数据结合相应的算法，计算出这个对象在数组中的位置，然后把这个对象存放在数组中。而这样的数组就称为哈希数组，即就是哈希表。</p><p>当向哈希表中存放元素时，需要根据元素的特有数据结合相应的算法，这个算法其实就是Object类中的hashCode方法。由于任何对象都是Object类的子类，所以任何对象有拥有这个方法。即就是在给哈希表中存放对象时，会调用对象的hashCode方法，算出对象在表中的存放位置，这里需要注意，如果两个对象hashCode方法算出结果一样，这样现象称为哈希冲突，这时会调用对象的equals方法，比较这两个对象是不是同一个对象，如果equals方法返回的是true，那么就不会把第二个对象存放在哈希表中，如果返回的是false，就会把这个值存放在哈希表中。</p><p>总结：保证HashSet集合元素的唯一，其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一，就必须复写hashCode和equals方法建立属于当前对象的比较方式。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115225316.png"></p><h3 id="String对象的哈希值"><a href="#String对象的哈希值" class="headerlink" title="String对象的哈希值"></a>String对象的哈希值</h3><p>对象的哈希值,就是普通的十进制整数，在父类object类中有一个方法public int hashCode()，它的作用就是返回哈希值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">int</span> i = p.hashCode();</span><br><span class="line">System.out.println(i);<span class="comment">//返回的数字每次都是不可预知的</span></span><br></pre></td></tr></table></figure><blockquote><p>Person没有做重写父类,每次运行结果都是不同整数（哈希值）</p><p>如果子类重写父类的方法,哈希值,自定义的</p><p>哈希值是存储到HashSet集合的依据</p></blockquote><p>在写一个String对象，看下哈希值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">System.out.println(s1.hashCode()); <span class="comment">//96354</span></span><br><span class="line">System.out.println(s2.hashCode()); <span class="comment">//96354</span></span><br></pre></td></tr></table></figure><p>可以看到哈希值一样，这就说明，String对象重写过了hashCode()方法</p><p>这个数字是String类自己计算的</p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115231815.png" style="zoom:67%;" /><h3 id="哈希表的存储过程"><a href="#哈希表的存储过程" class="headerlink" title="哈希表的存储过程"></a>哈希表的存储过程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">&quot;bbc&quot;</span>));</span><br><span class="line">set.add(<span class="keyword">new</span> String(<span class="string">&quot;bbc&quot;</span>));</span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure><p>运行结果：<code>[abc, bbc]</code></p><p>这个可不是重复元素的原因，这些都是不同的对象，所以不是重复元素，但是运行结果还是这样呢</p><p>解析：</p><p><code>HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();</code>运行这段代码，就会一个哈希表</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115232702.png"></p><p>在运行<code>set.add(new String(&quot;abc&quot;));</code>这段代码，在存之前会计算对象的哈希值<code>new String(&quot;abc&quot;).hashCode = 96354 </code> ,集合在容器中就会搜索，有没有96354一样的哈希值，如果没有，哈希数组的一个索引就会自动记录这个对象的地址，也就是装进去了</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115232807.png"></p><p>接着继续运行下一行代码<code>set.add(new String(&quot;abc&quot;));</code>，集合调用对象的哈希值<code>new String(&quot;abc&quot;).hashCode = 96354 </code>集合在容器中搜索，搜索到了已经有一个对象也是96354，</p><p>接着，集合会让后来的对象new String(“abc”)调用方法equals(已经有了的对象)，即：</p><p>new String(“abc”).equals(new String(“abc”)) //true</p><p>集合发现两个对象的哈希值一样，equals方法返回true，集合就会判定元素已经重复</p><p>后面的代码执行过程和前面一样，这就是哈希表存储的过程</p><hr><p>总得来说，哈希表存储对象的依据就是对象的哈希值和equals,</p><p>如果集合判断一个对象哈希值相同，但是equals不同的时候，这个时候，集合就会判断这两个元素不重复，将对象存入集合中，但是它不是存到哈希数组中，而是采用桶的方式存储，挂在前一个对象的下面，像链表一样</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115234511.png"></p><h2 id="HashSet存储JavaAPI中的类型元素"><a href="#HashSet存储JavaAPI中的类型元素" class="headerlink" title="HashSet存储JavaAPI中的类型元素"></a>HashSet存储JavaAPI中的类型元素</h2><p>给HashSet中存储JavaAPI中提供的类型元素时，不需要重写元素的hashCode和equals方法，因为这两个方法，在JavaAPI的每个类中已经重写完毕，如String类、Integer类等。</p><p>具体可以看前面的String对象的哈希值这一段</p><h2 id="HashSet存储自定义类型元素"><a href="#HashSet存储自定义类型元素" class="headerlink" title="HashSet存储自定义类型元素"></a>HashSet存储自定义类型元素</h2><p>给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一</p><h2 id="LinkedHashSet介绍"><a href="#LinkedHashSet介绍" class="headerlink" title="LinkedHashSet介绍"></a>LinkedHashSet介绍</h2><p>我们知道HashSet保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？</p><p>在HashSet下面有一个子类LinkedHashSet，它是链表和哈希表组合的一个数据存储结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;();</span><br><span class="line">set.add(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">set.add(<span class="string">&quot;bbc&quot;</span>);</span><br><span class="line">Iterator it = set.iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bbb</span><br><span class="line">aaa</span><br><span class="line">abc</span><br><span class="line">bbc</span><br></pre></td></tr></table></figure><p>总结：LinkedHashSet是一个有序的set集合，也不允许存放重复的元素，线程不安全，运行速度快，它的内部的链表结构是一个双重链表的结构</p><h1 id="判断集合元素唯一的原理"><a href="#判断集合元素唯一的原理" class="headerlink" title="判断集合元素唯一的原理"></a>判断集合元素唯一的原理</h1><h2 id="ArrayList的contains方法判断元素是否重复原理"><a href="#ArrayList的contains方法判断元素是否重复原理" class="headerlink" title="ArrayList的contains方法判断元素是否重复原理"></a>ArrayList的contains方法判断元素是否重复原理</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116145916.png"></p><p>ArrayList的contains方法会使用调用方法时，传入的元素的equals方法依次与集合中的旧元素所比较，从而根据返回的布尔值判断是否有重复元素。此时，当ArrayList存放自定义类型时，由于自定义类型在未重写equals方法前，判断是否重复的依据是地址值，所以如果想根据内容判断是否为重复元素，需要重写元素的equals方法。</p><h2 id="HashSet的add-contains等方法判断元素是否重复原理"><a href="#HashSet的add-contains等方法判断元素是否重复原理" class="headerlink" title="HashSet的add/contains等方法判断元素是否重复原理"></a>HashSet的add/contains等方法判断元素是否重复原理</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116150016.png"></p><p>Set集合不能存放重复元素，其添加方法在添加时会判断是否有重复元素，有重复不添加，没重复则添加。</p><p>HashSet集合由于是无序的，其判断唯一的依据是元素类型的hashCode与equals方法的返回结果。规则如下：</p><p>先判断新元素与集合内已经有的旧元素的HashCode值</p><ul><li>如果不同，说明是不同元素，添加到集合。</li><li>如果相同，再判断equals比较结果。返回true则相同元素；返回false则不同元素，添加到集合。</li></ul><p>所以，使用HashSet存储自定义类型，如果没有重写该类的hashCode与equals方法，则判断重复时，使用的是地址值，如果想通过内容比较元素是否相同，需要重写该元素类的hashcode与equals方法。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集合(一)</title>
      <link href="posts/d730f0bc.html"/>
      <url>posts/d730f0bc.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合的介绍"><a href="#集合的介绍" class="headerlink" title="集合的介绍"></a>集合的介绍</h2><p>集合，集合是Java中提供的一种容器，可以用来存储多个数据</p><p>在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，他们有什么区别呢？</p><ul><li>数组的长度是固定的，集合的长度是可变的。</li><li>集合中的存储的元素必须是引用类型数据</li></ul><h2 id="ArrayList集合存储元素"><a href="#ArrayList集合存储元素" class="headerlink" title="ArrayList集合存储元素"></a>ArrayList集合存储元素</h2><p>我们先来回顾下，使用ArrayList集合存储元素并遍历的过程</p><ul><li><p>ArrayList集合存储五个int类型元素</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">array.add(<span class="number">11</span>);</span><br><span class="line">array.add(<span class="number">12</span>);</span><br><span class="line">array.add(<span class="number">13</span>);</span><br><span class="line">array.add(<span class="number">14</span>);</span><br><span class="line">array.add(<span class="number">15</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.size() ;i++)&#123;</span><br><span class="line">    System.out.println(array.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  控制台将会显示</p><p>  <img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115104349.png"></p><blockquote><p>集合ArrayList,存储int类型数</p><p>集合本身不接受基本类,自动装箱存储</p></blockquote></li><li><p>ArrayList集合存储五个Person类型元素</p><p>  先定义一个person对象，里面保护，name,age属性</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; arrayPer = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">arrayPer.add(<span class="keyword">new</span> Person(<span class="string">&quot;a&quot;</span>,<span class="number">20</span>));</span><br><span class="line">arrayPer.add(<span class="keyword">new</span> Person(<span class="string">&quot;b&quot;</span>,<span class="number">18</span>));</span><br><span class="line">arrayPer.add(<span class="keyword">new</span> Person(<span class="string">&quot;c&quot;</span>,<span class="number">22</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arrayPer.size();i++)&#123;</span><br><span class="line">    <span class="comment">//get(0),取出的对象Person对象</span></span><br><span class="line">    <span class="comment">//打印的是一个对象,必须调用的toString()</span></span><br><span class="line">    System.out.println(arrayPer.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  运行结果</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115105222.png"></p><h2 id="集合的继承实现关系"><a href="#集合的继承实现关系" class="headerlink" title="集合的继承实现关系"></a>集合的继承实现关系</h2><p>查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而LIst接口又继承了Collection接口。Collection接口为最顶层集合接口</p><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span> <span class="keyword">implements</span> <span class="title">List</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写，那么，实现Collection接口的所有子类都会进行方法重写</p><ul><li>Collection接口常用的子接口有：List接口，Set接口</li><li>List接口常用的子类有：ArrayList类、LinkeList类</li><li>Set接口常用的子类有：HashSet类、LinkedHashSet类</li></ul><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115132713.png"></p><blockquote><p>集合是个很庞大的体系，我们可以先学习最上层的共有的接口，因为，作为子类，这些接口中的方法都必须要实现</p></blockquote><h2 id="Collection接口概述"><a href="#Collection接口概述" class="headerlink" title="Collection接口概述"></a>Collection接口概述</h2><p>既然collection接口是是集合中的顶层接口，那么它中定义的所有功能子类都可以使用。查阅API中描述的collection接口。collection层次结构中的根接口。collection表示一组对象，这些对象也称为collection的元素。一些collection是有序的，而另一些是无序的。</p><blockquote><p>这个概述是复制API中描述的一段话，我们看上面的图，</p><p>collection接口分为两个派系，分别是list和set</p><p>凡是list接口中集合类，它都允许存储重复的元素，并且是有序的（有序的意思是，存的时候是什么样子，输出还是什么样子）</p><p>而set接口中的集合类，不允许存储重复的元素，并且是无序的</p></blockquote><p>继续查阅API，发现collection接口中很多集合的操作方法，那么这些方法都具体能做什么呢？</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115142110.png"></p><p>这里我们不关心具体创建的collection中的哪个子类对象，这里重点演示的是collection接口中的方法。</p><p>创建集合的格式：</p><ul><li><p>方式1创建的集合，只能存储&lt;&gt;中指定的元素类型，该方式为常用方式</p></li><li><p>方式2创建的集合，集合的元素类型默认为object类型，即任何类型的元素都可以存储</p></li></ul><p>演示collection接口中的方法</p><p>Collection接口中的方法,是集合中所有实现类必须拥有的方法,接口不能直接new，所以可以用arraylist来进行演示，因为ArrayList implements List，list又继承了collection，所以ArrayList方法的执行,都是实现的重写</p><ul><li><p>void clear() 清空集合中的所有元素</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口多态的方式调用</span></span><br><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;bcd&quot;</span>);</span><br><span class="line">system.out.println(coll);<span class="comment">//[abc, bcd]</span></span><br><span class="line">coll.clear();</span><br><span class="line">system.out.println(coll);<span class="comment">//[]   clear是清空集合中的元素，但是集合容器本身还是存在的</span></span><br></pre></td></tr></table></figure></li><li><p>boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = coll.contains(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">System.out.println(b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p>int size()   返回集合容器的长度</p><p>这个不写代码了，另外说一下</p><p>Java中一共表示长度的就三种方式</p><ol><li>数组.length 属性  返回值 int</li><li>字符串.length() 方法,返回值int</li><li>集合.size()方法, 返回值int</li></ol></li><li><p>Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组 </p><p>返回是一个存储对象的数组, 数组存储的数据类型是Object</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;52s&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">Object[] objs = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; objs.length ; i++)&#123;</span><br><span class="line">    System.out.println(objs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是将coll对象从集合对象转成数组，但是有一点要注意，转成数组之后，这个coll对象的长度就不能在变了</p></li><li><p>boolean remove(Object o)移除集合中指定的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">System.out.println(coll);<span class="comment">//[abc, money, 123]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = coll.remove(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">System.out.println(b); <span class="comment">//true</span></span><br><span class="line">System.out.println(coll);<span class="comment">//[abc, 123]</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h1><h2 id="Iterator迭代器概述"><a href="#Iterator迭代器概述" class="headerlink" title="Iterator迭代器概述"></a>Iterator迭代器概述</h2><p>util包中有个接口，名字叫Iterator</p><p>java中提供了很多个集合，他们在存储元素时，采用的存储方式不同，我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。</p><p>collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有这个元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出来，一直把集合中的所有元素全部取出。这种取出方式的专业术语成为迭代。（实际上就是遍历）</p><p>集合中把这种取元素的方式描述在Iterator接口中。Iterator接口中的常用方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115150149.png"></p><ul><li>hasNext（）方法：判断集合中还有没有可以被取出的元素,如果有返回true</li><li>next（）方法：取出集合中的元素，并把指针向后移动一位</li></ul><p>由于Iterator接口的方法都是抽象的，所以不能直接使用，需要用实现类来演示</p><p>而实现类在哪里呢，查阅API，发现collection接口中有个方法是Iterator iterator()</p><p>而作为collection接口的实现类arraylist类，要重写方法iterator 返回Iterator接口的实现类的对象</p><p>所以，使用ArrayList集合的对象</p><p>Iterator it = array.iterator(),运行结果就是Iterator接口的实现类的对象</p><p>it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代</p><blockquote><p>这种思想就是面向接口编程思想，我们不需要知道Iterator接口的实现类是谁，只需要知道array.iterator()返回的对象是Iterator接口的实现类就可以了，然后再用Iterator接口接收它</p></blockquote><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc4&quot;</span>);</span><br><span class="line"><span class="comment">//迭代器,对集合ArrayList中的元素进行取出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用集合的方法iterator()获取出,Iterator接口的实现类的对象</span></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"><span class="comment">//接口实现类对象,调用方法hasNext()判断集合中是否有元素</span></span><br><span class="line"><span class="keyword">boolean</span> b = it.hasNext();</span><br><span class="line">System.out.println(b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口的实现类对象,调用方法next()取出集合中的元素</span></span><br><span class="line">String s = it.next();</span><br><span class="line">System.out.println(s);<span class="comment">//abc1</span></span><br></pre></td></tr></table></figure><p>循环演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc4&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Iterator迭代集合元素原理"><a href="#Iterator迭代集合元素原理" class="headerlink" title="Iterator迭代集合元素原理"></a>Iterator迭代集合元素原理</h2><p>Iterator it = array.iterator();</p><p>这句方法一运行，在集合内部就会建立一个指针，指向容器的-1位置，比如有个容器，里面存了这些数据</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115155455.png"></p><p>循环语句while(it.hasNext())</p><p>当执行这个hasNext方法时，指针就会判断下一个位置有没有元素，有就返回真，但是指针位置不动</p><p>代码继续运行循环体中的代码<code>it.next()</code>，这个方法就会返回下一个位置的元素，并且指针会往后移动一个位置，然后继续走while循环，判断，以此循环迭代，直到指针移动到最后一个元素位置，判断下一个位置的元素为false，循环才停止</p><p>注意：如果指针到了最后一个元素，也就是循环体之后，再next获取集合元素，会 发生java.util.NoSuchElementException没有集合元素的错误</p><h2 id="集合元素的向下转型"><a href="#集合元素的向下转型" class="headerlink" title="集合元素的向下转型"></a>集合元素的向下转型</h2><p>学习到这里，基本知道了collection接口的简单使用。可是集合中可以存储任何对象，那么存放进去的数据都是还是远死了的类型吗？不是了，提升成了object</p><p>在使用集合时，我们需要注意以下几点：</p><ul><li>集合中存储其实都是对象的地址。</li><li>集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。因为出现了基本类型包装类，它提供了自动装箱操作（基本类型-&gt;对象），这样，集合中的元素就是基本数值的包装类对象。</li><li>存储时提升了object。取出时要使用元素的特有内容，必须向下转型。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合可以存储任意类型的对象</span></span><br><span class="line"><span class="comment">//集合中,可以不指定存储的数据类型, 这个时候的集合什么都存</span></span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;uyjgtfd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器获取</span></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">//it.next()获取出来的是什么数据类型,Object类</span></span><br><span class="line">    <span class="comment">//Object obj = it.next();</span></span><br><span class="line">    <span class="comment">//System.out.println(obj);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用上面的方式也可以，但是如果我想将里面的字符串的长度打印出来，</span></span><br><span class="line">    <span class="comment">//也就是当需要使用子类对象的特有方法，需要向下转型</span></span><br><span class="line">    String s = (String)it.next();</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常，虽然说也可以用Iterator接口的&lt;&gt;控制迭代元素的类型，但是最好在一开始创建集合的时候就指定要数据类型</p><h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><p>增强for循环是jdk1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。</p><p>JDK1.5版本后,出现新的接口 java.lang.Iterable, Collection开始继承Iterable,在api中可以看见这么一句</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115170140.png"></p><p>这个接口的出现就是为了增强for而来的，它的作用就是增强for循环，凡是它的实现类都可以使用增强for，包括数组</p><p>增强for的内部其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量 ： Collection 集合 or 数组)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115170627.png"></p><p>看着很简洁，但是它也有弊端</p><p>当</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">    System.out.println(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115170924.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">    System.out.println(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115171059.png"></p><p>可以看到最后一行打印结果却是3</p><p>这个应该怎么理解呢</p><p>可以这样理解</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115172237.png"></p><p>增强for的好处与弊端</p><ul><li>好处: 代码少了,方便对容器遍历</li><li>弊端: 没有索引,不能操作容器里面的元素</li></ul><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型的引入"><a href="#泛型的引入" class="headerlink" title="泛型的引入"></a>泛型的引入</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对戏那个存储集合中，那么这时他们都会被提升成object类型。当我们再取出每一个对象，并且进行相应的操作，这时必须采用类型转换。比如下面程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;rtyg&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;43rt5yhju&quot;</span>);</span><br><span class="line">coll.add(<span class="number">1</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">//需要打印每个字符串的长度，就要把迭代出来的对象转成String类型</span></span><br><span class="line">    String s = it.next();</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个代码，程序会抛出一个异常，java.lang.ClassCastException</p><p>为什么会发生类型转换异常呢，我们分析下</p><p>由于集合中什么类型的元素都可以存储。导致取出时，如果出现强转就会引发运行时ClassCastException。怎么来解决这个问题呢？使用集合时，必须明确集合中元素的类型。这种方式称为：泛型</p><h2 id="泛型的定义与使用"><a href="#泛型的定义与使用" class="headerlink" title="泛型的定义与使用"></a>泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p><p>泛型是JDK1.5 出现新的安全机制,用来保证程序的安全性，指明了集合中存储数据的类型  &lt;数据类型&gt;</p><p>泛型，用来灵活的将数据类型应用到不同的类、方法、接口中。将数据类型作为参数进行传递。</p><blockquote><p>其实， Java中的泛型是伪泛型，就是是个假的</p><p>在IDE中加入泛型，比如ArrayList &lt; String&gt; 这只是个编译手段，下面的代码add如果是字符串就编译成功，如果不是string类，他就会编译失败</p><p>但是，在编译后的class文件，它是没有泛型的，那可以保证安全吗?答案是可以，因为不符合的数据类型在IDE中就提示错了错误，不允许被编译，既然都编译出来了class文件，那就说明编译通过了，编译通过了，就说明集合容器里面的类型就是统一的类型</p></blockquote><h3 id="含有泛型的类"><a href="#含有泛型的类" class="headerlink" title="含有泛型的类"></a>含有泛型的类</h3><p>定义格式：修饰符 class 类名&lt;代表泛型的变量&gt;｛｝</p><p>例如，ArrayList类</p><p>E: Element 元素, 实际思想就是一个变量而已 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span></span>&#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用格式：创建对象时，给一个具体的泛型类型，</p><p>例如，ArrayList<Integer>  array = new ArrayList<Integer> ();</p><p>此时，变量E的值就是Interger类型</p><h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名（参数）｛ ｝</p><p>例如，ArrayList类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)&#123;&#125;</span><br></pre></td></tr></table></figure><p>这个方法是用来把集合元素存储到指定数组类型的数组中，返回已存储集合元素的数组</p><p>使用格式：调用方法时，确定泛型的类型</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt;  array = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line">array.add(<span class="number">123</span>);</span><br><span class="line">array.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer[] i = <span class="keyword">new</span> Integer[array.size()];</span><br><span class="line">Integer [] j = array.toArray(i);</span><br><span class="line"><span class="keyword">for</span>(Integer k : j)&#123;</span><br><span class="line">    System.out.println(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br></pre></td></tr></table></figure><p>这个方法不常用，就是举个例子说一下，如果指定了E的类型，那么它的方法中E全部都是这个类型</p><h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>顾名思义就是带有泛型的接口</p><p>list类的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span> &lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的实现类，ArrayList类，先实现接口,不理会泛型</p><p> public class ArrayList<E> implements List<E>{}</p><p>这样是对调用者有好处的，比如new ArrayList&lt; String&gt;() 后期创建集合对象的时候,可以指定数据类型，指定了String，那么里面的E全部都会变成String这个类型</p><p>当然也可以实现接口的同时，也指定好了数据类型</p><p>public class XXX implements List&lt; String&gt;{}</p><p>但是以后new这个类的时候就不能随便指定类型了，只能String</p><h2 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h2><ol><li>将运行时期的ClassCastException异常，转移到了编译时期，变成了编译失败。</li><li>避免了类型的强转的麻烦</li></ol><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>先定义两个集合容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    array.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    array.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set.add(<span class="number">789</span>);</span><br><span class="line">    set.add(<span class="number">890</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如果需要定义一个方法，可以同时迭代2个集合，应该怎么实现呢</p><p>可以这样定义方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  定义方法,可以同时迭代2个集合</span></span><br><span class="line"><span class="comment"> *  参数: 怎么实现 , 不能写ArrayList,也不能写HashSet</span></span><br><span class="line"><span class="comment"> *  参数: 共同实现的接口</span></span><br><span class="line"><span class="comment"> *  泛型的通配符,匹配所有的数据类型  ?   这个符号就可以匹配所有的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; it = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型的限定"><a href="#泛型的限定" class="headerlink" title="泛型的限定"></a>泛型的限定</h3><p>比如我们创建了一个员工类， 他有三个子类，分别是厨师，服务员，经理，他们分别都有自己的工作方法work()</p><p>我们现在需要酒店员工,厨师,服务员,经理,分别存储到3个集合中，接着定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建3个集合对象</span></span><br><span class="line">ArrayList&lt;ChuShi&gt; cs = <span class="keyword">new</span> ArrayList&lt;ChuShi&gt;();</span><br><span class="line">ArrayList&lt;FuWuYuan&gt; fwy = <span class="keyword">new</span> ArrayList&lt;FuWuYuan&gt;();</span><br><span class="line">ArrayList&lt;JingLi&gt; jl = <span class="keyword">new</span> ArrayList&lt;JingLi&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个集合存储自己的元素</span></span><br><span class="line">cs.add(<span class="keyword">new</span> ChuShi(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;后厨001&quot;</span>));</span><br><span class="line">cs.add(<span class="keyword">new</span> ChuShi(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;后厨002&quot;</span>));</span><br><span class="line"></span><br><span class="line">fwy.add(<span class="keyword">new</span> FuWuYuan(<span class="string">&quot;翠花&quot;</span>, <span class="string">&quot;服务部001&quot;</span>));</span><br><span class="line">fwy.add(<span class="keyword">new</span> FuWuYuan(<span class="string">&quot;酸菜&quot;</span>, <span class="string">&quot;服务部002&quot;</span>));</span><br><span class="line"></span><br><span class="line">jl.add(<span class="keyword">new</span> JingLi(<span class="string">&quot;小名&quot;</span>, <span class="string">&quot;董事会001&quot;</span>, <span class="number">123456789.32</span>));</span><br><span class="line">jl.add(<span class="keyword">new</span> JingLi(<span class="string">&quot;小强&quot;</span>, <span class="string">&quot;董事会002&quot;</span>, <span class="number">123456789.33</span>));</span><br><span class="line"></span><br><span class="line">ArrayList&lt;String&gt; arrayString = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    iterator(jl);</span><br><span class="line">iterator(fwy);</span><br><span class="line">iterator(cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不用限定泛型那么方法这样写，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(ArrayList&lt;?&gt; array)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; it = array.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        Employee e = it.next();</span><br><span class="line">        e.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法是错误的，因为集合中还有个String类型，String类型没有work方法，所以这里要限定一下泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(ArrayList&lt;? extends Employee&gt; array)</span></span>&#123;</span><br><span class="line">    Iterator&lt;? extends Employee&gt; it = array.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        <span class="comment">//获取出的next() 数据类型,是Employee</span></span><br><span class="line">        Employee e = it.next();</span><br><span class="line">        e.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>借这个案例，引出泛型的限定这个概念</p><p>? extends Employee 限制的是父类, 上限限定, 可以传递Employee,传递他的子类对象</p><p>? super   Employee 限制的是子类, 下限限定, 可以传递Employee,传递他的父类对象</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitCracken7.0.0破解</title>
      <link href="posts/75da51a7.html"/>
      <url>posts/75da51a7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>此方法仅适用于7.0.0版本</p></blockquote><ol><li><p>前期准备</p><p>安装git<br>安装node<br>安装yarn（可以直接用npm下载）<code>npm install -g yarn --registry=https://registry.npm.taobao.org</code></p><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ yarn -v</span><br><span class="line">1.22.10</span><br><span class="line">$ npm -v</span><br><span class="line">6.14.6</span><br><span class="line">$ node -v</span><br><span class="line">v12.18.4</span><br></pre></td></tr></table></figure></li><li><p>屏蔽更新host</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitKraken 更新屏蔽</span></span><br><span class="line">127.0.0.1 release.gitkraken.com</span><br></pre></td></tr></table></figure></li><li><p>打开gitkraken并登陆</p></li><li><p>下载破解脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/5cr1pt/GitCracken.git</span><br></pre></td></tr></table></figure><p>最新的库不支持7.0.0,执行破解程序的时候，我这里报错了，所以我回退了一下版本</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201114114655.png"></p><p>进入此库，执行破解</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> GitCracken/GitCracken</span><br><span class="line">rm yarn.lock</span><br><span class="line">yarn install</span><br><span class="line">yarn build</span><br><span class="line"><span class="comment"># windows gitbash 改成对应版本</span></span><br><span class="line">node dist/bin/gitcracken.js patcher --asar ~/AppData/Local/gitkraken/app-7.0.0/resources/app.asar</span><br><span class="line"></span><br><span class="line"><span class="comment"># mac </span></span><br><span class="line">node dist/bin/gitcracken.js patcher --asar 你的gitkraken的目录/resources/app.asar</span><br></pre></td></tr></table></figure><p>如果成功，效果图如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201114114931.png"></p></li><li><p>重启gitkraken则能看见右下角的Pro</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201114115011.png"></p><p>切换账号则重新执行node命令</p></li></ol><p>参考：<a href="https://juejin.im/post/6844904087004135432">https://juejin.im/post/6844904087004135432</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 实用小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用类(包装类/System/Math/Arrays/大数据运算)</title>
      <link href="posts/80704cea.html"/>
      <url>posts/80704cea.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>回想下，在刚开始我们学习Java中的基本数据类型时，说Java中有8种基本的数据类型，可是这些数据是基本数据，想对其进行复杂操作，变的很难。怎么办呢？</p><h1 id="基本类型包装类"><a href="#基本类型包装类" class="headerlink" title="基本类型包装类"></a>基本类型包装类</h1><h2 id="基本类型包装类概述"><a href="#基本类型包装类概述" class="headerlink" title="基本类型包装类概述"></a>基本类型包装类概述</h2><p>在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等。那么，想实现字符串与基本数据之间转换怎么办呢？</p><p>Java中提供了相应的对象来解决该问题，基本数据类型对象包装类：java将基本数据类型值封装成了对象。封装成对象有什么好处？可以提供更多的操作基本数值的功能。</p><p>8种基本类型对应的包装类如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111231915.png"></p><p>其中需要注意int对应的是Integer，char对应的Character，其他6个都是基本类型首字母大写即可。</p><p>基本数据类型对象包装类特点：用于在基本数据和字符串之间进行转换。</p><ul><li><p>将字符串转成基本类型：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111232407.png"></p><p>parseXXX(String s);其中XXX表示基本类型，参数为可以转成基本类型的字符串，如果字符串无法转成基本类型，将会发生数字转换的问题 NumberFormatException</p><br /><p>我们这里主要就是看integer这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Integer类中静态方法 parseInt(String s) 返回基本数据类型</span></span><br><span class="line"><span class="comment"> * 要求: 字符串必须是数字格式的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = Integer.parseInt(<span class="string">&quot;12&quot;</span>);</span><br><span class="line">    System.out.println(i/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看api，parseInt还有重载方法parseInt(String s, int radix)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Integer类静态方法parseInt(String s, int radix)</span></span><br><span class="line"><span class="comment"> * radix基数,进制</span></span><br><span class="line"><span class="comment"> * &quot;110&quot;,2 含义 前面的数字是二进制的,但是方法parseInt运行结果都是十进制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = Integer.parseInt(<span class="string">&quot;110&quot;</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(i); <span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里在说一下，查看api，integer还有个tostring(int,int)重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = Interger.toString(<span class="number">5</span>,<span class="number">2</span>); <span class="comment">//将五转成二级制输出</span></span><br><span class="line">System.out.println(s1); <span class="comment">//101</span></span><br></pre></td></tr></table></figure><p>可以看到整个方法的作用，第二个参数就是进制，就是将int整数，转成指定进制数</p></blockquote></li><li><p>将基本数值转成字符串有3种方式：</p><ul><li><p>基本类型直接与””相连接即可；34+””    //一般推荐这种方法，因为很方便</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">String s = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">System.out.println(s+<span class="number">1</span>); <span class="comment">//此时打印会输出31，因为s已经变成了字符串了</span></span><br></pre></td></tr></table></figure></li><li><p>调用String的valueOf方法；<strong>String.valueOf(34)</strong> ；</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111233755.png"></p></li><li><p>调用包装类中的toString方法；<strong>Integer.toString(34)</strong> ；</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111233827.png"></p></li></ul></li></ul><h2 id="基本类型和对象转换"><a href="#基本类型和对象转换" class="headerlink" title="基本类型和对象转换"></a>基本类型和对象转换</h2><p>使用int类型与Integer对象转换进行演示，其他基本类型转换方式相同。</p><ul><li><p>基本数值—-&gt;包装对象</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201122001043.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer ii = <span class="keyword">new</span> Integer(<span class="string">&quot;4&quot;</span>);<span class="comment">//构造函数中可以传递一个数字字符串</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201122001126.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br><span class="line">Integer iiii = Integer.valueOf(<span class="string">&quot;4&quot;</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure></li><li><p>包装对象—-&gt;基本数值</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201122001216.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure></li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  Integer类构造方法</span></span><br><span class="line"><span class="comment"> *   Integer (String s)</span></span><br><span class="line"><span class="comment"> *   将数字格式的字符串,传递到Integer类的构造方法中</span></span><br><span class="line"><span class="comment"> *   创建Integer对象,包装的是一个字符串</span></span><br><span class="line"><span class="comment"> *   将构造方法中的字符串,转成基本数据类型,调用方法,非静态的, intValue()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">Integer in = <span class="keyword">new</span> Integer(<span class="string">&quot;100&quot;</span>); <span class="comment">//现在还不能直接进行数学运算，还需要将他转成 int对象</span></span><br><span class="line"><span class="keyword">int</span> i = in.intValue();</span><br><span class="line">System.out.println(--i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>Integer类的其他方法介绍</strong></p><ul><li><p>Integer类的静态成员变量</p><p>MAX_VALUE//最大值</p><p>MIN_VALUE //最小值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.MAX_VALUE);  <span class="comment">//查看int的最大值</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE);<span class="comment">//查看int的最小值</span></span><br></pre></td></tr></table></figure><p>这些静态成员变量都是通用的，也可以查看别的变量的最大值和最小值</p></li><li><p>Integer类的3个静态方法（做进制的转换）</p><p>十进制转成二进制  toBinarString(int)</p><p>十进制转成八进制  toOctalString(int)</p><p>十进制转成十六进制  toHexString(int)</p><p>三个方法,返回值都是以String形式出现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.toBinaryString(<span class="number">99</span>)); <span class="comment">//99的二进制</span></span><br><span class="line">System.out.println(Integer.toOctalString(<span class="number">99</span>));  <span class="comment">//99的八进制</span></span><br><span class="line">System.out.println(Integer.toHexString(<span class="number">999</span>));   <span class="comment">//999的十六进制</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="自动装箱拆箱"><a href="#自动装箱拆箱" class="headerlink" title="自动装箱拆箱"></a>自动装箱拆箱</h2><p>这是jdk1.5后出现的特性</p><p>在需要的情况下，基本类型与包装类型可以通用。有些时候我们必须使用引用数据类型时，可以传入基本数据类型。</p><p>比如：</p><p>​    基本类型可以使用运算符直接进行计算，但是引用类型不可以。而基本类型包装类作为引用类型的一种却可以计算，原因在于，Java”偷偷地”自动地进行了对象向基本数据类型的转换。</p><p>​    相对应的，引用数据类型变量的值必须是new出来的内存空间地址值，而我们可以将一个基本类型的值赋值给一个基本类型包装类的引用。原因同样在于Java又”偷偷地”自动地进行了基本数据类型向对象的转换。</p><ul><li><p>自动拆箱：对象转成基本数值</p></li><li><p>自动装箱：基本数值转成对象</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5; 加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure>  <br /></li><li><p>自动装箱(byte常量池)细节的演示</p><p>  当数值在byte范围之内时，进行自动装箱，不会新创建对象空间而是使用医来已有的空间。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">System.out.println(a==b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;---------------------&quot;</span>);</span><br><span class="line">Integer x = <span class="number">127</span>;</span><br><span class="line">Integer y = <span class="number">127</span>;</span><br><span class="line"><span class="comment">//在jdk1.5自动装箱时，如果数值在byte范围之内，不会新创建对象空间而是使用原来已有的空间。</span></span><br><span class="line">System.out.println(x==y); <span class="comment">//true</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul><hr><p>再次写下自己的理解，在Java中，如果jdk是1.5以后的，直接写<code>Integer i -= 1;</code>这条语句是不会报错的，按照之前学的知识，i是引用数据类型变量，引用变量一定会指向一个对象，也就是new的，但是1是个基本数据类型，他不是对象，为什么这里不会报错呢，原因是因为自动装箱，基本数据类型1直接变成了对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">1</span>; <span class="comment">//Integer i = new Integer(1);</span></span><br></pre></td></tr></table></figure><p>java进行了这个操作，虽然我们不需要写new Integer（1），但是我们要知道，它本质上就是一个对象</p><p>这也是个自动装箱的好处，可以省去很多的代码</p><br /><p>Java中，如果写<code>i=i+1;//i是Interger对象</code>，也不会报错，i是引用类型，不能和基本数据类型运算，为什么这里不会报错呢，是因为自动拆箱，这里的引用类型i自动转成了基本数据类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//i+1 ==&gt; i.inValue()+1 = 2; 自动拆箱操作</span></span><br><span class="line"><span class="comment">//i = 2   这里又进行了自动装箱操作</span></span><br><span class="line">i=i+<span class="number">1</span>;</span><br></pre></td></tr></table></figure><br /><p>自动装箱，拆箱的好处：基本类型和引用类型直接运算</p><p>弊端：有可能会带来空指针异常</p><p>如果给i赋一个null，null拆箱的过程中会调用intValue()方法，null不能调方法，所以这时候会产生异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i =<span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//i = null.intValue()+1</span></span><br><span class="line">i = i + <span class="number">1</span>;</span><br><span class="line">System.out.println(i);</span><br></pre></td></tr></table></figure><hr><p>思考题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">Integer j = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(i==j);</span><br><span class="line">System.out.println(i.equals(j));</span><br></pre></td></tr></table></figure><p>输出是什么</p><blockquote><p>解析：== 引用类型，比较的是对象地址，是false</p><p>第二个是 true  ，Integer继承Object重写equals,比较的对象数据</p></blockquote><br /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">500</span>;</span><br><span class="line">Integer b = <span class="number">500</span>;</span><br><span class="line">System.out.println(a==b);</span><br><span class="line">System.out.println(a.equals(b));</span><br></pre></td></tr></table></figure><p>输出是什么</p><blockquote><p>解析：第一个是由于自动装箱，==两边是引用类型，比较地址，所以是false</p><p>第二个是比较值，true</p></blockquote><br /><p>根据上一道题，再出一道题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">50</span>;</span><br><span class="line">Integer b = <span class="number">50</span>;</span><br><span class="line">System.out.println(a==b);</span><br><span class="line">System.out.println(a.equals(b));</span><br></pre></td></tr></table></figure><p>肯定是false和true了</p><p>第二个没问题，但是第一个是true，这又是为什么，那之前为什么又是false</p><p>再看一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">127</span>;</span><br><span class="line">Integer b = <span class="number">127</span>;</span><br><span class="line">System.out.println(a==b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>但如果两个是128，==比较就是false</p><br /><p>解释：数据在byte范围内，jvm不会重新new对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer aa = <span class="number">127</span>; <span class="comment">//Integer aa = new Integer (127) 执行第一句话的时候，jvm做了这个操作</span></span><br><span class="line">Integer bb = <span class="number">127</span>; <span class="comment">//Integer bb = aa; 执行第二句话的时候，jvm看到这个数据如果是byte范围内的就不会重新new对象，他会直接将之前那个对象赋给它</span></span><br><span class="line">System.out.println(a==b); <span class="comment">//所以同同一个对象，两个地址肯定是true</span></span><br></pre></td></tr></table></figure><h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在API中System类介绍的比较简单，我们给出定义，System中代表程序所在系统，提供了对应的一些系统属性信息，和系统操作。</p><p>System类不能手动创建对象，因为构造方法被private修饰，阻止外界创建对象。System类中的都是static方法，类名访问即可。在JDK中，有许多这样的类。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201123222850.png"></p><ul><li><p><strong>currentTimeMillis</strong>() 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值</p></li><li><p><strong>exit(int status)</strong> 用来结束正在运行的Java程序。参数传入一个数字即可。通常传入0记为正常状态，其他为异常状态</p></li><li><p><strong>gc()</strong> 用来运行JVM中的垃圾回收器，完成内存中垃圾的清除。</p></li><li><p><strong>getProperty(String key)</strong> 用来获取指定<strong>键</strong>(字符串名称)中所记录的系统属性信息</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201123223047.png"></p></li><li><p><strong>arraycopy</strong>方法，用来实现将源数组部分元素复制到目标数组的指定位置</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201123223116.png"></p></li></ul><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><ol><li><p>验证for循环打印数字1-9999所需要使用的时间（毫秒）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; i++) &#123;</span><br><span class="line">         System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;共耗时毫秒：&quot;</span> + (end-start) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>将src数组中前3个元素，复制到dest数组的前3个位置上</p><p> 复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]</p><p> 复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] src = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] dest = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    System.arraycopy( src, <span class="number">0</span>, dest, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//代码运行后：两个数组中的元素发生了变化</span></span><br><span class="line"><span class="comment">//src数组元素[1,2,3,4,5]</span></span><br><span class="line">    <span class="comment">//dest数组元素[1,2,3,9,10]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环生成100-999之间的的三位数并进行打印该数，当该数能被10整除时，结束运行的程序</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> number = random.nextInt(<span class="number">900</span>) + <span class="number">100</span>; <span class="comment">//0-899 + 100</span></span><br><span class="line">        <span class="keyword">if</span> (nmumber % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>lang包中的</p><p>Math类是包含用于执行基本数学运算的方法的数学工具类，如初等指数、对数、平方根和三角函数。</p><p>类似这样的<code>工具类</code>，其所有方法均为静态方法，并且一般不会创建对象。如System类工具类，代表能够完成一系列功能的类，在使用它们时，不用创建对象，该类中方法为静态方法    </p><p><em>(工具类：代表能够完成一系列功能的类，在使用它们时，不用创建对象，该类中方法为静态方法)</em></p><h2 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201123233804.png"></p><ul><li><p>abs方法,结果都为正数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.abs(-<span class="number">5</span>); <span class="comment">// d1的值为5</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.abs(<span class="number">5</span>); <span class="comment">// d2的值为5</span></span><br></pre></td></tr></table></figure></li><li><p>ceil方法，结果为比参数值大的最小整数的double值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.ceil(<span class="number">3.3</span>); <span class="comment">//d1的值为 4.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.ceil(-<span class="number">3.3</span>); <span class="comment">//d2的值为 -3.0</span></span><br><span class="line"><span class="keyword">double</span> d3 = Math.ceil(<span class="number">5.1</span>); <span class="comment">// d3的值为 6.0</span></span><br></pre></td></tr></table></figure></li><li><p>floor方法，结果为比参数值小的最大整数的double值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.floor(<span class="number">3.3</span>); <span class="comment">//d1的值为3.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.floor(-<span class="number">3.3</span>); <span class="comment">//d2的值为-4.0</span></span><br><span class="line"><span class="keyword">double</span> d3 = Math.floor(<span class="number">5.1</span>); <span class="comment">//d3的值为 5.0</span></span><br></pre></td></tr></table></figure></li><li><p>max方法，返回两个参数值中较大的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.max(<span class="number">3.3</span>, <span class="number">5.5</span>); <span class="comment">//d1的值为5.5</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.max(-<span class="number">3.3</span>, -<span class="number">5.5</span>); <span class="comment">//d2的值为-3.3</span></span><br></pre></td></tr></table></figure></li><li><p>min方法，返回两个参数值中较小的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.min(<span class="number">3.3</span>, <span class="number">5.5</span>); <span class="comment">//d1的值为3.3</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.max(-<span class="number">3.3</span>, -<span class="number">5.5</span>); <span class="comment">//d2的值为-5.5</span></span><br></pre></td></tr></table></figure></li><li><p>pow方法，返回第一个参数的第二个参数次幂的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.pow(<span class="number">2.0</span>, <span class="number">3.0</span>); <span class="comment">//d1的值为 8.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.pow(<span class="number">3.0</span>, <span class="number">3.0</span>); <span class="comment">//d2的值为27.0</span></span><br></pre></td></tr></table></figure></li><li><p>round方法，返回参数值四舍五入，取整数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.round(<span class="number">5.5</span>); <span class="comment">//d1的值为6.0</span></span><br><span class="line"><span class="keyword">double</span> d2 = Math.round(<span class="number">5.4</span>); <span class="comment">//d2的值为5.0</span></span><br></pre></td></tr></table></figure></li><li><p>random方法，产生一个大于等于0.0且小于1.0的double小数 //来源是random类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = Math.random();</span><br></pre></td></tr></table></figure></li></ul><h1 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>util包中</p><p>此类包含用来操作数组（比如排序和搜索）的各种方法。需要注意，如果指定数组引用为 null，则访问此类中的方法都会抛出空指针异常NullPointerException。</p><h2 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201123235037.png"></p><ul><li><p>sort方法，用来对指定数组中的元素进行排序（元素值从小到大进行排序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源arr数组元素&#123;1,5,9,3,7&#125;, 进行排序后arr数组元素为&#123;1,3,5,7,9&#125;</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">Arrays.sort( arr );</span><br></pre></td></tr></table></figure></li><li><p>toString方法，用来返回指定数组元素内容的字符串形式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">7</span>&#125;;</span><br><span class="line">String str = Arrays.toString(arr); <span class="comment">// str的值为[1, 3, 5, 7, 9]</span></span><br></pre></td></tr></table></figure></li><li><p>binarySearch方法，在指定数组中，查找给定元素值出现的位置。若没有查询到，返回位置为-1。要求该数组必须是个有序的数组。（其他情况不一定是-1，如果是查询一个数，但是数组中没有，返回的是<code>(-插入点-1)</code>插入点是将要查询的数带入原数组，有序的放入，那个点就是插入点，具体写代码可以体会，api中说明了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> index = Arrays.binarySearch(arr, <span class="number">4</span>); <span class="comment">//index的值为2</span></span><br><span class="line"><span class="keyword">int</span> index2= Arrasy.binarySearch(arr, <span class="number">2</span>); <span class="comment">//index2的值为-1</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>定义一个方法，接收一个数组，数组中存储10个学生考试分数，该方法要求返回考试分数最低的后三名考试分数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] method(<span class="keyword">double</span>[] arr)&#123;</span><br><span class="line">    Arrays.sort(arr); <span class="comment">//进行数组元素排序（元素值从小到大进行排序）</span></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>]; <span class="comment">//存储后三名考试分数</span></span><br><span class="line">    System.arraycopy(arr, <span class="number">0</span>, result, <span class="number">0</span>, <span class="number">3</span>);<span class="comment">//把arr数组前3个元素复制到result数组中</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大数据运算"><a href="#大数据运算" class="headerlink" title="大数据运算"></a>大数据运算</h1><h2 id="BigInteger类"><a href="#BigInteger类" class="headerlink" title="BigInteger类"></a>BigInteger类</h2><p> java中long型为最大整数类型,对于超过long型的数据如何去表示呢.在Java的世界中,超过long型的整数已经不能被称为整数了,它们被封装成BigInteger对象.在BigInteger类中,实现四则运算都是方法来实现,并不是采用运算符.</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201124000815.png"></p><p>构造方法中,采用字符串的形式给出整数</p><p>四则运算代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//大数据封装为BigInteger对象</span></span><br><span class="line">    BigInteger big1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12345678909876543210&quot;</span>);</span><br><span class="line">    BigInteger big2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;98765432101234567890&quot;</span>);</span><br><span class="line">    <span class="comment">//add实现加法运算</span></span><br><span class="line">    BigInteger bigAdd = big1.add(big2);</span><br><span class="line">    <span class="comment">//subtract实现减法运算</span></span><br><span class="line">    BigInteger bigSub = big1.subtract(big2);</span><br><span class="line">    <span class="comment">//multiply实现乘法运算</span></span><br><span class="line">    BigInteger bigMul = big1.multiply(big2);</span><br><span class="line">    <span class="comment">//divide实现除法运算</span></span><br><span class="line">    BigInteger bigDiv = big2.divide(big1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BigDecimal类"><a href="#BigDecimal类" class="headerlink" title="BigDecimal类"></a>BigDecimal类</h2><p>在程序中执行下列代码,会出现什么问题?</p><p>System.out.println(0.09 + 0.01);<br>System.out.println(1.0 - 0.32);<br>System.out.println(1.015 * 100);<br>System.out.println(1.301 / 100);</p><p>结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201124130120.png"></p><p> double和float类型在运算中很容易丢失精度,造成数据的不准确性,Java提供我们BigDecimal类可以实现浮点数据的高精度运算</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201124001356.png"></p><p> 建议浮点数据以字符串形式给出,因为参数结果是可以预知的</p><p> 实现加法减法乘法代码如下: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//大数据封装为BigDecimal对象</span></span><br><span class="line">BigDecimal big1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.09&quot;</span>);</span><br><span class="line">BigDecimal big2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.01&quot;</span>);</span><br><span class="line"><span class="comment">//add实现加法运算</span></span><br><span class="line">BigDecimal bigAdd = big1.add(big2); <span class="comment">//1.0</span></span><br><span class="line"></span><br><span class="line">BigDecimal big3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal big4 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.32&quot;</span>);</span><br><span class="line"><span class="comment">//subtract实现减法运算</span></span><br><span class="line">BigDecimal bigSub = big3.subtract(big4); <span class="comment">//0.68</span></span><br><span class="line"></span><br><span class="line">BigDecimal big5 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.105&quot;</span>);</span><br><span class="line">BigDecimal big6 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"><span class="comment">//multiply实现乘法运算</span></span><br><span class="line">BigDecimal bigMul = big5.multiply(big6);<span class="comment">//110.500</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于浮点数据的除法运算,和整数不同,可能出现无限不循环小数,因此需要对所需要的位数进行保留和选择舍入模式</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201124001515.png"></p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201124001523.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> System类 </tag>
            
            <tag> Math类 </tag>
            
            <tag> Arrays类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日期和时间对象</title>
      <link href="posts/2af9b407.html"/>
      <url>posts/2af9b407.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><h2 id="Date类概述"><a href="#Date类概述" class="headerlink" title="Date类概述"></a>Date类概述</h2><p>类 Date 表示特定的瞬间，精确到毫秒。</p><blockquote><p>时间和日期类<br>  java.util.Date</p><p>毫秒概念: 1000毫秒=1秒</p><p>毫秒的0点:<br>   System.currentTimeMillis() 返回值long类型参数<br>   获取当前日期的毫秒值   3742769374405<br>   时间原点： 公元1970年1月1日,午夜0:00:00   毫秒值就是0</p><p>这是个很重要的概念，因为时间和日期的计算,必须依赖毫秒值<br>  XXX-XXX-XX = 毫秒</p></blockquote><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111164609.png"></p><p>空参构造器获取的时间是操作系统中的当前时间和日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">1607616000000L</span>);</span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">//打印结果：Fri Dec 11 00:00:00 CST 2020  </span></span><br></pre></td></tr></table></figure><p>可是将毫秒值转成日期后，输出的格式不利于我们阅读，继续查阅API，Date中有getYear、getMouth等方法，可以他们已经过时，继续往下查阅，看到了toString方法。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111164704.png"></p><p>点开toString()方法查阅，原来上面打印的date对象就是默认调用了这个toString方法，并且在这个方法下面还有让我们参见toLocaleString方法，点进去，这个方法又过时了，从 JDK 1.1 开始，由 DateFormat.format(Date date) 取代。 </p><p>既然这个方法被DateFormat.format(Date date) 取代，那么就要去查阅DateFormat类。</p><h2 id="Date类常用方法"><a href="#Date类常用方法" class="headerlink" title="Date类常用方法"></a>Date类常用方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111164852.png"></p><p>把日期对象转换成对应的时间毫秒值</p><p>还有一个方法是<code>setTime(long )</code></p><p>这是用于，毫秒值转成日期对象，或者用Date类的构造器也可以实现</p><h1 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h1><h2 id="DateFormat类概述"><a href="#DateFormat类概述" class="headerlink" title="DateFormat类概述"></a>DateFormat类概述</h2><p>这个类在test包中，DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 <font color=red><strong>SimpleDateFormat类</strong></font>）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。</p><p>我们通过这个类可以帮我们完成日期和文本之间的转换。</p><p>继续阅读API，DateFormat 可帮助进行格式化并解析任何语言环境的日期。对于月、星期，甚至日历格式（阴历和阳历），其代码可完全与语言环境的约定无关。</p><blockquote><p>这是api中的介绍复制过来的，说白了，就是用于说自定义显示的时间格式的，直接得到的日期对象，不利于阅读，dateformat是个抽象类，里面有具体方法也有抽象方法，实际开发中使用的是它的子类SimpleDateFormat类，来实现需要的功能</p></blockquote><h2 id="日期格式"><a href="#日期格式" class="headerlink" title="日期格式"></a>日期格式</h2><p>要格式化一个当前语言环境下的日期也就是（日期 -&gt; 文本），要通过下面的方法来完成。DateFormat是抽象类，我们需要使用其子类SimpleDateFormat来创建对象。</p><p>关于日期的格式怎么写，api中也有具体的模式，可以查看</p><ul><li><p>构造方法</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111172901.png"></p></li><li><p>DateFormat类方法</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111172919.png"></p></li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何对日期格式化</span></span><br><span class="line"><span class="comment"> *  步骤:</span></span><br><span class="line"><span class="comment"> *    1. 创建SimpleDateFormat对象</span></span><br><span class="line"><span class="comment"> *       在类构造方法中,写入字符串的日期格式 (自己定义)</span></span><br><span class="line"><span class="comment"> *    2. SimpleDateFormat调用方法format对日期进行格式化</span></span><br><span class="line"><span class="comment"> *         String format(Date date) 传递日期对象,返回字符串</span></span><br><span class="line"><span class="comment"> *    日期模式:</span></span><br><span class="line"><span class="comment"> *       yyyy    年份</span></span><br><span class="line"><span class="comment"> *       MM      月份</span></span><br><span class="line"><span class="comment"> *       dd      月中的天数</span></span><br><span class="line"><span class="comment"> *       HH       0-23小时</span></span><br><span class="line"><span class="comment"> *       mm      小时中的分钟</span></span><br><span class="line"><span class="comment"> *       ss      秒</span></span><br><span class="line"><span class="comment"> *       yyyy年MM月dd日 HH点mm分钟ss秒  汉字修改,: -  字母表示的每个字段不可以随便写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH点mm分钟ss秒&quot;</span>);</span><br><span class="line">String date = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DateFormat类常用方法"><a href="#DateFormat类常用方法" class="headerlink" title="DateFormat类常用方法"></a>DateFormat类常用方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111174553.png"></p><ul><li>format方法，用来将Date对象转换成String</li><li>parse方法，用来将String转换成Date（转换时，该String要符合指定格式，否则不能转换）。</li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把Date对象转换成String</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">1607616000000L</span>);<span class="comment">//Fri Dec 11 00:00:00 CST 2020</span></span><br><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">String str = df.format(date);<span class="comment">//str中的内容为2020年12月11日</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把String转换成Date对象</span></span><br><span class="line">String str = ”<span class="number">2020</span>年<span class="number">12</span>月<span class="number">11</span>日”;</span><br><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">Date date = df.parse( str );<span class="comment">//Date对象中的内容为Fri Dec 11 00:00:00 CST 2020</span></span><br></pre></td></tr></table></figure><h1 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h1><h2 id="Calendar类概念"><a href="#Calendar类概念" class="headerlink" title="Calendar类概念"></a>Calendar类概念</h2><p>Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</p><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，将语言敏感内容处理好，再返回子类对象</p><blockquote><p>日历类 java.util.Calendar</p><p>他是个抽象类，我们如果要使用它，就得用他的子类对象</p><p>但是，它有个静态方法，getInstance() 直接返回了子类的对象，所以不需要直接new 子类的对象,可以通过静态方法直接获取</p></blockquote><ul><li><p>Calendar类静态方法</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111175749.png"></p><p>Calendar c = Calendar.getInstance(); //返回当前时间</p></li></ul><h2 id="Calendar类常用方法"><a href="#Calendar类常用方法" class="headerlink" title="Calendar类常用方法"></a>Calendar类常用方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111221317.png"></p><ul><li><p>calendar类的get方法 </p><p>获取日历字段的值 int get(int) 参数int,获取的哪个日历字段 返回值,就表示日历字段的具体数值</p><ul><li>YEAR 年</li><li>MONTH 月，从0开始算起，最大11；0代表1月，11代表12月。</li><li>DATE 天</li><li>HOUR 时</li><li>MINUTE分</li><li>SECOND秒</li></ul><p>代码演示：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funtion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calendar c = Calendar.getInstance();</span><br><span class="line">    <span class="comment">// 获取年份</span></span><br><span class="line">    <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">    <span class="comment">// 获取月份</span></span><br><span class="line">    <span class="keyword">int</span> month = c.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取天数</span></span><br><span class="line">    <span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Calendar类的set方法 </p><p>设置日历 set(int field,int value) field 设置的是哪个日历字段 value 设置后的具体数值</p><p>set(int year,int month,int day) 传递3个整数的年,月,日</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calendar c = Calendar.getInstance();</span><br><span class="line">    <span class="comment">// 设置,月份,设置到10月分</span></span><br><span class="line">    <span class="comment">// c.set(Calendar.MONTH, 9);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置年,月,日</span></span><br><span class="line">    c.set(<span class="number">2099</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取年份</span></span><br><span class="line">    <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">    <span class="comment">// 获取月份</span></span><br><span class="line">    <span class="keyword">int</span> month = c.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取天数</span></span><br><span class="line">    <span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Calendar类方法add </p><p>日历的偏移量，可以指定一个日历中的字段</p><p>进行整数的偏移 add(int field, int value)</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calendar c = Calendar.getInstance();</span><br><span class="line">    <span class="comment">// 让日历中的天数,向后偏移280天</span></span><br><span class="line">    c.add(Calendar.DAY_OF_MONTH, -<span class="number">280</span>);</span><br><span class="line">    <span class="comment">// 获取年份</span></span><br><span class="line">    <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">    <span class="comment">// 获取月份</span></span><br><span class="line">    <span class="keyword">int</span> month = c.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取天数</span></span><br><span class="line">    <span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Calendar类的方法getTime()</p><p>把日历对象,转成Date日期对象</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Calendar c = Calendar.getInstance();</span><br><span class="line">    Date date = c.getTime();</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="日期相关类练习"><a href="#日期相关类练习" class="headerlink" title="日期相关类练习"></a>日期相关类练习</h1><ol><li><p>求出自己已经出生多少天</p><p>思路：</p><ul><li>获取当前时间对应的天数</li><li>获取自己出生日期对应的天数</li><li>两个时间相减（当前时间天数 – 出生日期天数）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入出生日期 格式 YYYY-MM-dd&quot;</span>);</span><br><span class="line"><span class="comment">//获取出生日期,键盘输入</span></span><br><span class="line">String birthdayString = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line"><span class="comment">//将字符串日期,转成Date对象</span></span><br><span class="line"><span class="comment">//创建SimpleDateFormat对象,写日期模式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="comment">//调用方法parse,字符串转成日期对象</span></span><br><span class="line">Date birthdayDate = sdf.parse(birthdayString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取今天的日期对象</span></span><br><span class="line">Date todayDate = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个日期转成毫秒值,Date类的方法getTime</span></span><br><span class="line"><span class="keyword">long</span> birthdaySecond = birthdayDate.getTime();</span><br><span class="line"><span class="keyword">long</span> todaySecond = todayDate.getTime();</span><br><span class="line"><span class="keyword">long</span> secone = todaySecond-birthdaySecond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(secone &lt; <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;还没出生呢&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(secone/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Calendar my = Calendar.getInstance();</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"><span class="comment">//设置出生年月日 1995-05-10</span></span><br><span class="line">my.set(Calendar.YEAR, <span class="number">1995</span>);</span><br><span class="line">my.set(Calendar.MONTH, <span class="number">4</span>);</span><br><span class="line">my.set(Calendar.DATE, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//获取时间中的天数</span></span><br><span class="line"><span class="keyword">int</span> day = c.get(Calendar.DATE);</span><br><span class="line"><span class="keyword">int</span> myDay = my.get(Calendar.DATE);</span><br><span class="line">System.out.println(day - myDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>闰年计算</p><p>高级的算法: 日历设置到指定年份的3月1日,add向前偏移1天,如果获取的天数是29，那么它就是闰年</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Calendar c = Calendar.getInstance();</span><br><span class="line">    <span class="comment">//将日历,设置到指定年的3月1日</span></span><br><span class="line">    c.set(<span class="number">2088</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//日历add方法,向前偏移1天</span></span><br><span class="line">    c.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//get方法获取天数</span></span><br><span class="line">    <span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 日期对象 </tag>
            
            <tag> Date </tag>
            
            <tag> DateFormat </tag>
            
            <tag> Calendar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="posts/2f57a694.html"/>
      <url>posts/2f57a694.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>正则表达式</strong>（英语：Regular Expression，在代码中常简写为regex）。</p><p>正则表达式是一个字符串，使用单个字符串来描述、用来定义匹配规则，匹配一系列符合某个句法规则的字符串。在开发中，正则表达式通常被用来检索、替换那些符合某个规则的文本。</p><hr><p>举个例子</p><p>一个qq号码：12345678</p><p>检查QQ是否是合法的存在（全是数字，位数5-10，开头不是0）</p><p>满足一定规则：表示可以是一个字符串表示规则（正则表达式）</p><p>QQ号码也是字符串，规则也是一个字符串，进行匹配检查</p><p>那么这个正则表达式就可以写成<code>[1-9][0-9](4,9)</code>（第一位是1-9的数字，第二位开始可以出现0 了，第二位开始，最少出现四次，最多不能出现9次）</p><h1 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1><p>参照帮助文档，在Pattern类中有正则表达式的的规则定义，正则表达式中明确区分大小写字母。我们来学习语法规则。</p><p>正则表达式的语法规则：</p>  <br/><p><font color=red><strong>字符：x</strong></font></p><p><font color=red>含义：代表的是字符x</font></p><p>例如：匹配规则为 “a”，那么需要匹配的字符串内容就是 ”a”</p>  <br/><p><font color=red><strong>字符：\\</strong></font></p><p><font color=red>含义：代表的是反斜线字符\‘&#39;</font></p><p>例如：匹配规则为”\\&quot; <strong>，</strong>那么需要匹配的字符串内容就是 ”\”</p>  <br/><p><font color=blue><strong>字符：</strong>\t</font></p><p><font color=blue>含义：制表符</font></p><p>例如：匹配规则为”\t” ，那么对应的效果就是产生一个制表符的空间  </p><br/><p><font color=red><strong>字符：\n</strong></font></p><p><font color=red>含义：换行符</font></p><p>例如：匹配规则为”\n”，那么对应的效果就是换行,光标在原有位置的下一行  </p><br/><p><font color=red><strong>字符：\r</strong></font></p><p><font color=red>含义：回车符</font></p><p>例如：匹配规则为”\r” ，那么对应的效果就是回车后的效果,光标来到下一行行首  </p><br/><p><font color=blue><strong>字符类：[abc]</strong></font></p><p><font color=blue>含义：代表的是字符a、b 或 c</font></p><p>例如：匹配规则为”[abc]” ，那么需要匹配的内容就是字符a，或者字符b，或字符c的一个 </p> <br/><p><font color=blue><strong>字符类：<code>[^abc]</code></strong></font></p><p><font color=blue>含义：代表的是除了 a、b 或 c以外的任何字符</font></p><p>例如：匹配规则为<code>[^abc]</code>，那么需要匹配的内容就是不是字符a，或者不是字符b，或不是字符c的任意一个字符  </p><br/><p><font color=blue><strong>字符类：[a-zA-Z]</strong></font></p><p><font color=blue>含义：代表的是a 到 z 或 A 到 Z，两头的字母包括在内</font></p><p>例如：匹配规则为”[a-zA-Z]”，那么需要匹配的是一个大写或者小写字母</p> <br/><p><font color=blue><strong>字符类：[0-9]</strong></font></p><p><font color=blue>含义：代表的是 0到9数字，两头的数字包括在内</font></p><p>例如：匹配规则为”[0-9]”，那么需要匹配的是一个数字</p> <br/><p><font color=blue><strong>字符类：[a-zA-Z_0-9]</strong></font></p><p><font color=blue>含义：代表的字母或者数字或者下划线(即单词字符)</font></p><p>例如：匹配规则为” [a-zA-Z_0-9] “，那么需要匹配的是一个字母或者是一个数字或一个下滑线</p> <br /><p><font color=blue><strong>预定义字符类：.</strong></font></p><p><font color=blue>含义：代表的是任何字符</font></p><p>例如：匹配规则为” . “，那么需要匹配的是一个任意字符。如果，就想使用 . 的话，使用匹配规则”\.”来实现</p>  <br/><p><font color=blue><strong>预定义字符类：\d</strong></font></p><p><font color=blue>含义：代表的是 0到9数字，两头的数字包括在内，相当于[0-9]</font></p><p>例如：匹配规则为”\d “，那么需要匹配的是一个数字</p>  <br/><p><font color=blue><strong>预定义字符类：\w</strong></font></p><p><font color=blue>含义：代表的字母或者数字或者下划线(即单词字符)，相当于**[a-zA-Z_0-9]**</font></p><p>例如：匹配规则为”\w “，，那么需要匹配的是一个字母或者是一个数字或一个下滑线</p>  <br/><p><font color=red><strong>边界匹配器：^</strong></font></p><p><font color=red>含义：代表的是行的开头</font></p><p>例如：匹配规则为<code>^[abc][0-9]$</code> ，那么需要匹配的内容从[abc]这个位置开始, 相当于左双引号</p>  <br/><p><font color=red><strong>边界匹配器：$</strong></font></p><p><font color=red>含义：代表的是行的结尾</font></p><p>例如：匹配规则为<code>^[abc][0-9]$</code> ，那么需要匹配的内容以[0-9]这个结束, 相当于右双引号</p>  <br/><p><font color=red><strong>边界匹配器：\b</strong></font></p><p><font color=red>含义：代表的是单词边界</font></p><p>例如：匹配规则为”\b[abc]\b” ，那么代表的是字母a或b或c的左右两边需要的是非单词字符([a-zA-Z_0-9])</p>  <br/><p><font color=red><strong>数量词：X?</strong></font></p><p><font color=red>含义：代表的是X出现一次或一次也没有</font></p><p>例如：匹配规则为”a?”，那么需要匹配的内容是一个字符a，或者一个a都没有</p>  <br/><p><font color=red><strong>数量词：X*</strong></font></p><p><font color=red>含义：代表的是X出现零次或多次</font></p><p>例如：匹配规则为”a*“ ，那么需要匹配的内容是多个字符a，或者一个a都没有</p>  <br/><p><font color=blue><strong>数量词：X+</strong></font></p><p><font color=blue>含义：代表的是X出现一次或多次</font></p><p>例如：匹配规则为”a+”，那么需要匹配的内容是多个字符a，或者一个a</p>  <br/><p><font color=blue><strong>数量词：X{n}</strong></font></p><p><font color=blue>含义：代表的是X出现恰好 n 次</font></p><p>例如：匹配规则为”a{5}”，那么需要匹配的内容是5个字符a</p>  <br/><p><font color=blue><strong>数量词：X{n,}</strong></font></p><p><font color=blue>含义：代表的是X出现至少 n 次</font></p><p>例如：匹配规则为”a{5, }”，那么需要匹配的内容是最少有5个字符a</p>  <br/><p><font color=blue><strong>数量词：X{n,m}</strong></font></p><p><font color=blue>含义：代表的是X出现至少 n 次，但是不超过 m 次</font></p><p>例如：匹配规则为”a{5,8**}”**，那么需要匹配的内容是有5个字符a 到 8个字符a之间</p><h1 id="规则匹配练习"><a href="#规则匹配练习" class="headerlink" title="规则匹配练习"></a>规则匹配练习</h1><p>请写出满足如下匹配规则的字符串:</p><p>规则：”[0-9]{6,12}”</p><p>该规则需要匹配的内容是：<strong>长度为6位到12位的数字。</strong></p><p>如：使用数据”123456789”进行匹配结果为true；</p><p>使用数据”12345”进行匹配结果为false。</p><br /><p>规则：<code>&quot;1[34578][0-9]&#123;9&#125;&quot;</code></p><p>该规则需要匹配的内容是：<strong>11位的手机号码，第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。</strong></p><p>如：使用数据”12345678901”进行匹配结果为false；</p><p>使用数据”13312345678”进行匹配结果为true。</p><br /><p>规则：”a*b”</p><p>该规则需要匹配的内容是：<strong>在多个a或零个a后面有个b；b必须为最后一个字符。</strong><br>如：使用数据”aaaaab”进行匹配结果为true；<br>使用数据”abc”进行匹配结果为false。</p><h1 id="字符串类中涉及正则表达式的常用方法"><a href="#字符串类中涉及正则表达式的常用方法" class="headerlink" title="字符串类中涉及正则表达式的常用方法"></a>字符串类中涉及正则表达式的常用方法</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111155743.png"></p><p>实现正则规则和字符串进行匹配,使用到字符串类的方法<br>String类三个和正则表达式相关的方法</p><ol><li><p>boolean matches(String 正则的规则)<br>“abc”.matches(“[a]”)  匹配成功返回true</p></li><li><p>String[] split(String 正则的规则)<br>“abc”.split(“a”) 使用规则将字符串进行切割</p></li><li><p>String replaceAll( String 正则规则,String 字符串)<br>“abc0123”.repalceAll(“[\d]”,”#”)<br>安装正则的规则,替换字符串</p></li></ol><hr><p>举例</p><ul><li><p>public boolean <strong>matches</strong>(String regex) //判断字符串是否匹配给定的规则</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  检查QQ号码是否合法</span></span><br><span class="line"><span class="comment"> *  0不能开头,全数字, 位数5,10位</span></span><br><span class="line"><span class="comment"> *  123456 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQQ</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String QQ = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="comment">//检查QQ号码和规则是否匹配,String类的方法matches</span></span><br><span class="line">    <span class="keyword">boolean</span> b = QQ.matches(<span class="string">&quot;[1-9][0-9]&#123;4,9&#125;&quot;</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中，[0-9]可以写成<code>\d</code>的形式，但是直接这样写会报错<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111160706.png"></p><p>  <code>\</code>是转义字符，应该在加一个<code>\</code>,即<code>boolean b = QQ.matches(&quot;[1-9][\\d]&#123;4,9&#125;&quot;);</code></p>  <br />  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  检查手机号码是否合法</span></span><br><span class="line"><span class="comment"> *  1开头 可以是34578  0-9 位数固定11位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkTel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String telNumber = <span class="string">&quot;1335128005&quot;</span>;</span><br><span class="line">    <span class="comment">//String类的方法matches</span></span><br><span class="line">    <span class="keyword">boolean</span> b = telNumber.matches(<span class="string">&quot;1[34857][\\d]&#123;9&#125;&quot;</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中，<code>[34857]</code>这里面的数字是没有顺序规则的</p>  <br /></li><li><p>public String[] <strong>split</strong>(String regex)  //根据给定正则表达式的匹配规则，拆分此字符串</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  String类方法split对字符串进行切割</span></span><br><span class="line"><span class="comment"> *  12-25-36-98  按照-对字符串进行切割</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;12-25-36-98&quot;</span>;</span><br><span class="line"><span class="comment">//按照-对字符串进行切割,String类方法split</span></span><br><span class="line">String[] strArr = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;数组的长度&quot;</span>+strArr.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strArr.length ; i++)&#123;</span><br><span class="line">System.out.println(strArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * String类方法split对字符串进行切割</span></span><br><span class="line"><span class="comment"> * 18 22 40 65 按照空格切割字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;18    22     40          65&quot;</span>;</span><br><span class="line">String[] strArr = str.split(<span class="string">&quot; +&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;数组的长度&quot;</span>+strArr.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strArr.length ; i++)&#123;</span><br><span class="line">System.out.println(strArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * String类方法split对字符串进行切割</span></span><br><span class="line"><span class="comment"> * 192.168.105.27 按照 点切割字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">String ip = <span class="string">&quot;192.168.105.27&quot;</span>;</span><br><span class="line">String[] strArr = ip.split(<span class="string">&quot;\\.&quot;</span>); <span class="comment">//如果直接写. 的话，.会和字符串中的任意元素匹配，切不下来，所以需要转义字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;数组的长度&quot;</span>+strArr.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strArr.length ; i++)&#123;</span><br><span class="line">System.out.println(strArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <br /></li><li><p>public String <strong>replaceAll</strong>(String regex,String replacement)  //将符合规则的字符串内容，全部替换为新字符串</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &quot;Hello12345World6789012&quot;将所有数字替换掉</span></span><br><span class="line"><span class="comment"> * String类方法replaceAll(正则规则,替换后的新字符串)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replaceAll_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;Hello12345World6789012&quot;</span>;</span><br><span class="line">str = str.replaceAll(<span class="string">&quot;[\\d]+&quot;</span>, <span class="string">&quot;#&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ul><li><p>匹配正确的数字</p><p>匹配规则：</p><p>  匹配正整数：”\d+”</p><p>  匹配正小数：”\d+\.\d+” </p><p>  匹配负整数：”-\d+”</p><p>  匹配负小数：”-\d+\.\d+”</p><p>  匹配保留两位小数的正数：”\d+\.\d{2}”</p><p>  匹配保留1-3位小数的正数：”\d+\.\d{1,3}”</p></li><li><p>匹配合法的邮箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  检查邮件地址是否合法</span></span><br><span class="line"><span class="comment"> *  规则:</span></span><br><span class="line"><span class="comment"> *   1234567@qq.com</span></span><br><span class="line"><span class="comment"> *   mym_ail@sina.com</span></span><br><span class="line"><span class="comment"> *   nimail@163.com</span></span><br><span class="line"><span class="comment"> *   wodemail@yahoo.com.cn    </span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *   @: 前  数字字母_ 个数不能少于1个</span></span><br><span class="line"><span class="comment"> *   @: 后  数字字母     个数不能少于1个</span></span><br><span class="line"><span class="comment"> *   .: 后面 字母 </span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">String email =<span class="string">&quot;abc123@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = email.matches(<span class="string">&quot;[a-zA-Z0-9_]+@[0-9a-z]+(\\.[a-z]+)+&quot;</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串缓冲区</title>
      <link href="posts/b25195bc.html"/>
      <url>posts/b25195bc.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h1><p>在学习String类时，API中说<font color=red>字符串缓冲区支持可变的字符串</font>，什么是字符串缓冲区呢？接下来我们来研究下字符串缓冲区。</p><p>查阅StringBuffer的API，StringBuffer又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuffer是个字符串的缓冲区，即就是它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><hr><p>说白了，string类一旦创建不可改变，容易照成资源浪费，所以就开发了StringBuffer类，用于解决这个问题</p><p>Stringbuffer字符串的缓存区对象，用于提高字符串的操作对象，内部采用了可变数组的实现，类内部定义了数组，这个数组没有final</p><p>这里再举个例子，如果我们需要连接两个字符串，<code>“123”+“adf”</code></p><p>用string类的话，在内存中，“123”是一个数组，“adf”又是一个数组，两个一连接又是一个新的数组，这时候在内存中就会有三个数组</p><p>如果用stringbuffer类呢，在内存中始终只有一个数组，如果一个数组装满了，它会自动扩容，这个类的数组查看源码可以知道，默认容量是16</p><h1 id="StringBuffer的方法使用"><a href="#StringBuffer的方法使用" class="headerlink" title="StringBuffer的方法使用"></a>StringBuffer的方法使用</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110224839.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类的方法</span></span><br><span class="line"><span class="comment"> *   String toString() 继承Object,重写toString()</span></span><br><span class="line"><span class="comment"> *   将缓冲区中的所有字符,变成字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_5</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">buffer.append(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将可变的字符串缓冲区对象,变成了不可变String对象</span></span><br><span class="line">String s = buffer.toString();</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类的方法</span></span><br><span class="line"><span class="comment"> *    reverse() 将缓冲区中的字符反转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_4</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"></span><br><span class="line">buffer.reverse();</span><br><span class="line"></span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类方法</span></span><br><span class="line"><span class="comment"> *    replace(int start,int end, String str)</span></span><br><span class="line"><span class="comment"> *    将指定的索引范围内的所有字符,替换成新的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"></span><br><span class="line">buffer.replace(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类方法 insert</span></span><br><span class="line"><span class="comment"> *    insert(int index, 任意类型)</span></span><br><span class="line"><span class="comment"> *  将任意类型数据,插入到缓冲区的指定索引上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line"> StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"> buffer.append(<span class="string">&quot;abcdef&quot;</span>); </span><br><span class="line"> </span><br><span class="line"> buffer.insert(<span class="number">3</span>, <span class="number">9.5</span>);</span><br><span class="line"> System.out.println(buffer);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * StringBuffer类方法</span></span><br><span class="line"><span class="comment"> *   delete(int start,int end) 删除缓冲区中字符</span></span><br><span class="line"><span class="comment"> *   开始索引包含,结尾索引不包含</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"></span><br><span class="line">buffer.delete(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类方法</span></span><br><span class="line"><span class="comment"> *   StringBuffer append, 将任意类型的数据,添加缓冲区</span></span><br><span class="line"><span class="comment"> *   append 返回值,写return this</span></span><br><span class="line"><span class="comment"> *   调用者是谁,返回值就是谁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">//调用StringBuffer方法append向缓冲区追加内容</span></span><br><span class="line">buffer.append(<span class="number">6</span>).append(<span class="keyword">false</span>).append(<span class="string">&#x27;a&#x27;</span>).append(<span class="number">1.5</span>);</span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：append、delete、insert、replace、reverse方法调用后，返回值都是当前对象自己，所以说，StringBuffer它可以改变字符序列的长度和内容。</p><h1 id="对象的方法链式调用"><a href="#对象的方法链式调用" class="headerlink" title="对象的方法链式调用"></a>对象的方法链式调用</h1><p>在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。这种时候，我们就可以把代码现在一起，如append方法一样，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个字符串缓冲区对象。用于存储数据。</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">//添加数据。不断的添加数据后，要对缓冲区的最后的数据进行操作，必须转成字符串才可以。</span></span><br><span class="line">String str = sb.append(<span class="keyword">true</span>).append(<span class="string">&quot;hehe&quot;</span>).toString();</span><br></pre></td></tr></table></figure><h1 id="StringBuffer练习"><a href="#StringBuffer练习" class="headerlink" title="StringBuffer练习"></a>StringBuffer练习</h1><p>int[] arr = {34,12,89,68};将一个int[]中元素转成字符串 格式 [34,12,89,68]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* int[] arr = &#123;34,12,89,68&#125;;将一个int[]中元素转成字符串 </span></span><br><span class="line"><span class="comment">* 格式 [34,12,89,68]</span></span><br><span class="line"><span class="comment">* 以前的思路是用string</span></span><br><span class="line"><span class="comment">* String s = &quot;[&quot;</span></span><br><span class="line"><span class="comment">* 数组遍历</span></span><br><span class="line"><span class="comment">*   s+= arr[i];</span></span><br><span class="line"><span class="comment">*  s+&quot;]&quot;</span></span><br><span class="line"><span class="comment">*  现在用StringBuffer实现,可以节约内存空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建字符串缓冲区</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"><span class="comment">//数组遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++)&#123;</span><br><span class="line"><span class="comment">//判断是不是数组的最后一个元素</span></span><br><span class="line"><span class="keyword">if</span>(i == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">buffer.append(arr[i]).append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">buffer.append(arr[i]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无论多少数据，数据是什么类型都不重要，只要最终变成字符串就可以使用StringBuffer这个容器</p><h1 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h1><p>查阅API发现还有一个StringBuilder类，它也是字符串缓冲区，StringBuilder与它和StringBuffer的有什么不同呢？</p><p>我们阅读StringBuilder的API说明发现，它也是一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。</p><blockquote><p>两个类的方法完全一样，就是一个安全一个不安全的区别，stringbuffer线程安全，stringbuilder线程不安全，不同步就是不安全，安全意味着是速度慢</p></blockquote><p>目前，我们还没有涉及到线程与同步，知道结论StringBuilder比StringBuffer快即可。为什么快，我们会在学习线程时讲解。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> String </tag>
            
            <tag> StringBuffer </tag>
            
            <tag> StringBuilder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类</title>
      <link href="posts/5cf35ca9.html"/>
      <url>posts/5cf35ca9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>查阅API中的String类的描述，发现String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示字符串</span></span><br><span class="line">String str  = <span class="string">&quot;shuigwh&quot;</span>;</span><br><span class="line">str = <span class="string">&quot;水过无痕&quot;</span>;</span><br></pre></td></tr></table></figure><p>继续查阅API发现说字符串是常量；它们的值在创建之后不能更改</p><p>说明<font color=red>字符串是一个常量，一旦创建，不能改变</font>&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str = <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109133116.png"></p><p>既然不能改变，这又是怎么回事？</p><p>分析：</p><p>字符串本身是一个对象，运行的时候，方法进栈，对象在堆内存</p><p>这里说一下，字符串的本质，是一个字符的数组 “itcast” = char[] = {‘i’, ‘t’, ‘c’, ‘a’, ‘s’, ‘t’}</p><p>我们查看String类的源码，会发现有一行<code>private final char value[];</code>这也说明字符串就是个数组,final也说明一旦数组建立，此对象终身不变</p><p>最开始，main方法压栈运行，</p><p>这里说下堆内存其实有个小区域是存放常量的，这个区域叫常量池，他是专门用来存放常量的，常量池里面有多少个常量呢？这个不能具体回答，因为常量可以有无限个，但是字符串常量，在常量池中的是以字符型体现的，因为字符是有个数的，一共52个（大小写加起来）</p><p>当要建立<code>itcast</code>的时候，我们可以从常量池中拿字符来用，当<code>itcast</code>创建后，在堆内存中就会出现一块叫’itcast’的对象，而且 是被final的，不能被，引用数据类型变量str指向这块空间，见下图</p><p>当程序继续往下执行的时候，<code>str = &quot;itheima&quot;;</code>他不是改原来对象的数据，他是在堆内存中重新再次创建一个数组，叫”itheima”,然后引用变量str指向这块区域</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109232213.png"></p><p>所以，最开始的程序运行结果，最后的str输出的是“itheima”，<font color=red>不是对象变了，而是变量的指向的地址变了</font></p><hr><p>继续查API发现，字符串有大量的重载的构造方法。通过String类的构造方法可以完成字符串对象的创建,那么，通过使用双引号的方式创建对象与new的方式创建对象，有什么不同呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1);</span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//引用数据类型，比较对象的地址 false</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>程序开始执行，运行<code>String str1 = new String(&quot;abc&quot;);</code>这句话，其实是同时创建了两个对象，当new 的时候，堆内存会创建一个叫String类的对象，<code>abc</code>这个之前也说过，他也是对象，本质是char类型的数组，虚拟机会另外开辟一块空间存放<code>abc</code>的char数组,String类的对象其实保存的是char数组的地址，然后str1指向String类的地址，见下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109233909.png"></p><p>程序继续往下运行，<code>String str2 = &quot;abc&quot;;</code>按照之前学的内容，虚拟机肯定会在开辟一个空间，用于存放这个char数组，</p><p>但是不是，虚拟机在运行的时候会做一个优化，检查内存中有没有”abc”,如果有，就直接指向这个区域</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109234334.png"></p><p>所以str1==str2,比较的是地址，地址不一样，所以是false</p><p>至于str1.equals(str2)为什么是false，原因很简单，是因为String类继承了object类，重写了equals方法，建立了字符串自己的比较方式，比较字符串中的每个字符是否相同</p><h1 id="String类构造方法"><a href="#String类构造方法" class="headerlink" title="String类构造方法"></a>String类构造方法</h1><p>构造方法是用来完成String对象的创建，下图中给出了一部分构造方法需要在API中找到，并能够使用下列构造方法创建对象。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109234759.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(); <span class="comment">//创建String对象，字符串中没有内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(bys); <span class="comment">// 创建String对象，把数组元素作为字符串的内容  s2==&quot;abcd&quot;</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(bys, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">//创建String对象，把一部分数组元素作为字符串的内容，参数offset为数组元素的起始索引位置，参数length为要几个元素   s2==&quot;bcd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;’a’,’b’,’c’,’d’,’e’&#125;;</span><br><span class="line">String s4 = <span class="keyword">new</span> String(chs); <span class="comment">//创建String对象，把数组元素作为字符串的内容  s4==&quot;abcde&quot;</span></span><br><span class="line">String s5 = <span class="keyword">new</span> String(chs, <span class="number">0</span>, <span class="number">3</span>);<span class="comment">//创建String对象，把一部分数组元素作为字符串的内容，参数offset为数组元素的起始索引位置，参数count为要几个元素s5==&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">String s6 = <span class="keyword">new</span> String(“abc”); <span class="comment">//创建String对象，字符串内容为abc</span></span><br></pre></td></tr></table></figure><h1 id="String类的方法查找"><a href="#String类的方法查找" class="headerlink" title="String类的方法查找"></a>String类的方法查找</h1><p>String类中有很多的常用的方法，我们在学习一个类的时候，不要盲目的把所有的方法尝试去使用一遍，这时我们应该根据这个对象的特点分析这个对象应该具备那些功能，这样大家应用起来更方便。</p><p>字符串是一个对象，那么它的方法必然是围绕操作这个对象的数据而定义的。我们想想字符串中有哪些功能呢？</p><ul><li><p>字符串中有多少个字符?</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110130655.png"></p></li><li><p>获取部分字符串。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110130716.png"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String s1 = str.substring(<span class="number">1</span>); <span class="comment">//&quot;bcde&quot; 返回一个新字符串，内容为指定位置开始到字符串末尾的所有字符</span></span><br><span class="line">String s2 = str.substring(<span class="number">2</span>, <span class="number">4</span>);<span class="comment">//&quot;cd&quot; 返回一个新字符串，内容为指定位置开始到指定位置结束所有字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;str=&quot;</span>+str);</span><br><span class="line">System.out.println(<span class="string">&quot;s1=&quot;</span>+s1);</span><br><span class="line">System.out.println(<span class="string">&quot;s2=&quot;</span>+s2);</span><br></pre></td></tr></table></figure></li></ul><h1 id="String类中方法查找练习"><a href="#String类中方法查找练习" class="headerlink" title="String类中方法查找练习"></a>String类中方法查找练习</h1><p>前面给大家简单介绍了几个字符串中常用的方法，这个过程中主要让大家学会如何去查阅API，如何找到自己想用的方法。接下来我们来练习下字符串方法的查找。</p><ul><li><p>字符串是否以指定字符串开头。结尾同理。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110131814.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;StringDemo.java&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = str.startsWith(<span class="string">&quot;Demo&quot;</span>);<span class="comment">//false 判断是否以给定字符串开头</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = str.startsWith(<span class="string">&quot;String&quot;</span>);<span class="comment">//true </span></span><br><span class="line"><span class="keyword">boolean</span> b3 = str.endsWith(<span class="string">&quot;java&quot;</span>);<span class="comment">//true 判断是否以给定字符串结尾</span></span><br></pre></td></tr></table></figure></li><li><p>字符串中是否包含另一个字符串。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110132003.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> index = str.indexOf(“bcd”); <span class="comment">//判断是否包含指定字符串，包含则返回第一次出现该字符串的索引，不包含则返回-1</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = str.contains(<span class="string">&quot;bcd&quot;</span>);<span class="comment">//判断是否包含指定字符串，包含返回true，不包含返回false</span></span><br></pre></td></tr></table></figure></li><li><p>将字符串转成一个字符数组。或者字节数组。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110132206.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes();</span><br></pre></td></tr></table></figure></li><li><p>判断两个字符串中的内容是否相同</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110132402.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = str.equals(str2);</span><br><span class="line"><span class="keyword">boolean</span> b2 = str.equals(str3);</span><br></pre></td></tr></table></figure></li><li><p>获取该字符串对象中的内容</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110132452.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println( str.toString() );</span><br><span class="line">System.out.pintln( str );</span><br></pre></td></tr></table></figure><p>直接打印引用类型变量时，默认调用该类型进行重写后的toString方法</p></li></ul><h1 id="String类方法使用练习"><a href="#String类方法使用练习" class="headerlink" title="String类方法使用练习"></a>String类方法使用练习</h1><ol><li><p>题目一：</p><p>获取指定字符串中，大写字母、小写字母、数字的个数。</p><p>思路：</p><ul><li><p>为了统计大写字母、小写字母、数字的个数。创建3个计数的变量。</p></li><li><p>为了获取到字符串中的每个字符，进行字符串的遍历，得到每个字符。</p></li><li><p>对得到的字符进行判断，如果该字符为大写字母，则大写字母个数+1；如果该字符为小写字母，则小写字母个数+1；如果该字符为数字，则数字个数+1。</p></li><li><p>显示大写字母、小写字母、数字的个数</p></li></ul><p>分析：</p><ul><li>计数器,就是int变量,满足一个条件 ++</li><li>遍历字符串, 长度方法length() + charAt() 遍历</li><li>字符判断是大写,是小写,还是数字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">getCount(<span class="string">&quot;A%A3eBr1FFy&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCount</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义三个变量,计数</span></span><br><span class="line">    <span class="keyword">int</span> upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lower = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对字符串遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length() ; i++)&#123;</span><br><span class="line">        <span class="comment">//String方法charAt,索引,获取字符</span></span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        <span class="comment">//利用编码表 65-90  97-122  48-57</span></span><br><span class="line">        <span class="keyword">if</span>(c &gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;=<span class="number">90</span>)&#123;</span><br><span class="line">            upper++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c &gt;= <span class="number">97</span> &amp;&amp; c &lt;= <span class="number">122</span>)&#123;</span><br><span class="line">            lower++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c &gt;= <span class="number">48</span> &amp;&amp; c &lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            digit++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(upper);</span><br><span class="line">    System.out.println(lower);</span><br><span class="line">    System.out.println(digit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>题目二：</p><p>将字符串中，第一个字母转换成大写，其他字母转换成小写，并打印改变后的字符串。</p><p>思路：</p><ul><li>把字符串分为两个部分，第一部分为字符串中第一个字母，第二部分为剩下的字符串。</li><li>把第一部分字符串转换成大写字母，把第二部分字符串转换成小写字母</li><li>把两部分字符串连接在一起，得到一个完整的字符串</li></ul><p>分析：</p><ul><li>获取首字母, charAt(0)  substring(0,1)</li><li>转成大写 toUpperCase()</li><li>获取剩余字符串, substring(1)  toLowerCase()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toConvert</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义变量,保存首字母,和剩余字符</span></span><br><span class="line">    String first = str.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    String after = str.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//调用String类方法,大写,小写转换</span></span><br><span class="line">    first = first.toUpperCase();</span><br><span class="line">    after = after.toLowerCase();</span><br><span class="line">    <span class="keyword">return</span> first+after;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>题目三：</p><p>查询大字符串中，出现指定小字符串的次数。如“hellojava,nihaojava,javazhenbang”中查询出现“java”的次数。</p><p>思路：</p><ul><li><p>在大串中，查找小串出现的位置，出现了就次数+1</p></li><li><p>在上次小串出现位置的后面继续查找，需要更改大串的内容为上次未查询到的字符串。</p></li><li><p>回到第一步，继续查找小串出现的位置，直到大串中查询不到小串为止</p></li></ul><p>图示解析：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110223759.png"></p><p>分析：</p><ul><li>indexOf到字符串中到第一次出现的索引</li><li>找到的索引+被找字符串长度,截取字符串</li><li>计数器++</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStringCount</span><span class="params">(String str, String key)</span></span>&#123;</span><br><span class="line"><span class="comment">//定义计数器</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义变量,保存indexOf查找后的索引的结果</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//开始循环找,条件,indexOf==-1 字符串没有了</span></span><br><span class="line"><span class="keyword">while</span>(( index = str.indexOf(key) )!= -<span class="number">1</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="comment">//获取到的索引,和字符串长度求和,截取字符串</span></span><br><span class="line">str = str.substring(index+key.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>object类</title>
      <link href="posts/b7ed79d1.html"/>
      <url>posts/b7ed79d1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。所有类在创建对象的时候，最终找的父类就是Object。</p><p>在Object类众多方法中，我们先学习equals方法与toString方法，其他方法后面课程中会陆续学到。</p><h1 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@1.1/img/20201108230141.png"></p><p>这个equals是什么意思呢？</p><p>分析：</p><p>建立一个Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将父类的equals方法写过来,重写父类的方法</span></span><br><span class="line"><span class="comment"> * 但是,不改变父类方法的源代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">this</span> == obj)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEquals</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Person类继承Object类,继承下来了父类的方法equals</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment">//Person对象p1,调用父类的方法equals,进行对象的比较</span></span><br><span class="line"><span class="keyword">boolean</span> b = p1.equals(p1); </span><br><span class="line">System.out.println(b);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201108234533.png"></p><p><font color=red>equals方法，用于比较两个对象是否相同</font>，它其实就是使用两个对象的内存地址在比较。Object类中的equals方法内部使用的就是==比较运算符。</p><p>在开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较，也就是在开发经常需要子类重写equals方法根据对象的属性值进行比较。比如还是这个例子，我们如果要比较两个人的年龄，我们可以这样写</p><p>在Person类中重写equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">name/age  ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将父类的equals方法写过来,重写父类的方法</span></span><br><span class="line"><span class="comment"> * 但是,不改变父类方法的源代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        Person p = (Person)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age == p.age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">get/set ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样重写之后，再在测试类用equals比较，如果两个人年龄一样，返回ture,如果不同返回false，但是这样有个弊端，如果我们在测试类这样写的不是人，就比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//boolean b = p1.equals(p1); </span></span><br><span class="line"><span class="keyword">boolean</span> b = p1.equals(array);  <span class="comment">//p1与array比较</span></span><br><span class="line">System.out.println(b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>此时运行就会出现ClassCastException异常，一般向下转型的时候要判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person p = (Person)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age == p.age</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是不是就可以了？其实还有一种可能性，如果传了一个null，即p1和null比，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = p1.equals(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>所以代码还需要添加对null的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person p = (Person)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age == p.age</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还有一种情况，如果自己和自己比较，也就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = p1.equals(p1);</span><br></pre></td></tr></table></figure><p>那么在equals重写的时候还需要这样处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person p = (Person)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age == p.age</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实this == obj和对null的比较不写也可以的，后面instanceof比较可以判断的，但是写上却可以提升程序的执行效率</p><blockquote><p>总结：</p><p>在重写Object中的equals方法时，一定要注意public boolean equals(Object obj)的参数是Object类型，在调用对象的属性时，一定要进行类型转换，在转换之前必须进行类型判断。</p></blockquote><h1 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109130424.png"></p><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109131121.png"></p><p>可以观察到，两个结果是一样的</p><p>输出语句中，写的是一个对象，默认调用对象的toString方法</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age ;</span><br><span class="line"><span class="comment">//根据Person类的属性重写toString方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person [age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode默认终端修改为gitbash</title>
      <link href="posts/7d72a066.html"/>
      <url>posts/7d72a066.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>点开设置</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201106122527.png"></p></li><li><p>搜索<code>terminal.integrated.shell.windows</code></p><p> <img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201106122657.png"><br> 修改这里的配置文件</p></li><li><p>在这里添加路径</p><p> <img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201106122817.png"></p><blockquote><p>这里注意：要修改成为bin下面的bash.exe文件<br>直接复制路径可能会不存在，我不知道为什么，我这里用的everything复制的完整路径才可以，注意，原来的路径的<code>\</code>要改成<code>\\</code></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实用小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="posts/23a3bd72.html"/>
      <url>posts/23a3bd72.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>什么是异常？Java代码在运行时期发生的问题就是异常。</p><p>在Java中，把异常信息封装成了一个类。当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常的根类是Throwable，其下有两个子类：Error与Exception，平常所说的异常指Exception。</p><h2 id="异常的继承体系"><a href="#异常的继承体系" class="headerlink" title="异常的继承体系"></a>异常的继承体系</h2><p>在Java中使用Exception类来描述异常。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103233939.png"></p><p>查看API中Exception的描述，Exception 类及其子类是 Throwable 的一种形式，它用来表示java程序中可能会产生的异常，并要求对产生的异常进行合理的异常处理。</p><p>继续观察，我们可以发现Exception有继承关系，它的父类是Throwable。Throwable是Java 语言中所有错误或异常的超类，即祖宗类。</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103234138.png" style="zoom:80%;" /><p>另外，在异常Exception类中，有一个子类要特殊说明一下，RuntimeException子类，RuntimeException及其它的子类只能在Java程序运行过程中出现。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103234257.png"></p><p>我们再来观察Throwable类，能够发现与异常Exception平级的有一个Error，它是Throwable的子类，它用来表示java程序中可能会产生的严重错误。解决办法只有一个，修改代码避免Error错误的产生。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103234358.png"></p><p><strong>异常继承体系总结：</strong></p><blockquote><p>Throwable: 它是所有错误与异常的超类（祖宗类）</p><blockquote><p>Error 错误</p><p>Exception 编译期异常,进行编译JAVA程序时出现的问题</p><blockquote><p>RuntimeException 运行期异常, JAVA程序运行过程中出现的问题</p></blockquote></blockquote></blockquote><h2 id="异常与错误的区别"><a href="#异常与错误的区别" class="headerlink" title="异常与错误的区别"></a>异常与错误的区别</h2><p><strong>异常</strong>：指程序在编译、运行期间发生了某种异常(XxxException)，我们可以对异常进行具体的处理。若不处理异常，程序将会结束运行。</p><ul><li><p>异常的产生演示如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);<span class="comment">//该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException，由于没有处理异常，导致程序无法继续执行，程序结束。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;over&quot;</span>); <span class="comment">// 由于上面代码发生了异常，此句代码不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>错误</strong>：指程序在运行期间发生了某种错误(XxxError)，Error错误通常没有具体的处理方式，程序将会结束运行。Error错误的发生往往都是系统级别的问题，都是jvm所在系统发生的，并反馈给jvm的。我们无法针对处理，只能修正代码。</p><ul><li><p>错误的产生演示如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">100</span>];<span class="comment">//该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间，导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常的产生过程解析"><a href="#异常的产生过程解析" class="headerlink" title="异常的产生过程解析"></a>异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对给定的数组通过给定的角标获取元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> element = arr[index];</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> num = ArrayTools.getElement(arr,<span class="number">4</span>)</span><br><span class="line">System.out.println(<span class="string">&quot;num=&quot;</span>+num);</span><br><span class="line">System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台会显示</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201104000508.png"></p><p>分析：</p><p>程序正常运行到<code>        int num = ArrayTools.getElement(arr,4)</code>这里，由于没有找到4索引，导致运行发生了异常。java虚拟机能够检测到出现数组的越界问题，</p><p>随后，JVM会做两件事，</p><p>第一件事情：创建了异常的对象，new ArrayIndexOutOfBoundsException(4)</p><p>第二件事情：将异常的对象进行抛出，扔出去理论，抛给方法的调用者</p><p>main接收到了这个异常，main也没有对数组越界异常进行处理，将异常对象继续抛出，抛给main的调用者（JVM）</p><p>当JVM收到异常后做了两件事，</p><p>第一件事：将异常信息以红色字体输出控制台</p><p>第二件事：将程序停止，结束</p><p><strong>注意：一旦异常背抛出了，后面的所有程序，都不再执行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201104001614.png"></p><h2 id="抛出异常关键字throw"><a href="#抛出异常关键字throw" class="headerlink" title="抛出异常关键字throw"></a>抛出异常关键字throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象；</p></li></ol><p>throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p><p><em><font color=red>throw ,在方法内部，抛出异常对象，必须是exception，throw 后面必须写new 对象，必须是异常的对象或者是子类</font></em></p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);</span><br></pre></td></tr></table></figure><hr><p>下面是异常类ArrayIndexOutOfBoundsException与NullPointerException的构造方法</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201104114038.png"></p><p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p><p>编写工具类，提供获取数组指定索引处的元素值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过给定的数组，返回给定的索引对应的元素值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 若程序出了异常，JVM它会打包异常对象并抛出。但是它所提供的信息不够给力。想要更清晰，需要自己抛出异常信息。</span></span><br><span class="line"><span class="comment">         * 下面判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;arr指向的数组不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;错误的角标，&quot;</span> + index + <span class="string">&quot;索引在数组中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;; <span class="comment">//创建数组</span></span><br><span class="line"><span class="keyword">int</span> num = ArrayTools.getElement(<span class="keyword">null</span>,<span class="number">2</span>);<span class="comment">// 调用方法，获取数组中指定索引处元素</span></span><br><span class="line"><span class="comment">//int num = ArrayTools.getElement(arr,5);// 调用方法，获取数组中指定索引处元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;num=&quot;</span>+num);<span class="comment">//打印获取到的元素值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="声明异常关键字throws"><a href="#声明异常关键字throws" class="headerlink" title="声明异常关键字throws"></a>声明异常关键字throws</h2><p>声明：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>声明异常格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>… &#123;   &#125;</span><br></pre></td></tr></table></figure><p>声明异常的代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;show run&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p><p>多个异常的情况，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> NullPointerException, ArrayIndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;arr指向的数组不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;错误的角标，&quot;</span> + index + <span class="string">&quot;索引在数组中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="捕获异常try…catch…finally"><a href="#捕获异常try…catch…finally" class="headerlink" title="捕获异常try…catch…finally"></a>捕获异常try…catch…finally</h2><p>捕获：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理</p><p>捕获异常格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//需要被检测的语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类 变量) &#123; <span class="comment">//参数。</span></span><br><span class="line"><span class="comment">//异常的处理语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//一定会被执行的语句。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//throws ArrayIndexOutOfBoundsException</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">                System.out.println(arr[<span class="number">5</span>]);<span class="comment">// 会抛出ArrayIndexOutOfBoundsException</span></span><br><span class="line">                <span class="comment">//当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123; <span class="comment">//括号中需要定义什么呢？try中抛出的是什么异常，在括号中就定义什么异常类型。</span></span><br><span class="line">                System.out.println(<span class="string">&quot;异常发生了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                arr = <span class="keyword">null</span>; <span class="comment">//把数组指向null，通过垃圾回收器，进行内存垃圾的清除</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行结果&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="try…catch…finally异常处理的组合方式"><a href="#try…catch…finally异常处理的组合方式" class="headerlink" title="try…catch…finally异常处理的组合方式"></a>try…catch…finally异常处理的组合方式</h2><p><strong>try catch finally组合：</strong>检测异常，并传递给catch处理，并在finally中进行资源释放。</p><p><strong>try catch组合</strong> : 对代码进行异常检测，并对检测的异常传递给catch处理。对异常进行捕获处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//不用throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//产生异常，直接捕获处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个try 多个catch组合</strong> : 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//不用throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//产生异常，直接捕获处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XxxException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(YyyException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ZzzException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，<strong>并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理</strong>,如果是平级异常，也就是抛出的异常类之间，没有继承关系，那就没有顺序，上下随便写。</p><p><strong>try finally 组合</strong>: 对代码进行异常检测，检测到异常后因为没有catch，所以一样会被默认jvm抛出。异常是没有捕获处理的。但是功能所开启资源需要进行关闭，所有finally。只为关闭资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//需要throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行时期异常"><a href="#运行时期异常" class="headerlink" title="运行时期异常"></a>运行时期异常</h2><p>异常其实分为编译异常和运行时期异常</p><p>编译异常：调用了抛出异常的方法，不处理编译失败（try/throws）</p><p>运行异常：抛出的异常是RuntimeException类，或者是他的子类</p><hr><p>RuntimeException和他的所有子类异常,都属于运行时期异常。NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常.</p><p>运行异常的特点: 方法中抛出运行时期异常,方法定义中<strong>无需throws声明</strong>,调用者也无需处理此异常</p><p>设计原因：运行异常，不能发生，但是如果发生了，请修改源代码，因为运行代码一旦发生，后面的代码没有执行的意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常在方法重写中细节"><a href="#异常在方法重写中细节" class="headerlink" title="异常在方法重写中细节"></a>异常在方法重写中细节</h2><ol><li><p>子类覆盖父类方法时，如果父类的方法声明异常，<strong>子类只能声明父类异常或者该异常的子类，或者不声明。</strong>（声明不声明都可以）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123; &#125;  <span class="comment">//抛出父类一样的异常</span></span><br><span class="line">        <span class="comment">//public void method() throws NullPointerException&#123; &#125; //抛出父类子异常</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>当父类方法声明多个异常时，子类覆盖时只能声明多个异常的子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span><span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123; &#125;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException</span>&#123; &#125; <span class="comment">//抛出父类异常中的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> ClassCastException </span>&#123; &#125; <span class="comment">//抛出父类异常中的一部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当被覆盖的方法没有异常声明时，子类覆盖时无法声明异常的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; &#125;<span class="comment">//错误的方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：父类中会存在下列这种情况，接口也有这种情况</p><p>问题：接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？</p><p>答：无法进行throws声明，只能catch的捕获。万一问题处理不了呢？catch中继续throw抛出，但是只能将异常转换成RuntimeException子类抛出。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="comment">//无法声明 throws Exception</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//只能捕获处理</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;哥们，你定义的数组arr是空的!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;父方法中没有异常抛出，子类中不能抛出Exception异常&quot;</span>);</span><br><span class="line">                <span class="comment">//我们把异常对象e，采用RuntimeException异常方式抛出</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="异常中常用方法"><a href="#异常中常用方法" class="headerlink" title="异常中常用方法"></a>异常中常用方法</h2><p>在Throwable类中为我们提供了很多操作异常对象的方法，常用的如下：</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201104132631.png"></p><ul><li><p>getMessage方法：返回该异常的详细信息字符串，即异常提示信息</p></li><li><p>toString方法：返回该异常的名称与详细信息字符串</p></li><li><p>printStackTrace：在控制台输出该异常的名称与详细信息字符串、异常出现的代码位置，JVM默认调用方法也是这个方法</p><p>异常的常用方法代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Person p= <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (p==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(“出现空指针异常了，请检查对象是否为<span class="keyword">null</span>”);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">String message = e.getMesage();</span><br><span class="line">System.out.println(message ); </span><br><span class="line"></span><br><span class="line">String result = e.toString();</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>在上述代码中，发现这些异常都是JDK内部定义好的，并且这些异常不好找。书写时也很不方便，那么能不能自己定义异常呢？</p><p>之前的几个异常都是java通过类进行的描述。并将问题封装成对象，异常就是将问题封装成了对象。这些异常不好认，书写也很不方便，能不能定义一个符合我的程序要求的异常名称。既然JDK中是使用类在描述异常信息，那么我们也可以模拟Java的这种机制，我们自己定义异常的信息，异常的名字，让异常更符合自己程序的阅读。准确对自己所需要的异常进行类的描述。</p><h2 id="自定义异常类的定义"><a href="#自定义异常类的定义" class="headerlink" title="自定义异常类的定义"></a>自定义异常类的定义</h2><p>通过阅读异常源代码：发现java中所有的异常类，都是继承Throwable，或者继承Throwable的子类。这样该异常才可以被throw抛出。</p><p>说明这个异常体系具备一个特有的特性：可抛性：即可以被throw关键字操作。</p><p>并且查阅异常子类源码，发现每个异常中都调用了父类的构造方法，把异常描述信息传递给了父类，让父类帮我们进行异常信息的封装。</p><p>例如NullPointerException异常类源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullPointerException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullPointerException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//调用父类构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullPointerException</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);<span class="comment">//调用父类具有异常信息的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们来定义个自己的异常，即自定义异常。</p><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class 异常名 extends Exception&#123; <span class="comment">//或继承RuntimeException</span></span><br><span class="line"><span class="keyword">public</span> 异常名()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> 异常名(String s)&#123; </span><br><span class="line"><span class="keyword">super</span>(s); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>自定义异常继承Exception演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(message);<span class="comment">// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义异常继承RuntimeException演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MyException()&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line">MyException(String message)&#123;</span><br><span class="line"><span class="keyword">super</span>(message);<span class="comment">// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="自定义异常的练习"><a href="#自定义异常的练习" class="headerlink" title="自定义异常的练习"></a>自定义异常的练习</h2><p>定义Person类，包含name与age两个成员变量。</p><p>在Person类的有参数构造方法中，进行年龄范围的判断，若年龄为负数或大于200岁，则抛出NoAgeException异常，异常提示信息“年龄数值非法”。</p><p>要求：在测试类中，调用有参数构造方法，完成Person对象创建，并进行异常的处理。</p><p>自定义异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoAgeException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">NoAgeException() &#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NoAgeException(String message)&#123;</span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">Person(String name,<span class="keyword">int</span> age) <span class="keyword">throws</span> NoAgeException&#123;</span><br><span class="line"><span class="comment">//加入逻辑判断。</span></span><br><span class="line"><span class="keyword">if</span>(age&lt;<span class="number">0</span> || age&gt;<span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoAgeException(age+<span class="string">&quot;,年龄数值非法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Person对象对应的字符串表现形式。覆盖Object中的toString方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person[name=&quot;</span>+name+<span class="string">&quot;,age=&quot;</span>+age+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">20</span>);</span><br><span class="line">System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoAgeException ex)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;年龄异常啦&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，构造函数到底抛出这个NoAgeException是继承Exception呢？还是继承RuntimeException呢？</p><ul><li>继承Exception，必须要throws声明，一声明就告知调用者进行捕获，一旦问题处理了调用者的程序会继续执行。</li><li>继承RuntimeExcpetion,不需要throws声明的，这时调用是不需要编写捕获代码的，因为调用根本就不知道有问题。一旦发生NoAgeException，调用者程序会停掉，并有jvm将信息显示到屏幕，让调用者看到问题，修正代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码块</title>
      <link href="posts/57224242.html"/>
      <url>posts/57224242.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h1><p>局部代码块是定义在方法或语句中</p><p>特点：</p><ul><li>以”{}”划定的代码区域，此时只需要关注作用域的不同即可</li><li>方法和类都是以代码块的方式划定边界的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">         <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块&quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">99</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;代码块之外&quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>​        普通代码块1</p><p>​        代码块之外99</p><h1 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h1><p>构造代码块是定义在类中成员位置的代码块</p><p>特点：</p><ul><li><code>优先于构造方法</code>执行，构造代码块用于执行所有对象均需要的初始化动作</li><li><code>每创建一个对象均会执行一次构造代码块</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//构造代码块</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造代码块执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Person无参数的构造函数执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">System.out.println(<span class="string">&quot;Person（age）参数的构造函数执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>构造代码块执行了</p><p>Person无参数的构造函数执行</p><p>Person（age）参数的构造函数执行”</p><blockquote><p>构造代码块是优先于构造方法，所以就算构造代码块放在后面，他也先执行构造代码块的方法，和顺序没有关系</p></blockquote><h1 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h1><p>静态代码块是定义在成员位置，使用static修饰的代码块。</p><p>特点：</p><ul><li>它<code>优先于主方法执行</code>、<code>优先于构造代码块执行</code>，当以任意形式第一次使用到该类时执行。</li><li>该类不管创建多少对象，静态代码块<code>只执行一次</code>。</li><li>可用于给静态变量赋值，用来给类进行初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">     <span class="comment">//静态代码块</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四大访问权限修饰符</title>
      <link href="posts/f941d9b7.html"/>
      <url>posts/f941d9b7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限，以下表来说明不同权限的访问能力：</p><table><thead><tr><th align="left"></th><th align="center">public</th><th align="center">protected</th><th align="center">default</th><th align="center">private</th></tr></thead><tbody><tr><td align="left">同一类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">同一包中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="left">不同包的子类</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">不同包中的无关类</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>​     归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问</p><ul><li>要想仅能在本类中访问使用private修饰；</li><li>要想本包中的类都可以访问不加修饰符即可；</li><li>要想本包中的类与其他包中的子类可以访问使用protected修饰</li><li>要想所有包中的所有类都可以访问使用public修饰。</li><li>注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名对象与内部类</title>
      <link href="posts/307f30e5.html"/>
      <url>posts/307f30e5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个普通对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();<span class="comment">//这种对象可以反复使用</span></span><br></pre></td></tr></table></figure><p>创建一个匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person();<span class="comment">//这种对象只能使用一次</span></span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><p>创建匿名对象直接使用，没有变量名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person().eat()  <span class="comment">//eat方法被一个没有名字的Person对象调用了。</span></span><br></pre></td></tr></table></figure></li><li><p>匿名对象在没有指定其引用变量时，只能使用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person().eat(); 创建一个匿名对象，调用eat方法</span><br><span class="line"><span class="keyword">new</span> Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象</span><br></pre></td></tr></table></figure></li><li><p>匿名对象可以作为方法接收的参数、方法返回值使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//普通方式</span></span><br><span class="line"><span class="comment">//Person p = new Person();</span></span><br><span class="line"><span class="comment">//return p;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象作为方法返回值</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person p)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用getPerson方法，得到一个Person对象</span></span><br><span class="line">Person person = Demo.getPerson();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用method方法</span></span><br><span class="line">Demo.method(person);</span><br><span class="line"><span class="comment">//匿名对象作为方法接收的参数</span></span><br><span class="line">Demo.method(<span class="keyword">new</span> Person());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ol><li><p>什么是内部类</p><p>将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。</p></li><li><p>什么时候使用内部类</p><p>在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，这时发动机就可以使用内部类来描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 汽车 </span>&#123; <span class="comment">//外部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 发动机 </span>&#123; <span class="comment">//内部类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部类的分类</p><p>内部类分为成员内部类与局部内部类。</p><p>我们定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。在内部类中可以直接访问外部类的所有成员。</p></li></ol><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问</p><ol><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123; </span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 变量名 = <span class="keyword">new</span> 外部类名().new 内部类名();</span><br></pre></td></tr></table></figure></li><li><p>成员内部类代码演示</p><p>定义类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;<span class="comment">//外部类，身体</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> life= <span class="keyword">true</span>; <span class="comment">//生命状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123; <span class="comment">//内部类，心脏</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;心脏噗通噗通的跳&quot;</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;生命状态&quot;</span> + life); <span class="comment">//访问外部类成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建内部类对象</span></span><br><span class="line">Body.Heart bh = <span class="keyword">new</span> Body().<span class="function">new <span class="title">Heart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//调用内部类中的方法</span></span><br><span class="line">bh.jump();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用规则</p><p>内部类，可以使用外部类成员，包括私有</p><p>外部类要使用内部类的成员，必须建立内部类对象</p></li><li><p>成员内部类的同名变量调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//System.out.println(i);//输出3</span></span><br><span class="line">            <span class="comment">//System.out.println(this.i);//输出2</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.i);<span class="comment">//输出1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        in.inner(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问</p><ol><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123; </span><br><span class="line">修饰符 返回值类型 方法名(参数) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">            <span class="comment">//其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问方式</p><p>在外部类方法中，创建内部类对象，进行访问</p></li><li><p>局部内部类代码演示</p><p>定义类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Party</span> </span>&#123;<span class="comment">//外部类，聚会</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">puffBall</span><span class="params">()</span></span>&#123;<span class="comment">// 吹气球方法</span></span><br><span class="line">         <span class="class"><span class="keyword">class</span> <span class="title">Ball</span> </span>&#123;<span class="comment">// 内部类，气球</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">puff</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;气球膨胀了&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//创建内部类对象，调用puff方法</span></span><br><span class="line">        <span class="keyword">new</span> Ball().puff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建外部类对象</span></span><br><span class="line">Party p = <span class="keyword">new</span> Party();</span><br><span class="line"><span class="comment">//调用外部类中的puffBall方法</span></span><br><span class="line">p.puffBall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="内部类的实际使用——匿名内部类"><a href="#内部类的实际使用——匿名内部类" class="headerlink" title="内部类的实际使用——匿名内部类"></a>内部类的实际使用——匿名内部类</h2><h3 id="匿名内部类概念"><a href="#匿名内部类概念" class="headerlink" title="匿名内部类概念"></a>匿名内部类概念</h3><p>内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。</p><p>最常用到的内部类就是匿名内部类，它是局部内部类的一种。</p><p>定义的匿名内部类有两个含义：</p><ul><li>临时定义某一指定类型的子类</li><li>定义后即刻创建刚刚定义的这个子类的对象</li></ul><blockquote><p>概念解读：</p><p>以前我们实现类的时候，都是先定义一个类Fu，然后让Zi继承Fu，然后重现Fu类的抽象方法，接着创建实现类对象在调用重写方法</p><p>而匿名内部类就是用于简化这种问题，一步来完成，将<code>定义实现类</code>，<code>重写方法</code>，<code>建立实现类</code>，合而为一</p></blockquote><h3 id="定义匿名内部类的作用与格式"><a href="#定义匿名内部类的作用与格式" class="headerlink" title="定义匿名内部类的作用与格式"></a>定义匿名内部类的作用与格式</h3><ol><li><p>作用</p><p>匿名内部类是创建某个类型子类对象的快捷方式。</p></li><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类或接口()&#123;</span><br><span class="line"><span class="comment">//进行方法重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已经存在的父类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义并创建该父类的子类对象，并用多态的方式赋值给父类引用变量</span></span><br><span class="line">Person  p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“我吃了”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用eat方法</span></span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure><p>使用匿名对象的方式，将定义子类与创建子类对象两个步骤由一个格式一次完成，。虽然是两个步骤，但是两个步骤是连在一起完成的。</p><p>匿名内部类如果不定义变量引用，则也是匿名对象。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“我吃了”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.eat();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static关键字</title>
      <link href="posts/ce244871.html"/>
      <url>posts/ce244871.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？</p><p>可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。</p><hr><p>概念解读：</p><p>比如有个学生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    String schoolName = “淮南师范学院”;   <span class="comment">//学校名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学生的年龄和姓名可能都不一样，但是学生都属于同一个学校，我们每次创建一个学生的时候，内存就会开辟一个空间，成员变量也会随之进来，，比如创建五个对象，学校名字变量也会创建五次，都是一样的，这就会照成浪费</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201101163257.png"></p><p>解决的方法:</p><p>变量schoolName从堆内存拿出来，放到一个地方去，让所有的学生对象共享一个schoolName变量</p><p>name，age属于对象自己的属性，对象自己特有的数据</p><p>schoolName应该作为对象的共享数据出现</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201101163625.png"></p><p>如何实现对象的共享数据？</p><p>在数据的前面加上static修饰</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol><li><p>被static修饰的成员变量属于类，不属于这个类的某个对象。</p><p><font color = "red">也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量</font></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo d1 = <span class="keyword">new</span> Demo();</span><br><span class="line">        Demo d2 = <span class="keyword">new</span> Demo();</span><br><span class="line">        d1.num = <span class="number">200</span>;</span><br><span class="line">        System.out.println(d1.num); <span class="comment">//结果为200</span></span><br><span class="line">        System.out.println(d2.num); <span class="comment">//结果为200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>被static修饰的成员可以并且建议通过类名直接访问。</p></li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><p>静态内容是优先于对象存在，只能访问静态（原因是因为，生命周期不同，静态优先于非静态存在内存中，静态出现的时候，非静态还没有出现），不能使用this/super（this代表本类引用，静态优于对象，没有对象，this就没有用，super同理）。静态修饰的内容存于静态区。</p></li><li><p>同一个类中，静态成员只能访问静态成员</p></li><li><p>main方法为静态方法仅仅为程序执行入口，它不属于任何一个对象，可以定义在任意类中。</p><blockquote><p>问题：</p><p>static修饰到底什么时候使用，应用场景</p><p>static修饰成员变量，成员方法</p><blockquote><p>成员变量加static，根据具体事物，具体分析问题</p><p>定义事物的时候，多个事物之间是否有共性的数据</p><p>请你将共性的数据定义为静态的成员变量</p></blockquote><blockquote><p>成员方法加static，跟着变量走</p><p>如果方法，没有调用过非静态成员，将方法定义为静态</p></blockquote></blockquote></li><li><p>多态调用中，编译运行都看“=”左边的父类，</p><p> 父类有，编译成功，父类没有，编译失败。</p><p> <strong>运行，静态方法，运行父类中的静态方法</strong></p><p> 运行，非静态方法，运行子类的重写方法</p><p> 成员变量，编译运行全是父类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.printf(<span class="string">&quot;父类的静态方法show&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.printf(<span class="string">&quot;子类的静态方法show&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fu f  =<span class="keyword">new</span> Zi();<span class="comment">//多态调用</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用还是父类的静态方法，原因：静态属于类，不属于对象</span></span><br><span class="line">      <span class="comment">//对象的多态性，静态和对象无关，父类的引用，静态方法</span></span><br><span class="line">        f.show(); <span class="comment">//打印会输出父类的方法show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="定义静态常量"><a href="#定义静态常量" class="headerlink" title="定义静态常量"></a>定义静态常量</h1><p>开发中，我们想在类中定义一个静态常量，通常使用<code>public static final修饰的变量</code>来完成定义。此时变量名用全部大写，多个单词使用下划线连接。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure><p>注意：</p><p>接口中的每个成员变量都默认使用public static final修饰。</p><p>所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值。可以直接用接口名访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方位接口中的静态变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inter.COUNT</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="posts/af55167d.html"/>
      <url>posts/af55167d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？</p><p>要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p>final修饰类不可以被继承，但是可以继承其他类。这种类在使用方式上没有任何变化，包括创建对象，调用方法，和之前没有区别，只是他不能被继承</p><h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。</p><h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><p>final修饰的变量称为常量，这些变量只能赋值一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">i = <span class="number">30</span>; <span class="comment">//赋值报错，final修饰的变量只能赋值一次</span></span><br></pre></td></tr></table></figure><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>final还可以修饰引用变量</p><p>引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">p = p2; <span class="comment">//final修饰的变量p，所记录的地址值不能改变</span></span><br><span class="line">p.name = <span class="string">&quot;小明&quot;</span>;<span class="comment">//可以更改p对象中name属性值</span></span><br></pre></td></tr></table></figure><p>p不能为别的对象，而p对象中的name或age属性值可更改。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">final 修饰成员变量</span></span><br><span class="line"><span class="comment">成员变量，在堆内存，具有默认值</span></span><br><span class="line"><span class="comment">final修饰的成员变量，固定的不是内存的默认值</span></span><br><span class="line"><span class="comment">固定的是，成员变量的手动赋值，绝对不是内存的默认</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果手动不赋值，可以在构造器利用构造器赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以采用手动直接赋值，或者构造器的方法都可以，只要保证，<code>被final修饰的成员变量，只能被赋值一次</code>，<strong>在创建对象前赋值</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】第二章：操作系统基础操作</title>
      <link href="posts/39515ecd.html"/>
      <url>posts/39515ecd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h1><ol><li><p>CPU, I/O, 内存通过总线连接</p></li><li><p>DISK（硬盘）: 存放OS</p><p>BIOS：基本I/O处理系统</p><p>Bootloader: 加载OS到内存中</p></li><li><p>当电脑通电时，段寄存器CS和指令寄存器IP<code>合在一起</code>能够确定一个内存地址，例如CS:IP = 0xf000:fff0。刚开始加电，以x86为例，bios会从0xf000:fff0这个地址开始执行，然后会执行接下来的一系列工作，包括第四点的自检</p></li><li><p>POST(加电自检)，寻找显卡和执行BIOS。(显示器，键盘…是否正常)</p></li><li><p>步骤：</p><ul><li><p>BIOS：将Bootloader从磁盘的磁盘的引导扇区(在硬盘的第一个扇区，也就是512字节)加载到0x7c00，跳转到CS:IP=0000:7c00的内存区域(以便下一步)，这个时候cpu的控制权已经交给Bootloader了</p></li><li><p>Bootloader：将操作系统的代码和数据从硬盘加载到内存中；跳转到操作系统的起始地址，这个时候cpu的控制权已经交给os了</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201031225845.png"></p></li></ul></li><li><p>系统调用：(来源于应用程序)应用程序主动向操作系统发出服务请求</p></li><li><p>异常：(来源于不良的应用程序)非法指令或其它花的处理状态(如：内存出错)</p></li><li><p>中断：(来源于外设)来自不同的硬件设备的计时器和网络的中断</p></li><li><p>为什么应用程序不能直接访问硬件而是通过操作系统？</p><ul><li>计算机运行时，内核是被信任的第三方</li><li>只有内核可以执行特权指令</li><li>为了方便应用程序</li></ul></li><li><p>讨论的问题：操作系统如何设计和实现中断/异常和系统调用；他们三者的区别和特点。</p><ol><li><p>产生的源头：</p><ul><li>中断：外设(键盘/鼠标/网卡/声卡/显卡，可以产生各种事件)</li><li>异常：应用程序意想不到的行为(例：异常，恶意程序，应用程序需要的资源未得到满足)</li><li>系统调用(system call)：应用程序请求操作提供服务(例：打开/关闭/读写文件，发送网络包)</li></ul></li><li><p>处理时间</p><ul><li>中断：异步（当这个事件产生的时候，我们的应用程序不知道他什么时候会产生，无法预测）</li><li>异常：同步</li><li>系统调用：同步或异步</li></ul><blockquote><p>异步同步我没有理解，弹幕上说，异步不可预知，同步可以预知</p></blockquote></li><li><p>响应</p><ul><li>中断：持续，对用户应用程序时透明的（因为操作系统把中断过程完成了，我们感知不到）</li><li>异常：杀死或者重新执行意想不到的应用程序指令</li><li>系统调用：等待和持续</li></ul></li></ol></li></ol><h1 id="中断-异常和系统调用"><a href="#中断-异常和系统调用" class="headerlink" title="中断/异常和系统调用"></a>中断/异常和系统调用</h1><ol><li><p>中断/异常处理机制</p><p>中断是外设的事件</p><p>异常是CPU的事件</p><p>中断/异常迫使CPU访问一些被中断和异常服务访问的功能</p></li><li><p>中断处理机制</p><p>硬件：设置中断标记(CPU初始化)</p><ul><li>将内部/外部事件设置中断标记；</li><li>中断事件的ID(程序访问的中断向量地址)</li></ul><p>软件(操作系统)：</p><ul><li>保存当前处理状态</li><li>中断服务程序处理</li><li>清除中断标记</li><li>恢复之前保存的处理状态</li></ul></li><li><p>异常处理机制</p><p>异常：异常编号</p><ul><li>保存现场</li><li>异常处理：杀死产生异常的程序；重新执行异常指令</li><li>恢复现场</li></ul></li><li><p>系统调用</p><ul><li>一条指令会触发一个系统调用</li><li>程序访问主要是通过高层次的API接口而不是直接进行系统调用。</li><li>通常情况下，存在与每个系统调用相关的序号，系统调用接口根据这些序号来维护表的索引</li><li>系统调用接口调用内核态中预期的系统调用，并返回系统调用的状态和其它任何返回值</li><li>用户不需要知道系统调用是如何实现的，只需要获取API和了解操作新系统将什么作为返回结果。操作系统接口的细节大部分都隐藏在API中，并通过运行程序支持的库来管理</li><li>用户态：应用程序在执行的过程中，CPU执行的特权级的状态(很低，不能访问特殊机器指令和IO)</li><li>内核态：应用程序在执行的过程中，CPU执行的特权级的状态(高，操作系统可以执行CPU任何一条指令)</li><li>系统调用时涉及到特权级从用户态到内核态的转换，应用程序和操作系统有各自的堆栈，这两个变化比函数调用的开销更大，但更安全和可靠。(而程序调用是在一个栈空间实现参数的调用和返回)</li></ul></li><li><p>跨越操作系统边界的开销</p><ul><li><p>在执行时间上的开销超过程序调用</p></li><li><p>开销包括：</p><p>建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销；<br>建立内核堆栈(操作系统和应用程序的堆栈不一样)；<br>验证参数(操作系统会检查数据)；<br>内核态映射到用户态的地址空间，更新页面映射权限(内存拷贝开销)；<br>内核态独立地址空间TLB。</p></li></ul></li></ol><blockquote><p>参考：<a href="https://blog.csdn.net/iwanderu/article/details/103934399">https://blog.csdn.net/iwanderu/article/details/103934399</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>super关键字</title>
      <link href="posts/f6ea766.html"/>
      <url>posts/f6ea766.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>和this一样，<code>super.</code>的方式，是用来引用父类的变量与方法的</p><p>除此之外，super还可以调用父类的构造方法</p><p> <code>super()</code>调用的是父类的空参数构造</p><p><code>super(参数)</code> 调用的是父类的有参数构造方法</p><p>其中要注意的是，子类的构造方法, 有一个默认添加的构造方法，子类构造方法中的第一行,有一个隐式代码 super()，<font color=brown>（注：这里说一下，子类的<strong>所有构造方法</strong>，无论重载多少个，第一行都是 super()）</font></p><p>即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的构造方法第一行super语句,调用父类的构造方法</p><p>代码理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台会输出<code>父类构造方法</code>字样，意思就是我上面说的那样，子类的构造方法, 有一个默认添加的构造方法，子类构造方法的第一行,有一个隐式代码 super()</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？</p><p>这时是没有的，因为this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。</p><p> super(参数) 与 this(参数) 不能同时在构造方法中存在</p><p>小结论: 无论如何,子类的所有构造方法,直接,间接必须调用到父类构造方法</p><hr><blockquote><p>这里吐槽一下，这些东西我早忘记了….一点印象都没有…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this关键字</title>
      <link href="posts/75f5b5c3.html"/>
      <url>posts/75f5b5c3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>this.的方式</code>，区分局部变量和成员变量同名情况</p><p>除此之外，this还可以在构造方法之间调用，语法格式是<code>this()</code>,而且<strong>只能写在构造方法的第一行</strong></p><p>代码理解：</p><p>创建一个人，出生的时候如果不初始化，默认给一个name和age代码，不是null和0，是指定的数字</p><p>如果不用this，代码可以这样表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getset省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到无论是有参构造器还是无参构造器，两个方法的作用都是给对象的成员变量初始化，所以如果一个方法调用另一个方法，可以使代码减少很多</p><p>正确的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//调用了有参数的构造方法</span></span><br><span class="line"><span class="comment">//参数李四,20传递给了变量name,age</span></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  构造方法,传递String,int</span></span><br><span class="line"><span class="comment"> *  在创建对象的同时为成员变量赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getset省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立对象的时候，如果没有指定参数，就会默认调用无参构造器，其中的<code>this(&quot;李四&quot;,20);</code>调用有参构造，然后给成员变量初始化，就会达到，建立对象的同时给成员变量赋值的效果</p><p>注意：<strong>调用其他构造方法的语句必须<font color=red>定义在构造方法的第一行</font>，原因是初始化动作要最先执行。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于构造方法</title>
      <link href="posts/7b749a13.html"/>
      <url>posts/7b749a13.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>构造方法的作用就是: 在new 的同时对成员变量赋值, 给对象的属性初始化赋值  new Person 对属性 name,age赋值</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限  方法名(参数列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>方法的名字,必须和类的名字完全一致</p><p>构造方法不允许写返回值类型  , void 也不能写</p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>构造方法在new 的时候,自动执行，而且只允许一次</p><p>每个类必须拥有构造方法，不写也有，编译的时候，javac, 会自动检查类中是否有构造方法，如果有,就这样的，如果没有,编译器就会自动添加一个构造方法</p><p> 编译器自动添加的构造方法: public Person(){}</p><p>自己手写了构造方法,编译的时候,不会自动添加构造方法!</p><h1 id="内存详解"><a href="#内存详解" class="headerlink" title="内存详解"></a>内存详解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person的构造方法，拥有参数列表</span></span><br><span class="line">Person(<span class="keyword">int</span> age, String name) &#123;</span><br><span class="line"><span class="comment">// 接受到创建对象时传递进来的值，将值赋给成员属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">set/get省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建Person对象，并明确对象的年龄和姓名</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序最开始，main方法压栈运行，执行<code>Person p = new Person(23, &quot;张三&quot;);</code>,堆内存会出现一块空间给Person，成员变量 跟随对象 创建进入堆内存，并且初始化默认值，0与null,，然后接着<strong>对象会调用自己的构造方法</strong>，构造方法会进入栈内存运行</p><p>构造方法压栈运行，对象会将最初的<code>张三</code>与<code>23</code>传给构造方法，将自己的内存地址传给this关键字，然后赋值成员变量，构造方法运行完成后，弹栈死亡，<strong>构造方法运行结束了，整个对象才算建立完成</strong>，然后p指向对象地址</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201024160045.png"></p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><ol><li>一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的,根据自己需求</li><li>构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。<em>这个应该就是应对考试的，记一下吧</em></li></ol><h1 id="构造方法和一般方法区别"><a href="#构造方法和一般方法区别" class="headerlink" title="构造方法和一般方法区别"></a>构造方法和一般方法区别</h1><ol><li>构造方法在对象创建时就执行了，而且只执行一次。<strong>是对象调用的</strong></li><li>一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。<strong>是我们自己调用的</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态向上与向下转型</title>
      <link href="posts/fc8e9806.html"/>
      <url>posts/fc8e9806.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h1><p>多态中特有的体现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类的引用 变量 = new 子类的对象();</span><br></pre></td></tr></table></figure><p>java是一门强制数据类型的语言，参数运算的数据，保证类型的统一性，</p><p>如果数据类型不一致的时候，只有两种情况，一种是<code>自动类型提升</code>，一种是<code>强制类型转换</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fu f = new Zi();</span><br></pre></td></tr></table></figure><p>这条语句明显左右两边类型不一样，但是编译运行的时候，却不受影响，只有上面说的两种情况，但是我没有参与，也就是强制转换其他类型，它只有一种解释，就是<code>自动类型提升</code>, </p><p>所谓自动类型提升就是，将取值范围小的自动提升为取值范围大的，而引用数据类型没有取值范围这个概念，但是原理都是一样的，范围小的看成是子类，范围大的看成是父类，<code>Fu f = new Zi();</code>这行代码，f就是父类类型，将子类提升为了父类类型，这个提升就是<code>向上转型</code>。</p><p><strong>实际上，当new 子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。</strong></p><p>向上转型的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：Person p = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><p>向上转型只能调用子类和父类的公有内容，这也是多态的一个好处，但是也有弊端，就是不能调用子类的特有方法，但是可以向下转型</p><h1 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h1><p>多态调用，如果要调用子类的特有内容，可以向下转型，父类类型强制转换子类类型，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fu f = <span class="keyword">new</span> Zi();<span class="comment">//多态调用，f向上转型，现在下一步我要调用子类特有方法</span></span><br><span class="line">Zi z = (Zi)f;    <span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><p>一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！</p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类类型的变量;</span><br><span class="line">如:Student stu = (Student) p;  </span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>什么时候使用向上转型</p><p>当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。</p></li><li><p>什么时候使用向下转型</p><p>当要使用子类特有功能时，就需要使用向下转型。</p></li><li><p>向下转型的好处：可以使用子类特有功能。</p></li><li><p>弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。</p><p>如：if( !a instanceof Dog){…}</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>instanceof关键字</title>
      <link href="posts/15b3e85e.html"/>
      <url>posts/15b3e85e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java中有个关键字叫<code>instanceof</code>，返回值是true或者false</p><p>它是用来比较引用数据类型的关键字，一个引用类型的变量,是不是这个类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;学生在休息睡觉&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;老师在休息&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，建立一个抽象类Person，定义抽象方法sleep（），再建立学生类与老师类继承Person类，重写抽象方法</p><p>建立对象的时候，利用多态性，可以这样写</p><p><code>Person p = new Student();</code>也可以<code>Person p = new Teacher();</code>，</p><p>而instanceof就可以用来比较这个p是是Student类型对象,还是Teacher类型对象</p><p>写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用变量 <span class="keyword">instanceof</span> 类名</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p <span class="keyword">instanceof</span> Student  <span class="comment">//比较,p是不是Student类型的对象,如果是,intanceof返回true</span></span><br></pre></td></tr></table></figure><p>附上test类代码以及结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = p <span class="keyword">instanceof</span> Student;</span><br><span class="line">System.out.println(b);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> c = p <span class="keyword">instanceof</span> Teacher;        </span><br><span class="line">    System.out.println(c);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中还有前提条件就是，老师和学生一定要继承Person类才可以用instanceof关键字，否则会编译报错</p><p>用代码解释就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再添加一个动物抽象类，测试类中这样写到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">b = p <span class="keyword">instanceof</span> Animal;  <span class="comment">//这样写错误的，编译不能通过</span></span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instanceof比较的两个变量一定要有关系才可以用</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态概述以及成员特点</title>
      <link href="posts/47b88999.html"/>
      <url>posts/47b88999.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多态概述"><a href="#多态概述" class="headerlink" title="多态概述"></a>多态概述</h1><p>我理解的多态就是<code>同一种事物的多种形态</code></p><p>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。</p><p>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</p><p>Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。</p><p>如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。</p><h1 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h1><ul><li>父类引用变量可以指向子类对象</li><li>多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。</li><li>在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</li></ul><h1 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h1><ol><li><p>先看成员变量</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 建立一个测试类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(f.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 控制台会显示1,也就是父类的成员变量值，他没有走子类的</p></li><li><p>如果是方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        f.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 控制台会显示zi,也就是子类的重写方法</p></li></ol><blockquote><p>总结</p><ol><li><p>成员变量:</p><p> 编译的时候, 参考父类中有没有这个变量,如果有,编译成功,没有编译失败</p><p> 运行的时候, 运行的是父类中的变量值<br><font color=#b33b63> <strong><em>编译运行全看父类</em></strong></font></p></li></ol><ol start="2"><li><p>成员方法:</p><p>   编译的时候, 参考父类中有没有这个方法,如果有,编译成功,没有编译失败</p><p>   运行的时候, 运行的是子类的重写方法</p><p>   <font color=#b33b63><strong><em>编译看父类，运行看子类</em></strong></font></p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口的区别</title>
      <link href="posts/4a128e89.html"/>
      <url>posts/4a128e89.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>举例：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">犬：</span><br><span class="line">    行为：</span><br><span class="line">        吼叫；</span><br><span class="line">        吃饭；</span><br><span class="line">缉毒犬：</span><br><span class="line">    行为：</span><br><span class="line">        吼叫；</span><br><span class="line">        吃饭；</span><br><span class="line">        缉毒；</span><br></pre></td></tr></table></figure></li><li><p>思考</p><p> 由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。</p><p> 可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。</p><p> 代码演示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 缉毒</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 缉毒();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义犬科的这个提醒的共性功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 吃饭();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 吼叫();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，</span></span><br><span class="line"><span class="comment">//由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 缉毒犬 <span class="keyword">extends</span> 犬科 <span class="keyword">implements</span> 缉毒</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 缉毒() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 吃饭() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 吼叫() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 缉毒猪 <span class="keyword">implements</span> 缉毒</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 缉毒() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>通过上面的例子总结：</p><p> <strong>相同点:</strong></p><ul><li><p>都位于继承的顶端,用于被其他类实现或继承;</p></li><li><p>都不能直接实例化对象;</p></li><li><p>都包含抽象方法,其子类都必须覆写这些抽象方法;</p></li></ul><p> <strong>区别:</strong></p><ul><li><p>抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;</p></li><li><p>一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)</p></li><li><p>抽象类是这个事物中应该具备的你内容, 共性</p></li><li><p>接口是这个事物中的额外内容,</p><blockquote><p>抽象类是同一个事物的共性，</p><p>而接口就是额外多出来的功能，他有你没有，你有我没有，并不是大家都有的功能</p></blockquote></li></ul><p> <strong>二者的选用</strong>：</p><ul><li><p>优先选用接口,尽量少用抽象类;</p></li><li><p>需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo绑定个人域名</title>
      <link href="posts/d026edc8.html"/>
      <url>posts/d026edc8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h1><ol><li><p>先进入桌面, <code>cd 你的hexo本地目录</code>, <code>cd source</code>, <code>touch CNAME</code>创建CNAME文件，写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shuigwh.cn</span><br></pre></td></tr></table></figure></li><li><p>保存,部署远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li></ol><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>www是<code>xxxx.github.io</code></p><p>@对应的是<code>xxxx.github.io</code>的IP，可以ping拿到IP</p><p>即</p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>记录值</th></tr></thead><tbody><tr><td>www</td><td>CNAME</td><td>xxxx.github.io</td></tr><tr><td>@</td><td>A</td><td>xxx.xxx.xxx.xxx</td></tr></tbody></table><p>然后保存，这个时候等一会就可以访问了，但是只能访问http://的形式</p><p>到远程库的设置里面，<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201023142757.png"></p><p>将这个https勾选，保存即可</p><p>过一会就可以访问https://的形式了</p><blockquote><p>参考：<a href="https://blog.csdn.net/yucicheung/article/details/79560027">https://blog.csdn.net/yucicheung/article/details/79560027</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承，实现总结</title>
      <link href="posts/1eedea8a.html"/>
      <url>posts/1eedea8a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p><code>类与类</code>之间是继承关系，只能单继承，子类自动继承父类的所有数据，即成员变量和方法</p><blockquote><p> 注意：抽象类，其中可以包含抽象方法，也可以包含具体的方法，但是如果有抽象方法，这个类一定是抽象类</p><p> 类继承抽象类，要重写抽象类里面的所有抽象方法</p></blockquote><blockquote><p>接口，里面只能包含常量（默认public static final）与抽象方法(默认public abstract),就算不写修饰符，也就是public static final abstract 这些，也是可以的</p></blockquote></li><li><p><code>类与接口</code>的之间是实现关系(implement)，可以多实现接口，一旦类实现接口，必须要重写接口里面的所有抽象方法</p></li><li><p><code>接口与接口</code>之间是继承(extends)，支持多继承（因为都是抽象方法，所以不像类只能单继承，存在安全隐患）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于接口与继承的理解</title>
      <link href="posts/18276965.html"/>
      <url>posts/18276965.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="继承的弊端"><a href="#继承的弊端" class="headerlink" title="继承的弊端"></a>继承的弊端</h1><p>在Java中，继承不能多继承，也就是一个类只能继承一个类，不能继承多个类，举个列子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bbbb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在来一个类叫C，c同时继承A 和B类，当实例化c的时候，调用父类的function方法时候,这个时候就不知道应该调用那个类中的function方法了，这也是继承的局限性</p><h1 id="接口的好处"><a href="#接口的好处" class="headerlink" title="接口的好处"></a>接口的好处</h1><p>所以就有了接口，Java中，一个类可以实现多个接口，也可以理解同时继承多个接口，但是和继承不同的是，接口里面的方法全是抽象方法，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是两个接口，里面的方法都是一样的，建立一个C类，实现这两个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口要重写里面的抽象方法，由于抽象方法名字都是一样的，所以写一次就可以了，接口的里面的方法全都是抽象的，即使名字一样也不要紧，由实现接口的类自己定，所以它和继承不一样</p><blockquote><p>总结：类的多继承，当多个父类中有相同功能时，子类调用会产生不确定性，所以会存在安全隐患，<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口的多实现，没有安全隐患，原因在于接口中的方法全是抽象，没有主体</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用数据类型传参</title>
      <link href="posts/626c8828.html"/>
      <url>posts/626c8828.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引用数据类型传参会涉及到堆内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        System.out.println(p.name);<span class="comment">//张三</span></span><br><span class="line">        function(p);</span><br><span class="line">        System.out.println(p.name);<span class="comment">//李四</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> statc <span class="keyword">void</span> <span class="title">function</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        p.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序开始运行，main方法先压栈执行，<code>Person p = new Person();</code>堆内存会开辟一块内存空间，Person对象，成员变量name随着对象建立一起进入堆内存，并且赋初值null,此内存地址假设是0x01，c变量会指向堆内存的0x01地址，<code>p.name = &quot;张三&quot;;</code>null被<code>张三</code>覆盖，接着打印p.name,会显示张三</p><p>运行<code>function(p)；</code>,function方法会压栈执行，传参给的其实p中保存的地址，所以function方法中的p也指向堆内存的内存地址0x01,此时两个变量p都指向了同一片内存空间地址，function方法中<code>p.name=&quot;李四&quot;</code>,原来的张三又被李四覆盖，function方法运行完毕，function方法就会弹出栈内存死亡，main方法继续运行<code> System.out.println(p.name);</code>，控制台会显示李四</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021140357.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成员变量和局部变量区别</title>
      <link href="posts/40dd4c9d.html"/>
      <url>posts/40dd4c9d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>定义位置上的区别</p><p>成员变量，定义在类中，方法外</p><p>局部变量，方法内，语句外</p></li><li><p>作用域不同</p><p>成员变量，作用范围是整个类</p><p>局部变量，方法内，语句内</p></li><li><p><font color=green><strong>默认值不同</strong></font></p><p>成员变量有自己的默认值（对象在内存中的理解说过）</p><p><font color = red><strong>局部变量，没有默认值，不赋值不能使用</strong></font></p></li><li><p><font color=green><strong>内存位置不同（对象在内存中的理解说过）</strong></font></p><p>成员变量，跟随对象进入堆内存存储</p><p>局部变量，跟随自己的方法，进入栈内存</p></li><li><p><font color=green><strong>生命周期不同</strong></font></p><p>成员变量，跟随对象，在堆内存中存储，等待JVM（虚拟机）清理          生命周期较长</p><p>局部变量，跟随方法，方法出栈                                                                                    生命周期较短</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象在内存中的理解</title>
      <link href="posts/576f6a89.html"/>
      <url>posts/576f6a89.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中有栈内存和堆内存</p><p><code>栈内存</code>是运行方法用的，<code>堆内存</code>是存储容器用的</p><p><del>一个完整的Java程序如果要运行，先从main方法进行，main先压栈，new出来的对象实力，在堆内存里面</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小汽车在跑&quot;</span>+color+<span class="string">&quot;..&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Car c = <span class="keyword">new</span> Car();</span><br><span class="line">        c.color = <span class="string">&quot;无色&quot;</span>;</span><br><span class="line">        c.count = <span class="number">5</span>;</span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一个完整的Java程序,一个car类，一个测试类</p><p>程序开始运行</p><p>main先压栈，运行第一行代码<code>Car c = new Car();</code>，Java虚拟机会在堆内存开辟一快空间，有了空间，就会有属于自己的内存地址</p><p>例如这个地址是<code>0x001</code>,这块空间是new car 创建的</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021123430.png" style="zoom: 80%;" /><p>对象在对内存创建后，类的成员变量，会跟随对象进入到堆内存中，并且会赋值默认值，这个默认值是更加成员变量的类型而定的，就比如<code>Car c = new Car()</code>,如果后面没有赋值，那么他的成员变量的默认值就是<code>null</code>和<code>0</code>，即下图：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021124434.jpg" style="zoom: 67%;" /><p>这就是<code>new Car();</code>在堆内存中的执行时的示意图</p><p>此时对象就建立完成了，然后Java虚拟机就会将这个对象内存地址传送给引用变量c,c就会指向这片内存空间，即</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021125009.jpg" style="zoom:80%;" /><p>所以，真正的对象是new出来的，而c保存的其实是对象内存的地址，所以，直接把c叫做car类的变量也没有问题</p><p>接着，main开始运行下一条代码，<code>c.color = &quot;无色&quot;;</code>，相应的，堆内存中的<code>null</code>会被<code>无色</code>覆盖，<code>c.count = 5;</code>堆内存中的<code>0</code>会被<code>5</code>覆盖</p><p>当程序执行<code>c.run();</code>，类中的方法run就会进栈执行，虚拟机会再次开辟空间是run方法压栈运行</p><p>run方法中只有一句<code>System.out.println(&quot;小汽车在跑&quot;+color+&quot;..&quot;+count);</code>,其中的color与count可以这样理解，方法run是对象c调用，那么其中的color和count指的就是对象c的成员变量，所以<code>无色</code>和<code>5</code>就会被打印到控制台上，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021131215.jpg" style="zoom: 80%;" /><p>打印完成后，run方法就会结束，run方法就要出栈死亡，这个过程叫弹栈，弹出栈内存死亡，死亡了，内存就会被释放</p><p>main也随即运行完成了，也会弹出栈内存死亡，释放内存</p><p>main死亡之后，变量c将不会再指向堆内存的对象地址，所以这个对象在内存中也会变成垃圾    </p><blockquote><p> 这里要说一下，栈内存中的方法用完了就会释放，空间就会出来了，而堆内存中的对象或者是数组，它自己不会释放，他要等着虚拟机清理，而虚拟机清理垃圾是不需要我们考虑的，它属于自动行为</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---定状同从句</title>
      <link href="posts/c9325fa6.html"/>
      <url>posts/c9325fa6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131032.png"></p><p>以下这些词都可以用同位语从句进行解释</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131122.png" style="zoom:67%;" /><p>例句：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131347.png" style="zoom:80%;" /><blockquote><p>同位语从句有很多连接词，但是百分之99都是that</p></blockquote><h1 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h1><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131753.png" style="zoom: 80%;" /><h2 id="连词"><a href="#连词" class="headerlink" title="连词"></a>连词</h2><h3 id="修饰人-who-whom"><a href="#修饰人-who-whom" class="headerlink" title="修饰人(who/whom)"></a>修饰人(who/whom)</h3><ol><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132039.png" style="zoom:67%;" /></li><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132137.png" style="zoom:67%;" /></li></ol><h3 id="修饰物（that-which）"><a href="#修饰物（that-which）" class="headerlink" title="修饰物（that/which）"></a>修饰物（that/which）</h3><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019140350.png" style="zoom:67%;" /><p>其中that和which不能乱用</p><p>这种情况只能用that，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132706.png" style="zoom:67%;" /><blockquote><p> 先行词就是被修饰的那个名词</p></blockquote><h3 id="修饰句，表示总结（which）"><a href="#修饰句，表示总结（which）" class="headerlink" title="修饰句，表示总结（which）"></a>修饰句，表示总结（which）</h3><p>这种情况只能用which，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132929.png" style="zoom:67%;" /><h4 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h4><p><strong><font color='green'><em>修饰句，表示总结</em></font></strong></p><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019133201.png" style="zoom:67%;" /><p>这就是修饰的前面整句话，所以必须用which，必须用<code>,</code></p><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019134710.png" style="zoom:67%;" /><p>这句话，如果不用定语从句，这句话是这样翻译的：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019134757.png" style="zoom:80%;" /><p>这是两个简单句，完全可以。</p><p>如果用定语从句可以这样</p><p>分析：</p><p><code>这</code>修饰前面的<code>中国的经济正迅速发展</code>这句话，所以是定语从句，所以也可以这样写，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135028.png" style="zoom:80%;" /><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135509.png" style="zoom:67%;" /><h2 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h2><ul><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135729.png" style="zoom:80%;" /></li><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019140523.png" style="zoom: 80%;" /></li></ul><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><blockquote><p>做阅读可能会遇到下面的几个情况</p></blockquote><p><strong><em><font color='green'>介词+which</font></em></strong></p><p>这也是定语从句，翻译方法：</p><ol><li>介词先砍掉，</li><li>然后把介词放到从句里面去</li></ol><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141059.png"></p><p>分析：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141152.png"></p><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141234.png"></p><p>分析：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141333.png" style="zoom:80%;" /><hr><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019142136.png" style="zoom:80%;" /><blockquote><p><font color='brown'><strong>连词如果在定语从句中做宾语是可以省略的</strong></font>，这里要注意，可能阅读会有陷阱</p></blockquote><h1 id="状语从句"><a href="#状语从句" class="headerlink" title="状语从句"></a>状语从句</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019143906.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度云在线视频加速方法</title>
      <link href="posts/9ced7ac.html"/>
      <url>posts/9ced7ac.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>网页版百度网盘视频今天看着有点慢，想加速，搜了一下，防止遗忘，在此记录一下</p></blockquote><p>打开网页版，然后打开控制台，输入以下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">videojs.getPlayers(<span class="string">&quot;video-player&quot;</span>).html5player.tech_.setPlaybackRate(<span class="number">1.5</span>) </span><br></pre></td></tr></table></figure><p>这是1.5倍播放，需要多少，直接在后面改参数就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 实用小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百度网盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---主宾表从句</title>
      <link href="posts/ca22eae1.html"/>
      <url>posts/ca22eae1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="从句概念"><a href="#从句概念" class="headerlink" title="从句概念"></a>从句概念</h1><p>一句话做定语=定语从句</p><p>一句话做宾语=宾语从句</p><p>一句话做表语=表语从句</p><h1 id="主从句之间的连接"><a href="#主从句之间的连接" class="headerlink" title="主从句之间的连接"></a>主从句之间的连接</h1><p>桥梁：连词</p><h2 id="连词一（从句完整）"><a href="#连词一（从句完整）" class="headerlink" title="连词一（从句完整）"></a>连词一（从句完整）</h2><p><strong><em>that/whether/if</em></strong></p><p>从句完整的时候用that连接</p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225156.png" style="zoom:50%;" /><p>有时候也用whether或者if</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225331.png" style="zoom:50%;" /><p>注意，不能使用if的情况</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225431.png" style="zoom:67%;" /><p>所以为了方便，一直用whether就可以了</p><h2 id="连词二（从句缺人）"><a href="#连词二（从句缺人）" class="headerlink" title="连词二（从句缺人）"></a>连词二（从句缺人）</h2><p><strong><em>who/ whom</em></strong></p><ul><li><p>who是在从句中做主语</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225926.png" style="zoom: 80%;" /></li><li><p>whom是在从句中做宾语</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230129.png" style="zoom:80%;" /></li></ul><p>举例：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230343.png" style="zoom:80%;" /><h2 id="连词三（从句缺物）"><a href="#连词三（从句缺物）" class="headerlink" title="连词三（从句缺物）"></a>连词三（从句缺物）</h2><p><strong><em>what</em></strong></p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201018122713.png" style="zoom:67%;" /><h2 id="连词四（从句需状语）"><a href="#连词四（从句需状语）" class="headerlink" title="连词四（从句需状语）"></a>连词四（从句需状语）</h2><p><strong><em>when(时间)/where（地点）/why（原因）/how（方式）</em></strong></p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230758.png" style="zoom: 80%;" /><h1 id="翻译从句的方法"><a href="#翻译从句的方法" class="headerlink" title="翻译从句的方法"></a>翻译从句的方法</h1><p>先把连词放在句子的空缺处，然后从左往右翻译</p><h1 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h1><h2 id="特殊主语从句"><a href="#特殊主语从句" class="headerlink" title="特殊主语从句"></a>特殊主语从句</h2><p>有道题是这样的</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232551.png" style="zoom: 80%;" /><p>这种情况是错误的，出现了两个动词</p><p>解决方法：</p><p>可以加个that</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232717.png"></p><p>但是前面有点长，要避免头重脚轻，把that引动的从句放到后面，前面加个形式主语it</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232847.png"></p><h1 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h1><h2 id="在及物动词后作宾语"><a href="#在及物动词后作宾语" class="headerlink" title="在及物动词后作宾语"></a>在及物动词后作宾语</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233317.png"></p><h2 id="在介词后面作宾语"><a href="#在介词后面作宾语" class="headerlink" title="在介词后面作宾语"></a>在介词后面作宾语</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233423.png"></p><p>宾从例句：</p><p>​    <img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233754.png" style="zoom: 67%;" /></p><h1 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234424.png"></p><p>这是个简单句，不是表语从句</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234452.png"></p><p>表语从句</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234929.png" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---句子成分</title>
      <link href="posts/92acea72.html"/>
      <url>posts/92acea72.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="主语"><a href="#主语" class="headerlink" title="主语"></a>主语</h1><p> 动作发出者</p><h2 id="找主语的方法"><a href="#找主语的方法" class="headerlink" title="找主语的方法"></a>找主语的方法</h2><ol><li>谓语动词的前面</li></ol><h1 id="宾语"><a href="#宾语" class="headerlink" title="宾语"></a>宾语</h1><p>动作承受者  名词类（及物动词后面的全是宾语）</p><p>动词不能直接做宾语，要修改成名词</p><p>动词 —&gt; 名词  的方法</p><pre><code>                                   1. to do                                                        2. doing</code></pre><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015132831.png"></p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015133020.png"></p><h2 id="找宾语的方法："><a href="#找宾语的方法：" class="headerlink" title="找宾语的方法："></a>找宾语的方法：</h2><ol><li>介词后面的</li><li>及物动词后面的</li></ol><h2 id="介宾结构"><a href="#介宾结构" class="headerlink" title="介宾结构"></a>介宾结构</h2><p>介词只能加，名词/doing/宾格，其他都是错的</p><h1 id="表语"><a href="#表语" class="headerlink" title="表语"></a>表语</h1><p>修饰主语, 名词或者形容词类</p><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015170014.png"></p><blockquote><p>改变世界还没有完成，所以用to do </p></blockquote><p>这里为什么要加个the</p><p>the的用法：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015170453.png"></p><h2 id="找表语的方法"><a href="#找表语的方法" class="headerlink" title="找表语的方法"></a>找表语的方法</h2><p>​    系动词后面的</p><p>​    凡是能用be动词替换的，包括be本身，都是主系表结构</p><h1 id="定语"><a href="#定语" class="headerlink" title="定语"></a>定语</h1><p>概念： 修饰名词的</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015171502.png"></p><p>当动词是doing，修饰名词，这个doing代表一个功能</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015171902.png"></p><p>定于可以在前面也可以在后面，当在前面的时候很简单，很短，</p><p>当在后面的时候一般都很复杂，要么是<code>to do</code>要么是<code>介词短语</code></p><h1 id="状语"><a href="#状语" class="headerlink" title="状语"></a>状语</h1><p>修饰形容词，动词，句子</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015172558.png" style="zoom:50%;" /><h1 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a>同位语</h1><p>修饰且等于名词</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015173540.png" style="zoom: 80%;" /><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015174440.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---句子结构</title>
      <link href="posts/5d143ecd.html"/>
      <url>posts/5d143ecd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="三个基本结构"><a href="#三个基本结构" class="headerlink" title="三个基本结构"></a>三个基本结构</h1><ol><li>主谓宾</li><li>主谓</li><li>主系表</li></ol><h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><ol><li><p>及物动词（有对象）</p></li><li><p>不及物动词</p><p>1和2叫实义动词</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014164711.png"></p></li><li><p>系动词（能用be替换）</p><p>​    例如：<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201014160925.png">，<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201014161100.png">，</p><p>​    <strong><em>凡是能用be动词替换的，包括be本身，都是主系表结构</em></strong></p></li><li><p>助词</p><p>时态，情态，否定</p></li></ol><hr><p>及物动词引导主谓宾，不及物动词引导主谓，系动词引导主系表</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014165529.png"></p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014165749.png"></p><p>判断结构</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014170701.png"></p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>可以先将代表修饰的词删掉<img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014170508.png"></p><h1 id="三大特殊结构"><a href="#三大特殊结构" class="headerlink" title="三大特殊结构"></a>三大特殊结构</h1><ol><li><p>主谓宾宾</p></li><li><p>主谓宾补</p></li><li><p>强调句</p><p>1和2  宾宾和宾补可以在中间加个be动词进行连接，可以连接的是宾补，不能的就是宾宾<br><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014173513.png"></p></li></ol><h2 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h2><p>格式：</p><p>​        强调主语：it is  + 人 +   who<br>​        强调状语：it is  + 物 +   that</p><hr><p>强调谁，就把谁放在前面，剩下的部分原封不动放在后面</p><p>举例：</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014174507.png"></p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="posts/f2b26283.html"/>
      <url>posts/f2b26283.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这几个命令怕以后忘记了，单独开个博文记录一下</p></blockquote><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="添加暂存区"><a href="#添加暂存区" class="headerlink" title="添加暂存区"></a>添加暂存区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;信息&quot;</span></span><br></pre></td></tr></table></figure><h2 id="推送远程库"><a href="#推送远程库" class="headerlink" title="推送远程库"></a>推送远程库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;远程地址&gt;</span><br><span class="line">git branch -M origin main</span><br><span class="line">git push -u origin &lt;main&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status  //查看状态</span><br><span class="line">git reset //可以撤回git add的内容</span><br><span class="line">git reset --soft HEAD^ //可以撤销git commit的内容，但是写的代码仍然保留</span><br></pre></td></tr></table></figure><p>如果commit注释写错了，只是想改一下注释，只需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p><h2 id="用于迁移"><a href="#用于迁移" class="headerlink" title="用于迁移"></a>用于迁移</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main //主分支和main分支合并</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git配置与仓库迁移</title>
      <link href="posts/2ad68004.html"/>
      <url>posts/2ad68004.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的账号不要了，上面的仓库需要迁移</p><p>于是….</p><p>就出现了很多问题，下面主要就记录下</p><h2 id="github加速"><a href="#github加速" class="headerlink" title="github加速"></a>github加速</h2><h3 id="有代理"><a href="#有代理" class="headerlink" title="有代理"></a>有代理</h3><p>我用的是v2rayn,查看端口号是<code>10808</code>,然后在<code>C:\Users\UserName\.gitconfig</code>文件添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">    proxy = http://127.0.0.1:10808</span><br><span class="line">[https]</span><br><span class="line">    proxy = http://127.0.0.1:10808</span><br></pre></td></tr></table></figure><p>，当然命令也可以，这里是直接打开文件添加，这是http的方式</p><p>ssh的方式是这样，打开<code>C:\Users\UserName\.ssh</code>,新建<code>config</code>文件填写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyCommand connect -S 127.0.0.1:10808 %h %p</span><br></pre></td></tr></table></figure><h3 id="无代理"><a href="#无代理" class="headerlink" title="无代理"></a>无代理</h3><p>我最先用的就是无代理，网上介绍代理全是ss,v2rayn我以为不可以，后来在一个<a href="https://www.youtube.com/watch?v=hKBhOXlQc4c&ab_channel=%E6%9D%9C%E8%BF%9C%E8%B6%85%E5%AE%98%E6%96%B9%E9%A2%91%E9%81%93">youtube</a>视频评论下残看到的原来端口号不一样</p><p>没有代理就在<code>C:\Windows\System32\drivers\etc</code>中host文件，写这两行</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009144812.png"></p><p>IP地址有时候会变，每次在这里<a href="https://www.ipaddress.com/%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%8B%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%9F%A5%E5%88%B0%E7%9A%84IP%E5%86%99%EF%BC%8C%E8%BF%99%E6%98%AFhttp%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86">https://www.ipaddress.com/查询一下，根据查到的IP写，这是http的方式，然后就可以了</a></p><p>实话实说，感觉利用梯子效果更好，这种改host文件的方法感觉没什么变化</p><h2 id="git的配置"><a href="#git的配置" class="headerlink" title="git的配置"></a>git的配置</h2><h3 id="添加key"><a href="#添加key" class="headerlink" title="添加key"></a>添加key</h3><p>清除之前的公钥和密钥文件，重新生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>一路回车</p><p>生成的公钥添加到github账号上面</p><p>然后验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 你的英文名     <span class="comment">#此英文名不需要跟GitHub账号保持一致</span></span><br><span class="line">git config --global user.email 你的邮箱      <span class="comment">#此邮箱不需要跟GitHub账号保持一致</span></span><br><span class="line">git config --global push.default matching</span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global core.editor <span class="string">&quot;vim&quot;</span></span><br></pre></td></tr></table></figure><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>因为我之前clone下的远程库有之前的地址，我要改一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:xxxxx.git</span><br></pre></td></tr></table></figure><p>master迁移到main分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main </span><br></pre></td></tr></table></figure><p>可以推送新的仓库了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main </span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/148110705?utm_source=qq&amp;utm_medium=social&amp;utm_oi=882705482219917312">https://zhuanlan.zhihu.com/p/148110705?utm_source=qq&amp;utm_medium=social&amp;utm_oi=882705482219917312</a></p><p><a href="https://zhuanlan.zhihu.com/p/48209762">https://zhuanlan.zhihu.com/p/48209762</a></p><p><a href="https://os.51cto.com/art/202009/627539.htm">https://os.51cto.com/art/202009/627539.htm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github图片，jsdelivr加速不能访问</title>
      <link href="posts/ed109295.html"/>
      <url>posts/ed109295.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>百度搜索关于cdn jsdelivr picgo github图床一堆，我这里就不重新写了，主要写遇到的问题，picgo配置好了，也可以正常上传，但是一旦用jsdelivr链接加速就是访问不了，百度上面连接都是这也写的</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn.jsdelivr.net/gh/用户名/仓库名</a></p></blockquote><p> 所以我最初写的也是<br><code>https://cdn.jsdelivr.net/gh/cloudvillager/cloud/img/20201009135759.png</code>看着没有问题，但是就是不对，一直访问是</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009140831.png"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>猜测是和github默认分支改成main的原因</p><p>github这个月开始，新建仓库都是<code>main</code>作为主分支，原来<code>master</code>已经不用了,可能不指定分支，默认访问的就是master</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在用jsdelivr加速的时候，指定一下main分支,格式是</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/%7BGithub%E7%94%A8%E6%88%B7%E5%90%8D%7D/%7BGithub%E4%BB%93%E5%BA%93%E5%90%8D%7D@%7B%E7%89%88%E6%9C%AC%E5%90%8D%7D/%7B%E4%BB%93%E5%BA%93%E4%B8%8B%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%7D">https://cdn.jsdelivr.net/gh/{Github用户名}/{Github仓库名}@{版本名}/{仓库下资源路径}</a></p></blockquote><p>例如： <a href="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009135759.png">https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009135759.png</a></p><p>就可以访问了</p><hr><p>参考：</p><blockquote><p><a href="https://www.dazhuanlan.com/2020/03/26/5e7c9c9250cb8/?__cf_chl_jschl_tk__=ef5bbb49c273a87d67426449fa2defbac0dfa6e7-1602224791-0-AYlVlW0tHM7FK5Qhf5aEkX6pJ7S5DHPQVpmNoGVMhVOnqXxWhsdpPA9auCrFSdnIkctDqUWuxA6FoL7wdAnceIQAR1wGVkhzYKXZPOhD9Yzu4AWYMr40e1N0qT05isp__Jxq01aqydGOL2FNQMogmatShYr3_IFtqmybF0eamnkLMq28fgCsy-DBU91oAt5PTSqqR7oZogV9J8-wNtpyWbH40mAjPVFsBckeQWHVOQNfAQCfnJeXUPTuPWFo50wshnJgyqHYmWrc0VtxXnz2jGaSi08cBy3BmVwnrmBPmKz7fdf1ZiuEElBT-9UmnsejAQ">https://www.dazhuanlan.com/2020/03/26/5e7c9c9250cb8/?__cf_chl_jschl_tk__=ef5bbb49c273a87d67426449fa2defbac0dfa6e7-1602224791-0-AYlVlW0tHM7FK5Qhf5aEkX6pJ7S5DHPQVpmNoGVMhVOnqXxWhsdpPA9auCrFSdnIkctDqUWuxA6FoL7wdAnceIQAR1wGVkhzYKXZPOhD9Yzu4AWYMr40e1N0qT05isp__Jxq01aqydGOL2FNQMogmatShYr3_IFtqmybF0eamnkLMq28fgCsy-DBU91oAt5PTSqqR7oZogV9J8-wNtpyWbH40mAjPVFsBckeQWHVOQNfAQCfnJeXUPTuPWFo50wshnJgyqHYmWrc0VtxXnz2jGaSi08cBy3BmVwnrmBPmKz7fdf1ZiuEElBT-9UmnsejAQ</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> jsdelivr </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 本地拒绝连接远程库问题 错误403</title>
      <link href="posts/9fcda5d2.html"/>
      <url>posts/9fcda5d2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下午本来想推送一下网站的<code>hexo d</code>然后一直报错</p><blockquote><p>On branch master<br>nothing to commit, working tree clean<br>remote: Permission to cloudvillager/cloudvillager.github.io.git denied to shuimqs.<br>fatal: unable to access ‘<a href="https://github.com/cloudvillager/cloudvillager.github.io.git/&#39;">https://github.com/cloudvillager/cloudvillager.github.io.git/&#39;</a>: The requested URL returned error: 403</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>报错信息大概意思就是，我之前登陆 了别的github账户，现在要推送到另一个账户，推不上去，拒绝访问，这不废话嘛，肯定推不了，找了好久，其实吧报错信息往谷歌里面一方，出来的就是答案，和我遇到的情况一样，<a href="https://stackoverflow.com/questions/47465644/github-remote-permission-denied%EF%BC%8C">https://stackoverflow.com/questions/47465644/github-remote-permission-denied，</a> 不过我看不懂，后来这里找到了答案， <a href="https://blog.csdn.net/klxh2009/article/details/76019742%EF%BC%8C">https://blog.csdn.net/klxh2009/article/details/76019742，</a> 然后看这不就是我之前看的那个链接吗，感觉一样，后来发现确实一样。。。</p><p>在看看下面评论都挺好的，再看看，之前那个国外网站是17年，这个csdn是19年发的。。英语太重要了。</p><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201007165000.png"></p><p>就是这里，普通凭据那里，找到<code>  git:https://github.com</code>删除就可以了，然后<code>hexo d</code>就可以推送成功了</p><p>参考：</p><blockquote><p><a href="https://blog.csdn.net/klxh2009/article/details/76019742">https://blog.csdn.net/klxh2009/article/details/76019742</a><br><a href="https://stackoverflow.com/questions/47465644/github-remote-permission-denied">https://stackoverflow.com/questions/47465644/github-remote-permission-denied</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="posts/d87f7e0c.html"/>
      <url>posts/d87f7e0c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>docker adf</p><blockquote><p>afd fasd</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>test</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
