<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>日期和时间对象</title>
      <link href="posts/2af9b407.html"/>
      <url>posts/2af9b407.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h1><h2 id="Date类概述"><a href="#Date类概述" class="headerlink" title="Date类概述"></a>Date类概述</h2><p>类 Date 表示特定的瞬间，精确到毫秒。</p><blockquote><p>时间和日期类<br>  java.util.Date</p><p>毫秒概念: 1000毫秒=1秒</p><p>毫秒的0点:<br>   System.currentTimeMillis() 返回值long类型参数<br>   获取当前日期的毫秒值   3742769374405<br>   时间原点： 公元1970年1月1日,午夜0:00:00   毫秒值就是0</p><p>这是个很重要的概念，因为时间和日期的计算,必须依赖毫秒值<br>  XXX-XXX-XX = 毫秒</p></blockquote><p>继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111164609.png"></p><p>空参构造器获取的时间是操作系统中的当前时间和日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建日期对象，把当前的毫秒值转成日期对象</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">1607616000000L</span>);</span><br><span class="line">System.out.println(date);</span><br><span class="line"><span class="comment">//打印结果：Fri Dec 11 00:00:00 CST 2020  </span></span><br></pre></td></tr></table></figure><p>可是将毫秒值转成日期后，输出的格式不利于我们阅读，继续查阅API，Date中有getYear、getMouth等方法，可以他们已经过时，继续往下查阅，看到了toString方法。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111164704.png"></p><p>点开toString()方法查阅，原来上面打印的date对象就是默认调用了这个toString方法，并且在这个方法下面还有让我们参见toLocaleString方法，点进去，这个方法又过时了，从 JDK 1.1 开始，由 DateFormat.format(Date date) 取代。 </p><p>既然这个方法被DateFormat.format(Date date) 取代，那么就要去查阅DateFormat类。</p><h2 id="Date类常用方法"><a href="#Date类常用方法" class="headerlink" title="Date类常用方法"></a>Date类常用方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111164852.png"></p><p>把日期对象转换成对应的时间毫秒值</p><p>还有一个方法是<code>setTime(long )</code></p><p>这是用于，毫秒值转成日期对象，或者用Date类的构造器也可以实现</p><h1 id="DateFormat"><a href="#DateFormat" class="headerlink" title="DateFormat"></a>DateFormat</h1><h2 id="DateFormat类概述"><a href="#DateFormat类概述" class="headerlink" title="DateFormat类概述"></a>DateFormat类概述</h2><p>这个类在test包中，DateFormat 是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 <font color=red><strong>SimpleDateFormat类</strong></font>）允许进行格式化（也就是日期 -&gt; 文本）、解析（文本-&gt; 日期）和标准化。</p><p>我们通过这个类可以帮我们完成日期和文本之间的转换。</p><p>继续阅读API，DateFormat 可帮助进行格式化并解析任何语言环境的日期。对于月、星期，甚至日历格式（阴历和阳历），其代码可完全与语言环境的约定无关。</p><blockquote><p>这是api中的介绍复制过来的，说白了，就是用于说自定义显示的时间格式的，直接得到的日期对象，不利于阅读，dateformat是个抽象类，里面有具体方法也有抽象方法，实际开发中使用的是它的子类SimpleDateFormat类，来实现需要的功能</p></blockquote><h2 id="日期格式"><a href="#日期格式" class="headerlink" title="日期格式"></a>日期格式</h2><p>要格式化一个当前语言环境下的日期也就是（日期 -&gt; 文本），要通过下面的方法来完成。DateFormat是抽象类，我们需要使用其子类SimpleDateFormat来创建对象。</p><p>关于日期的格式怎么写，api中也有具体的模式，可以查看</p><ul><li><p>构造方法</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111172901.png"></p></li><li><p>DateFormat类方法</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111172919.png"></p></li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何对日期格式化</span></span><br><span class="line"><span class="comment"> *  步骤:</span></span><br><span class="line"><span class="comment"> *    1. 创建SimpleDateFormat对象</span></span><br><span class="line"><span class="comment"> *       在类构造方法中,写入字符串的日期格式 (自己定义)</span></span><br><span class="line"><span class="comment"> *    2. SimpleDateFormat调用方法format对日期进行格式化</span></span><br><span class="line"><span class="comment"> *         String format(Date date) 传递日期对象,返回字符串</span></span><br><span class="line"><span class="comment"> *    日期模式:</span></span><br><span class="line"><span class="comment"> *       yyyy    年份</span></span><br><span class="line"><span class="comment"> *       MM      月份</span></span><br><span class="line"><span class="comment"> *       dd      月中的天数</span></span><br><span class="line"><span class="comment"> *       HH       0-23小时</span></span><br><span class="line"><span class="comment"> *       mm      小时中的分钟</span></span><br><span class="line"><span class="comment"> *       ss      秒</span></span><br><span class="line"><span class="comment"> *       yyyy年MM月dd日 HH点mm分钟ss秒  汉字修改,: -  字母表示的每个字段不可以随便写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日 HH点mm分钟ss秒&quot;</span>);</span><br><span class="line">String date = sdf.format(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DateFormat类常用方法"><a href="#DateFormat类常用方法" class="headerlink" title="DateFormat类常用方法"></a>DateFormat类常用方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111174553.png"></p><ul><li>format方法，用来将Date对象转换成String</li><li>parse方法，用来将String转换成Date（转换时，该String要符合指定格式，否则不能转换）。</li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把Date对象转换成String</span></span><br><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">1607616000000L</span>);<span class="comment">//Fri Dec 11 00:00:00 CST 2020</span></span><br><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">String str = df.format(date);<span class="comment">//str中的内容为2020年12月11日</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把String转换成Date对象</span></span><br><span class="line">String str = ”<span class="number">2020</span>年<span class="number">12</span>月<span class="number">11</span>日”;</span><br><span class="line">DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy年MM月dd日&quot;</span>);</span><br><span class="line">Date date = df.parse( str );<span class="comment">//Date对象中的内容为Fri Dec 11 00:00:00 CST 2020</span></span><br></pre></td></tr></table></figure><h1 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h1><h2 id="Calendar类概念"><a href="#Calendar类概念" class="headerlink" title="Calendar类概念"></a>Calendar类概念</h2><p>Calendar是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</p><p>Calendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，将语言敏感内容处理好，再返回子类对象</p><blockquote><p>日历类 java.util.Calendar</p><p>他是个抽象类，我们如果要使用它，就得用他的子类对象</p><p>但是，它有个静态方法，getInstance() 直接返回了子类的对象，所以不需要直接new 子类的对象,可以通过静态方法直接获取</p></blockquote><ul><li><p>Calendar类静态方法</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111175749.png"></p><p>Calendar c = Calendar.getInstance(); //返回当前时间</p></li></ul><h2 id="Calendar类常用方法"><a href="#Calendar类常用方法" class="headerlink" title="Calendar类常用方法"></a>Calendar类常用方法</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111221317.png"></p><ul><li><p>calendar类的get方法 </p><p>获取日历字段的值 int get(int) 参数int,获取的哪个日历字段 返回值,就表示日历字段的具体数值</p><ul><li>YEAR 年</li><li>MONTH 月，从0开始算起，最大11；0代表1月，11代表12月。</li><li>DATE 天</li><li>HOUR 时</li><li>MINUTE分</li><li>SECOND秒</li></ul><p>代码演示：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">funtion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calendar c = Calendar.getInstance();</span><br><span class="line">    <span class="comment">// 获取年份</span></span><br><span class="line">    <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">    <span class="comment">// 获取月份</span></span><br><span class="line">    <span class="keyword">int</span> month = c.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取天数</span></span><br><span class="line">    <span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Calendar类的set方法 </p><p>设置日历 set(int field,int value) field 设置的是哪个日历字段 value 设置后的具体数值</p><p>set(int year,int month,int day) 传递3个整数的年,月,日</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calendar c = Calendar.getInstance();</span><br><span class="line">    <span class="comment">// 设置,月份,设置到10月分</span></span><br><span class="line">    <span class="comment">// c.set(Calendar.MONTH, 9);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置年,月,日</span></span><br><span class="line">    c.set(<span class="number">2099</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取年份</span></span><br><span class="line">    <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">    <span class="comment">// 获取月份</span></span><br><span class="line">    <span class="keyword">int</span> month = c.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取天数</span></span><br><span class="line">    <span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Calendar类方法add </p><p>日历的偏移量，可以指定一个日历中的字段</p><p>进行整数的偏移 add(int field, int value)</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calendar c = Calendar.getInstance();</span><br><span class="line">    <span class="comment">// 让日历中的天数,向后偏移280天</span></span><br><span class="line">    c.add(Calendar.DAY_OF_MONTH, -<span class="number">280</span>);</span><br><span class="line">    <span class="comment">// 获取年份</span></span><br><span class="line">    <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">    <span class="comment">// 获取月份</span></span><br><span class="line">    <span class="keyword">int</span> month = c.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取天数</span></span><br><span class="line">    <span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Calendar类的方法getTime()</p><p>把日历对象,转成Date日期对象</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Calendar c = Calendar.getInstance();</span><br><span class="line">    Date date = c.getTime();</span><br><span class="line">    System.out.println(date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="日期相关类练习"><a href="#日期相关类练习" class="headerlink" title="日期相关类练习"></a>日期相关类练习</h1><ol><li><p>求出自己已经出生多少天</p><p>思路：</p><ul><li>获取当前时间对应的天数</li><li>获取自己出生日期对应的天数</li><li>两个时间相减（当前时间天数 – 出生日期天数）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;请输入出生日期 格式 YYYY-MM-dd&quot;</span>);</span><br><span class="line"><span class="comment">//获取出生日期,键盘输入</span></span><br><span class="line">String birthdayString = <span class="keyword">new</span> Scanner(System.in).next();</span><br><span class="line"><span class="comment">//将字符串日期,转成Date对象</span></span><br><span class="line"><span class="comment">//创建SimpleDateFormat对象,写日期模式</span></span><br><span class="line">SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="comment">//调用方法parse,字符串转成日期对象</span></span><br><span class="line">Date birthdayDate = sdf.parse(birthdayString);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取今天的日期对象</span></span><br><span class="line">Date todayDate = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个日期转成毫秒值,Date类的方法getTime</span></span><br><span class="line"><span class="keyword">long</span> birthdaySecond = birthdayDate.getTime();</span><br><span class="line"><span class="keyword">long</span> todaySecond = todayDate.getTime();</span><br><span class="line"><span class="keyword">long</span> secone = todaySecond-birthdaySecond;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(secone &lt; <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;还没出生呢&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(secone/<span class="number">1000</span>/<span class="number">60</span>/<span class="number">60</span>/<span class="number">24</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种解法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Calendar my = Calendar.getInstance();</span><br><span class="line">Calendar c = Calendar.getInstance();</span><br><span class="line"><span class="comment">//设置出生年月日 1995-05-10</span></span><br><span class="line">my.set(Calendar.YEAR, <span class="number">1995</span>);</span><br><span class="line">my.set(Calendar.MONTH, <span class="number">4</span>);</span><br><span class="line">my.set(Calendar.DATE, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//获取时间中的天数</span></span><br><span class="line"><span class="keyword">int</span> day = c.get(Calendar.DATE);</span><br><span class="line"><span class="keyword">int</span> myDay = my.get(Calendar.DATE);</span><br><span class="line">System.out.println(day - myDay);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>闰年计算</p><p>高级的算法: 日历设置到指定年份的3月1日,add向前偏移1天,如果获取的天数是29，那么它就是闰年</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Calendar c = Calendar.getInstance();</span><br><span class="line">    <span class="comment">//将日历,设置到指定年的3月1日</span></span><br><span class="line">    c.set(<span class="number">2088</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//日历add方法,向前偏移1天</span></span><br><span class="line">    c.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//get方法获取天数</span></span><br><span class="line">    <span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(day);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 日期对象 </tag>
            
            <tag> Date </tag>
            
            <tag> DateFormat </tag>
            
            <tag> Calendar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="posts/2f57a694.html"/>
      <url>posts/2f57a694.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>正则表达式</strong>（英语：Regular Expression，在代码中常简写为regex）。</p><p>正则表达式是一个字符串，使用单个字符串来描述、用来定义匹配规则，匹配一系列符合某个句法规则的字符串。在开发中，正则表达式通常被用来检索、替换那些符合某个规则的文本。</p><hr><p>举个例子</p><p>一个qq号码：12345678</p><p>检查QQ是否是合法的存在（全是数字，位数5-10，开头不是0）</p><p>满足一定规则：表示可以是一个字符串表示规则（正则表达式）</p><p>QQ号码也是字符串，规则也是一个字符串，进行匹配检查</p><p>那么这个正则表达式就可以写成<code>[1-9][0-9](4,9)</code>（第一位是1-9的数字，第二位开始可以出现0 了，第二位开始，最少出现四次，最多不能出现9次）</p><h1 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h1><p>参照帮助文档，在Pattern类中有正则表达式的的规则定义，正则表达式中明确区分大小写字母。我们来学习语法规则。</p><p>正则表达式的语法规则：</p>  <br/><p><font color=red><strong>字符：x</strong></font></p><p><font color=red>含义：代表的是字符x</font></p><p>例如：匹配规则为 “a”，那么需要匹配的字符串内容就是 ”a”</p>  <br/><p><font color=red><strong>字符：\\</strong></font></p><p><font color=red>含义：代表的是反斜线字符\‘&#39;</font></p><p>例如：匹配规则为”\\&quot; <strong>，</strong>那么需要匹配的字符串内容就是 ”\”</p>  <br/><p><font color=blue><strong>字符：</strong>\t</font></p><p><font color=blue>含义：制表符</font></p><p>例如：匹配规则为”\t” ，那么对应的效果就是产生一个制表符的空间  </p><br/><p><font color=red><strong>字符：\n</strong></font></p><p><font color=red>含义：换行符</font></p><p>例如：匹配规则为”\n”，那么对应的效果就是换行,光标在原有位置的下一行  </p><br/><p><font color=red><strong>字符：\r</strong></font></p><p><font color=red>含义：回车符</font></p><p>例如：匹配规则为”\r” ，那么对应的效果就是回车后的效果,光标来到下一行行首  </p><br/><p><font color=blue><strong>字符类：[abc]</strong></font></p><p><font color=blue>含义：代表的是字符a、b 或 c</font></p><p>例如：匹配规则为”[abc]” ，那么需要匹配的内容就是字符a，或者字符b，或字符c的一个 </p> <br/><p><font color=blue><strong>字符类：<code>[^abc]</code></strong></font></p><p><font color=blue>含义：代表的是除了 a、b 或 c以外的任何字符</font></p><p>例如：匹配规则为<code>[^abc]</code>，那么需要匹配的内容就是不是字符a，或者不是字符b，或不是字符c的任意一个字符  </p><br/><p><font color=blue><strong>字符类：[a-zA-Z]</strong></font></p><p><font color=blue>含义：代表的是a 到 z 或 A 到 Z，两头的字母包括在内</font></p><p>例如：匹配规则为”[a-zA-Z]”，那么需要匹配的是一个大写或者小写字母</p> <br/><p><font color=blue><strong>字符类：[0-9]</strong></font></p><p><font color=blue>含义：代表的是 0到9数字，两头的数字包括在内</font></p><p>例如：匹配规则为”[0-9]”，那么需要匹配的是一个数字</p> <br/><p><font color=blue><strong>字符类：[a-zA-Z_0-9]</strong></font></p><p><font color=blue>含义：代表的字母或者数字或者下划线(即单词字符)</font></p><p>例如：匹配规则为” [a-zA-Z_0-9] “，那么需要匹配的是一个字母或者是一个数字或一个下滑线</p> <br /><p><font color=blue><strong>预定义字符类：.</strong></font></p><p><font color=blue>含义：代表的是任何字符</font></p><p>例如：匹配规则为” . “，那么需要匹配的是一个任意字符。如果，就想使用 . 的话，使用匹配规则”\.”来实现</p>  <br/><p><font color=blue><strong>预定义字符类：\d</strong></font></p><p><font color=blue>含义：代表的是 0到9数字，两头的数字包括在内，相当于[0-9]</font></p><p>例如：匹配规则为”\d “，那么需要匹配的是一个数字</p>  <br/><p><font color=blue><strong>预定义字符类：\w</strong></font></p><p><font color=blue>含义：代表的字母或者数字或者下划线(即单词字符)，相当于**[a-zA-Z_0-9]**</font></p><p>例如：匹配规则为”\w “，，那么需要匹配的是一个字母或者是一个数字或一个下滑线</p>  <br/><p><font color=red><strong>边界匹配器：^</strong></font></p><p><font color=red>含义：代表的是行的开头</font></p><p>例如：匹配规则为<code>^[abc][0-9]$</code> ，那么需要匹配的内容从[abc]这个位置开始, 相当于左双引号</p>  <br/><p><font color=red><strong>边界匹配器：$</strong></font></p><p><font color=red>含义：代表的是行的结尾</font></p><p>例如：匹配规则为<code>^[abc][0-9]$</code> ，那么需要匹配的内容以[0-9]这个结束, 相当于右双引号</p>  <br/><p><font color=red><strong>边界匹配器：\b</strong></font></p><p><font color=red>含义：代表的是单词边界</font></p><p>例如：匹配规则为”\b[abc]\b” ，那么代表的是字母a或b或c的左右两边需要的是非单词字符([a-zA-Z_0-9])</p>  <br/><p><font color=red><strong>数量词：X?</strong></font></p><p><font color=red>含义：代表的是X出现一次或一次也没有</font></p><p>例如：匹配规则为”a?”，那么需要匹配的内容是一个字符a，或者一个a都没有</p>  <br/><p><font color=red><strong>数量词：X*</strong></font></p><p><font color=red>含义：代表的是X出现零次或多次</font></p><p>例如：匹配规则为”a*“ ，那么需要匹配的内容是多个字符a，或者一个a都没有</p>  <br/><p><font color=blue><strong>数量词：X+</strong></font></p><p><font color=blue>含义：代表的是X出现一次或多次</font></p><p>例如：匹配规则为”a+”，那么需要匹配的内容是多个字符a，或者一个a</p>  <br/><p><font color=blue><strong>数量词：X{n}</strong></font></p><p><font color=blue>含义：代表的是X出现恰好 n 次</font></p><p>例如：匹配规则为”a{5}”，那么需要匹配的内容是5个字符a</p>  <br/><p><font color=blue><strong>数量词：X{n,}</strong></font></p><p><font color=blue>含义：代表的是X出现至少 n 次</font></p><p>例如：匹配规则为”a{5, }”，那么需要匹配的内容是最少有5个字符a</p>  <br/><p><font color=blue><strong>数量词：X{n,m}</strong></font></p><p><font color=blue>含义：代表的是X出现至少 n 次，但是不超过 m 次</font></p><p>例如：匹配规则为”a{5,8**}”**，那么需要匹配的内容是有5个字符a 到 8个字符a之间</p><h1 id="规则匹配练习"><a href="#规则匹配练习" class="headerlink" title="规则匹配练习"></a>规则匹配练习</h1><p>请写出满足如下匹配规则的字符串:</p><p>规则：”[0-9]{6,12}”</p><p>该规则需要匹配的内容是：<strong>长度为6位到12位的数字。</strong></p><p>如：使用数据”123456789”进行匹配结果为true；</p><p>使用数据”12345”进行匹配结果为false。</p><br /><p>规则：<code>&quot;1[34578][0-9]&#123;9&#125;&quot;</code></p><p>该规则需要匹配的内容是：<strong>11位的手机号码，第1位为1，第2位为3、4、5、7、8中的一个，后面9位为0到9之间的任意数字。</strong></p><p>如：使用数据”12345678901”进行匹配结果为false；</p><p>使用数据”13312345678”进行匹配结果为true。</p><br /><p>规则：”a*b”</p><p>该规则需要匹配的内容是：<strong>在多个a或零个a后面有个b；b必须为最后一个字符。</strong><br>如：使用数据”aaaaab”进行匹配结果为true；<br>使用数据”abc”进行匹配结果为false。</p><h1 id="字符串类中涉及正则表达式的常用方法"><a href="#字符串类中涉及正则表达式的常用方法" class="headerlink" title="字符串类中涉及正则表达式的常用方法"></a>字符串类中涉及正则表达式的常用方法</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111155743.png"></p><p>实现正则规则和字符串进行匹配,使用到字符串类的方法<br>String类三个和正则表达式相关的方法</p><ol><li><p>boolean matches(String 正则的规则)<br>“abc”.matches(“[a]”)  匹配成功返回true</p></li><li><p>String[] split(String 正则的规则)<br>“abc”.split(“a”) 使用规则将字符串进行切割</p></li><li><p>String replaceAll( String 正则规则,String 字符串)<br>“abc0123”.repalceAll(“[\d]”,”#”)<br>安装正则的规则,替换字符串</p></li></ol><hr><p>举例</p><ul><li><p>public boolean <strong>matches</strong>(String regex) //判断字符串是否匹配给定的规则</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  检查QQ号码是否合法</span></span><br><span class="line"><span class="comment"> *  0不能开头,全数字, 位数5,10位</span></span><br><span class="line"><span class="comment"> *  123456 </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkQQ</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String QQ = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line">    <span class="comment">//检查QQ号码和规则是否匹配,String类的方法matches</span></span><br><span class="line">    <span class="keyword">boolean</span> b = QQ.matches(<span class="string">&quot;[1-9][0-9]&#123;4,9&#125;&quot;</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中，[0-9]可以写成<code>\d</code>的形式，但是直接这样写会报错<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201111160706.png"></p><p>  <code>\</code>是转义字符，应该在加一个<code>\</code>,即<code>boolean b = QQ.matches(&quot;[1-9][\\d]&#123;4,9&#125;&quot;);</code></p>  <br />  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  检查手机号码是否合法</span></span><br><span class="line"><span class="comment"> *  1开头 可以是34578  0-9 位数固定11位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkTel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String telNumber = <span class="string">&quot;1335128005&quot;</span>;</span><br><span class="line">    <span class="comment">//String类的方法matches</span></span><br><span class="line">    <span class="keyword">boolean</span> b = telNumber.matches(<span class="string">&quot;1[34857][\\d]&#123;9&#125;&quot;</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  其中，<code>[34857]</code>这里面的数字是没有顺序规则的</p>  <br /></li><li><p>public String[] <strong>split</strong>(String regex)  //根据给定正则表达式的匹配规则，拆分此字符串</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  String类方法split对字符串进行切割</span></span><br><span class="line"><span class="comment"> *  12-25-36-98  按照-对字符串进行切割</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;12-25-36-98&quot;</span>;</span><br><span class="line"><span class="comment">//按照-对字符串进行切割,String类方法split</span></span><br><span class="line">String[] strArr = str.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;数组的长度&quot;</span>+strArr.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strArr.length ; i++)&#123;</span><br><span class="line">System.out.println(strArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * String类方法split对字符串进行切割</span></span><br><span class="line"><span class="comment"> * 18 22 40 65 按照空格切割字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;18    22     40          65&quot;</span>;</span><br><span class="line">String[] strArr = str.split(<span class="string">&quot; +&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;数组的长度&quot;</span>+strArr.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strArr.length ; i++)&#123;</span><br><span class="line">System.out.println(strArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * String类方法split对字符串进行切割</span></span><br><span class="line"><span class="comment"> * 192.168.105.27 按照 点切割字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">String ip = <span class="string">&quot;192.168.105.27&quot;</span>;</span><br><span class="line">String[] strArr = ip.split(<span class="string">&quot;\\.&quot;</span>); <span class="comment">//如果直接写. 的话，.会和字符串中的任意元素匹配，切不下来，所以需要转义字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;数组的长度&quot;</span>+strArr.length);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; strArr.length ; i++)&#123;</span><br><span class="line">System.out.println(strArr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <br /></li><li><p>public String <strong>replaceAll</strong>(String regex,String replacement)  //将符合规则的字符串内容，全部替换为新字符串</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * &quot;Hello12345World6789012&quot;将所有数字替换掉</span></span><br><span class="line"><span class="comment"> * String类方法replaceAll(正则规则,替换后的新字符串)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">replaceAll_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">String str = <span class="string">&quot;Hello12345World6789012&quot;</span>;</span><br><span class="line">str = str.replaceAll(<span class="string">&quot;[\\d]+&quot;</span>, <span class="string">&quot;#&quot;</span>);</span><br><span class="line">System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ul><li><p>匹配正确的数字</p><p>匹配规则：</p><p>  匹配正整数：”\d+”</p><p>  匹配正小数：”\d+\.\d+” </p><p>  匹配负整数：”-\d+”</p><p>  匹配负小数：”-\d+\.\d+”</p><p>  匹配保留两位小数的正数：”\d+\.\d{2}”</p><p>  匹配保留1-3位小数的正数：”\d+\.\d{1,3}”</p></li><li><p>匹配合法的邮箱</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  检查邮件地址是否合法</span></span><br><span class="line"><span class="comment"> *  规则:</span></span><br><span class="line"><span class="comment"> *   1234567@qq.com</span></span><br><span class="line"><span class="comment"> *   mym_ail@sina.com</span></span><br><span class="line"><span class="comment"> *   nimail@163.com</span></span><br><span class="line"><span class="comment"> *   wodemail@yahoo.com.cn    </span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *   @: 前  数字字母_ 个数不能少于1个</span></span><br><span class="line"><span class="comment"> *   @: 后  数字字母     个数不能少于1个</span></span><br><span class="line"><span class="comment"> *   .: 后面 字母 </span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">String email =<span class="string">&quot;abc123@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = email.matches(<span class="string">&quot;[a-zA-Z0-9_]+@[0-9a-z]+(\\.[a-z]+)+&quot;</span>);</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串缓冲区</title>
      <link href="posts/b25195bc.html"/>
      <url>posts/b25195bc.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h1><p>在学习String类时，API中说<font color=red>字符串缓冲区支持可变的字符串</font>，什么是字符串缓冲区呢？接下来我们来研究下字符串缓冲区。</p><p>查阅StringBuffer的API，StringBuffer又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。</p><p>原来StringBuffer是个字符串的缓冲区，即就是它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。</p><hr><p>说白了，string类一旦创建不可改变，容易照成资源浪费，所以就开发了StringBuffer类，用于解决这个问题</p><p>Stringbuffer字符串的缓存区对象，用于提高字符串的操作对象，内部采用了可变数组的实现，类内部定义了数组，这个数组没有final</p><p>这里再举个例子，如果我们需要连接两个字符串，<code>“123”+“adf”</code></p><p>用string类的话，在内存中，“123”是一个数组，“adf”又是一个数组，两个一连接又是一个新的数组，这时候在内存中就会有三个数组</p><p>如果用stringbuffer类呢，在内存中始终只有一个数组，如果一个数组装满了，它会自动扩容，这个类的数组查看源码可以知道，默认容量是16</p><h1 id="StringBuffer的方法使用"><a href="#StringBuffer的方法使用" class="headerlink" title="StringBuffer的方法使用"></a>StringBuffer的方法使用</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110224839.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类的方法</span></span><br><span class="line"><span class="comment"> *   String toString() 继承Object,重写toString()</span></span><br><span class="line"><span class="comment"> *   将缓冲区中的所有字符,变成字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_5</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line">buffer.append(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将可变的字符串缓冲区对象,变成了不可变String对象</span></span><br><span class="line">String s = buffer.toString();</span><br><span class="line">System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类的方法</span></span><br><span class="line"><span class="comment"> *    reverse() 将缓冲区中的字符反转</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_4</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"></span><br><span class="line">buffer.reverse();</span><br><span class="line"></span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类方法</span></span><br><span class="line"><span class="comment"> *    replace(int start,int end, String str)</span></span><br><span class="line"><span class="comment"> *    将指定的索引范围内的所有字符,替换成新的字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_3</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"></span><br><span class="line">buffer.replace(<span class="number">1</span>, <span class="number">4</span>, <span class="string">&quot;Q&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类方法 insert</span></span><br><span class="line"><span class="comment"> *    insert(int index, 任意类型)</span></span><br><span class="line"><span class="comment"> *  将任意类型数据,插入到缓冲区的指定索引上</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_2</span><span class="params">()</span></span>&#123;</span><br><span class="line"> StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"> buffer.append(<span class="string">&quot;abcdef&quot;</span>); </span><br><span class="line"> </span><br><span class="line"> buffer.insert(<span class="number">3</span>, <span class="number">9.5</span>);</span><br><span class="line"> System.out.println(buffer);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * StringBuffer类方法</span></span><br><span class="line"><span class="comment"> *   delete(int start,int end) 删除缓冲区中字符</span></span><br><span class="line"><span class="comment"> *   开始索引包含,结尾索引不包含</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;abcdef&quot;</span>);</span><br><span class="line"></span><br><span class="line">buffer.delete(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  StringBuffer类方法</span></span><br><span class="line"><span class="comment"> *   StringBuffer append, 将任意类型的数据,添加缓冲区</span></span><br><span class="line"><span class="comment"> *   append 返回值,写return this</span></span><br><span class="line"><span class="comment"> *   调用者是谁,返回值就是谁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">//调用StringBuffer方法append向缓冲区追加内容</span></span><br><span class="line">buffer.append(<span class="number">6</span>).append(<span class="keyword">false</span>).append(<span class="string">&#x27;a&#x27;</span>).append(<span class="number">1.5</span>);</span><br><span class="line">System.out.println(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：append、delete、insert、replace、reverse方法调用后，返回值都是当前对象自己，所以说，StringBuffer它可以改变字符序列的长度和内容。</p><h1 id="对象的方法链式调用"><a href="#对象的方法链式调用" class="headerlink" title="对象的方法链式调用"></a>对象的方法链式调用</h1><p>在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。这种时候，我们就可以把代码现在一起，如append方法一样，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个字符串缓冲区对象。用于存储数据。</span></span><br><span class="line">StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="comment">//添加数据。不断的添加数据后，要对缓冲区的最后的数据进行操作，必须转成字符串才可以。</span></span><br><span class="line">String str = sb.append(<span class="keyword">true</span>).append(<span class="string">&quot;hehe&quot;</span>).toString();</span><br></pre></td></tr></table></figure><h1 id="StringBuffer练习"><a href="#StringBuffer练习" class="headerlink" title="StringBuffer练习"></a>StringBuffer练习</h1><p>int[] arr = {34,12,89,68};将一个int[]中元素转成字符串 格式 [34,12,89,68]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* int[] arr = &#123;34,12,89,68&#125;;将一个int[]中元素转成字符串 </span></span><br><span class="line"><span class="comment">* 格式 [34,12,89,68]</span></span><br><span class="line"><span class="comment">* 以前的思路是用string</span></span><br><span class="line"><span class="comment">* String s = &quot;[&quot;</span></span><br><span class="line"><span class="comment">* 数组遍历</span></span><br><span class="line"><span class="comment">*   s+= arr[i];</span></span><br><span class="line"><span class="comment">*  s+&quot;]&quot;</span></span><br><span class="line"><span class="comment">*  现在用StringBuffer实现,可以节约内存空间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line"><span class="comment">//创建字符串缓冲区</span></span><br><span class="line">StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">buffer.append(<span class="string">&quot;[&quot;</span>);</span><br><span class="line"><span class="comment">//数组遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arr.length;i++)&#123;</span><br><span class="line"><span class="comment">//判断是不是数组的最后一个元素</span></span><br><span class="line"><span class="keyword">if</span>(i == arr.length-<span class="number">1</span>)&#123;</span><br><span class="line">buffer.append(arr[i]).append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">buffer.append(arr[i]).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> buffer.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>无论多少数据，数据是什么类型都不重要，只要最终变成字符串就可以使用StringBuffer这个容器</p><h1 id="StringBuilder类"><a href="#StringBuilder类" class="headerlink" title="StringBuilder类"></a>StringBuilder类</h1><p>查阅API发现还有一个StringBuilder类，它也是字符串缓冲区，StringBuilder与它和StringBuffer的有什么不同呢？</p><p>我们阅读StringBuilder的API说明发现，它也是一个可变的字符序列。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。</p><blockquote><p>两个类的方法完全一样，就是一个安全一个不安全的区别，stringbuffer线程安全，stringbuilder线程不安全，不同步就是不安全，安全意味着是速度慢</p></blockquote><p>目前，我们还没有涉及到线程与同步，知道结论StringBuilder比StringBuffer快即可。为什么快，我们会在学习线程时讲解。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> String </tag>
            
            <tag> StringBuffer </tag>
            
            <tag> StringBuilder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String类</title>
      <link href="posts/5cf35ca9.html"/>
      <url>posts/5cf35ca9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>查阅API中的String类的描述，发现String 类代表字符串。Java 程序中的所有字符串字面值（如 “abc” ）都作为此类的实例实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//演示字符串</span></span><br><span class="line">String str  = <span class="string">&quot;shuigwh&quot;</span>;</span><br><span class="line">str = <span class="string">&quot;水过无痕&quot;</span>;</span><br></pre></td></tr></table></figure><p>继续查阅API发现说字符串是常量；它们的值在创建之后不能更改</p><p>说明<font color=red>字符串是一个常量，一旦创建，不能改变</font>&gt;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;itcast&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str = <span class="string">&quot;itheima&quot;</span>;</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109133116.png"></p><p>既然不能改变，这又是怎么回事？</p><p>分析：</p><p>字符串本身是一个对象，运行的时候，方法进栈，对象在堆内存</p><p>这里说一下，字符串的本质，是一个字符的数组 “itcast” = char[] = {‘i’, ‘t’, ‘c’, ‘a’, ‘s’, ‘t’}</p><p>我们查看String类的源码，会发现有一行<code>private final char value[];</code>这也说明字符串就是个数组,final也说明一旦数组建立，此对象终身不变</p><p>最开始，main方法压栈运行，</p><p>这里说下堆内存其实有个小区域是存放常量的，这个区域叫常量池，他是专门用来存放常量的，常量池里面有多少个常量呢？这个不能具体回答，因为常量可以有无限个，但是字符串常量，在常量池中的是以字符型体现的，因为字符是有个数的，一共52个（大小写加起来）</p><p>当要建立<code>itcast</code>的时候，我们可以从常量池中拿字符来用，当<code>itcast</code>创建后，在堆内存中就会出现一块叫’itcast’的对象，而且 是被final的，不能被，引用数据类型变量str指向这块空间，见下图</p><p>当程序继续往下执行的时候，<code>str = &quot;itheima&quot;;</code>他不是改原来对象的数据，他是在堆内存中重新再次创建一个数组，叫”itheima”,然后引用变量str指向这块区域</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109232213.png"></p><p>所以，最开始的程序运行结果，最后的str输出的是“itheima”，<font color=red>不是对象变了，而是变量的指向的地址变了</font></p><hr><p>继续查API发现，字符串有大量的重载的构造方法。通过String类的构造方法可以完成字符串对象的创建,那么，通过使用双引号的方式创建对象与new的方式创建对象，有什么不同呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">String str2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str1);</span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//引用数据类型，比较对象的地址 false</span></span><br><span class="line">System.out.println(str1.equals(str2));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>分析：</p><p>程序开始执行，运行<code>String str1 = new String(&quot;abc&quot;);</code>这句话，其实是同时创建了两个对象，当new 的时候，堆内存会创建一个叫String类的对象，<code>abc</code>这个之前也说过，他也是对象，本质是char类型的数组，虚拟机会另外开辟一块空间存放<code>abc</code>的char数组,String类的对象其实保存的是char数组的地址，然后str1指向String类的地址，见下图：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109233909.png"></p><p>程序继续往下运行，<code>String str2 = &quot;abc&quot;;</code>按照之前学的内容，虚拟机肯定会在开辟一个空间，用于存放这个char数组，</p><p>但是不是，虚拟机在运行的时候会做一个优化，检查内存中有没有”abc”,如果有，就直接指向这个区域</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109234334.png"></p><p>所以str1==str2,比较的是地址，地址不一样，所以是false</p><p>至于str1.equals(str2)为什么是false，原因很简单，是因为String类继承了object类，重写了equals方法，建立了字符串自己的比较方式，比较字符串中的每个字符是否相同</p><h1 id="String类构造方法"><a href="#String类构造方法" class="headerlink" title="String类构造方法"></a>String类构造方法</h1><p>构造方法是用来完成String对象的创建，下图中给出了一部分构造方法需要在API中找到，并能够使用下列构造方法创建对象。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109234759.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(); <span class="comment">//创建String对象，字符串中没有内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(bys); <span class="comment">// 创建String对象，把数组元素作为字符串的内容  s2==&quot;abcd&quot;</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(bys, <span class="number">1</span>, <span class="number">3</span>); <span class="comment">//创建String对象，把一部分数组元素作为字符串的内容，参数offset为数组元素的起始索引位置，参数length为要几个元素   s2==&quot;bcd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;’a’,’b’,’c’,’d’,’e’&#125;;</span><br><span class="line">String s4 = <span class="keyword">new</span> String(chs); <span class="comment">//创建String对象，把数组元素作为字符串的内容  s4==&quot;abcde&quot;</span></span><br><span class="line">String s5 = <span class="keyword">new</span> String(chs, <span class="number">0</span>, <span class="number">3</span>);<span class="comment">//创建String对象，把一部分数组元素作为字符串的内容，参数offset为数组元素的起始索引位置，参数count为要几个元素s5==&quot;abc&quot;</span></span><br><span class="line"></span><br><span class="line">String s6 = <span class="keyword">new</span> String(“abc”); <span class="comment">//创建String对象，字符串内容为abc</span></span><br></pre></td></tr></table></figure><h1 id="String类的方法查找"><a href="#String类的方法查找" class="headerlink" title="String类的方法查找"></a>String类的方法查找</h1><p>String类中有很多的常用的方法，我们在学习一个类的时候，不要盲目的把所有的方法尝试去使用一遍，这时我们应该根据这个对象的特点分析这个对象应该具备那些功能，这样大家应用起来更方便。</p><p>字符串是一个对象，那么它的方法必然是围绕操作这个对象的数据而定义的。我们想想字符串中有哪些功能呢？</p><ul><li><p>字符串中有多少个字符?</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110130655.png"></p></li><li><p>获取部分字符串。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110130716.png"></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String s1 = str.substring(<span class="number">1</span>); <span class="comment">//&quot;bcde&quot; 返回一个新字符串，内容为指定位置开始到字符串末尾的所有字符</span></span><br><span class="line">String s2 = str.substring(<span class="number">2</span>, <span class="number">4</span>);<span class="comment">//&quot;cd&quot; 返回一个新字符串，内容为指定位置开始到指定位置结束所有字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;str=&quot;</span>+str);</span><br><span class="line">System.out.println(<span class="string">&quot;s1=&quot;</span>+s1);</span><br><span class="line">System.out.println(<span class="string">&quot;s2=&quot;</span>+s2);</span><br></pre></td></tr></table></figure></li></ul><h1 id="String类中方法查找练习"><a href="#String类中方法查找练习" class="headerlink" title="String类中方法查找练习"></a>String类中方法查找练习</h1><p>前面给大家简单介绍了几个字符串中常用的方法，这个过程中主要让大家学会如何去查阅API，如何找到自己想用的方法。接下来我们来练习下字符串方法的查找。</p><ul><li><p>字符串是否以指定字符串开头。结尾同理。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110131814.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;StringDemo.java&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = str.startsWith(<span class="string">&quot;Demo&quot;</span>);<span class="comment">//false 判断是否以给定字符串开头</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = str.startsWith(<span class="string">&quot;String&quot;</span>);<span class="comment">//true </span></span><br><span class="line"><span class="keyword">boolean</span> b3 = str.endsWith(<span class="string">&quot;java&quot;</span>);<span class="comment">//true 判断是否以给定字符串结尾</span></span><br></pre></td></tr></table></figure></li><li><p>字符串中是否包含另一个字符串。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110132003.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> index = str.indexOf(“bcd”); <span class="comment">//判断是否包含指定字符串，包含则返回第一次出现该字符串的索引，不包含则返回-1</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = str.contains(<span class="string">&quot;bcd&quot;</span>);<span class="comment">//判断是否包含指定字符串，包含返回true，不包含返回false</span></span><br></pre></td></tr></table></figure></li><li><p>将字符串转成一个字符数组。或者字节数组。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110132206.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] chs = str.toCharArray();</span><br><span class="line"><span class="keyword">byte</span>[] bytes = str.getBytes();</span><br></pre></td></tr></table></figure></li><li><p>判断两个字符串中的内容是否相同</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110132402.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String str2 = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">String str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> b1 = str.equals(str2);</span><br><span class="line"><span class="keyword">boolean</span> b2 = str.equals(str3);</span><br></pre></td></tr></table></figure></li><li><p>获取该字符串对象中的内容</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110132452.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println( str.toString() );</span><br><span class="line">System.out.pintln( str );</span><br></pre></td></tr></table></figure><p>直接打印引用类型变量时，默认调用该类型进行重写后的toString方法</p></li></ul><h1 id="String类方法使用练习"><a href="#String类方法使用练习" class="headerlink" title="String类方法使用练习"></a>String类方法使用练习</h1><ol><li><p>题目一：</p><p>获取指定字符串中，大写字母、小写字母、数字的个数。</p><p>思路：</p><ul><li><p>为了统计大写字母、小写字母、数字的个数。创建3个计数的变量。</p></li><li><p>为了获取到字符串中的每个字符，进行字符串的遍历，得到每个字符。</p></li><li><p>对得到的字符进行判断，如果该字符为大写字母，则大写字母个数+1；如果该字符为小写字母，则小写字母个数+1；如果该字符为数字，则数字个数+1。</p></li><li><p>显示大写字母、小写字母、数字的个数</p></li></ul><p>分析：</p><ul><li>计数器,就是int变量,满足一个条件 ++</li><li>遍历字符串, 长度方法length() + charAt() 遍历</li><li>字符判断是大写,是小写,还是数字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">getCount(<span class="string">&quot;A%A3eBr1FFy&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCount</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义三个变量,计数</span></span><br><span class="line">    <span class="keyword">int</span> upper = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lower = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//对字符串遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; str.length() ; i++)&#123;</span><br><span class="line">        <span class="comment">//String方法charAt,索引,获取字符</span></span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        <span class="comment">//利用编码表 65-90  97-122  48-57</span></span><br><span class="line">        <span class="keyword">if</span>(c &gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;=<span class="number">90</span>)&#123;</span><br><span class="line">            upper++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c &gt;= <span class="number">97</span> &amp;&amp; c &lt;= <span class="number">122</span>)&#123;</span><br><span class="line">            lower++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( c &gt;= <span class="number">48</span> &amp;&amp; c &lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            digit++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(upper);</span><br><span class="line">    System.out.println(lower);</span><br><span class="line">    System.out.println(digit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>题目二：</p><p>将字符串中，第一个字母转换成大写，其他字母转换成小写，并打印改变后的字符串。</p><p>思路：</p><ul><li>把字符串分为两个部分，第一部分为字符串中第一个字母，第二部分为剩下的字符串。</li><li>把第一部分字符串转换成大写字母，把第二部分字符串转换成小写字母</li><li>把两部分字符串连接在一起，得到一个完整的字符串</li></ul><p>分析：</p><ul><li>获取首字母, charAt(0)  substring(0,1)</li><li>转成大写 toUpperCase()</li><li>获取剩余字符串, substring(1)  toLowerCase()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toConvert</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义变量,保存首字母,和剩余字符</span></span><br><span class="line">    String first = str.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    String after = str.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//调用String类方法,大写,小写转换</span></span><br><span class="line">    first = first.toUpperCase();</span><br><span class="line">    after = after.toLowerCase();</span><br><span class="line">    <span class="keyword">return</span> first+after;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>题目三：</p><p>查询大字符串中，出现指定小字符串的次数。如“hellojava,nihaojava,javazhenbang”中查询出现“java”的次数。</p><p>思路：</p><ul><li><p>在大串中，查找小串出现的位置，出现了就次数+1</p></li><li><p>在上次小串出现位置的后面继续查找，需要更改大串的内容为上次未查询到的字符串。</p></li><li><p>回到第一步，继续查找小串出现的位置，直到大串中查询不到小串为止</p></li></ul><p>图示解析：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201110223759.png"></p><p>分析：</p><ul><li>indexOf到字符串中到第一次出现的索引</li><li>找到的索引+被找字符串长度,截取字符串</li><li>计数器++</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStringCount</span><span class="params">(String str, String key)</span></span>&#123;</span><br><span class="line"><span class="comment">//定义计数器</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义变量,保存indexOf查找后的索引的结果</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//开始循环找,条件,indexOf==-1 字符串没有了</span></span><br><span class="line"><span class="keyword">while</span>(( index = str.indexOf(key) )!= -<span class="number">1</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="comment">//获取到的索引,和字符串长度求和,截取字符串</span></span><br><span class="line">str = str.substring(index+key.length());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>object类</title>
      <link href="posts/b7ed79d1.html"/>
      <url>posts/b7ed79d1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。所有类在创建对象的时候，最终找的父类就是Object。</p><p>在Object类众多方法中，我们先学习equals方法与toString方法，其他方法后面课程中会陆续学到。</p><h1 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@1.1/img/20201108230141.png"></p><p>这个equals是什么意思呢？</p><p>分析：</p><p>建立一个Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将父类的equals方法写过来,重写父类的方法</span></span><br><span class="line"><span class="comment"> * 但是,不改变父类方法的源代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">this</span> == obj)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEquals</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//Person类继承Object类,继承下来了父类的方法equals</span></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment">//Person对象p1,调用父类的方法equals,进行对象的比较</span></span><br><span class="line"><span class="keyword">boolean</span> b = p1.equals(p1); </span><br><span class="line">System.out.println(b);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201108234533.png"></p><p><font color=red>equals方法，用于比较两个对象是否相同</font>，它其实就是使用两个对象的内存地址在比较。Object类中的equals方法内部使用的就是==比较运算符。</p><p>在开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较，也就是在开发经常需要子类重写equals方法根据对象的属性值进行比较。比如还是这个例子，我们如果要比较两个人的年龄，我们可以这样写</p><p>在Person类中重写equals方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line">name/age  ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将父类的equals方法写过来,重写父类的方法</span></span><br><span class="line"><span class="comment"> * 但是,不改变父类方法的源代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        Person p = (Person)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age == p.age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">get/set ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样重写之后，再在测试类用equals比较，如果两个人年龄一样，返回ture,如果不同返回false，但是这样有个弊端，如果我们在测试类这样写的不是人，就比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>,<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//boolean b = p1.equals(p1); </span></span><br><span class="line"><span class="keyword">boolean</span> b = p1.equals(array);  <span class="comment">//p1与array比较</span></span><br><span class="line">System.out.println(b);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>此时运行就会出现ClassCastException异常，一般向下转型的时候要判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person p = (Person)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age == p.age</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样是不是就可以了？其实还有一种可能性，如果传了一个null，即p1和null比，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = p1.equals(<span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p>所以代码还需要添加对null的判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person p = (Person)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age == p.age</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实还有一种情况，如果自己和自己比较，也就是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = p1.equals(p1);</span><br></pre></td></tr></table></figure><p>那么在equals重写的时候还需要这样处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person p = (Person)obj;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.age == p.age</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实this == obj和对null的比较不写也可以的，后面instanceof比较可以判断的，但是写上却可以提升程序的执行效率</p><blockquote><p>总结：</p><p>在重写Object中的equals方法时，一定要注意public boolean equals(Object obj)的参数是Object类型，在调用对象的属性时，一定要进行类型转换，在转换之前必须进行类型判断。</p></blockquote><h1 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109130424.png"></p><p>toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201109131121.png"></p><p>可以观察到，两个结果是一样的</p><p>输出语句中，写的是一个对象，默认调用对象的toString方法</p><p>由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> age ;</span><br><span class="line"><span class="comment">//根据Person类的属性重写toString方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person [age=&quot;</span> + age + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode默认终端修改为gitbash</title>
      <link href="posts/7d72a066.html"/>
      <url>posts/7d72a066.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>点开设置</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201106122527.png"></p></li><li><p>搜索<code>terminal.integrated.shell.windows</code></p><p> <img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201106122657.png"><br> 修改这里的配置文件</p></li><li><p>在这里添加路径</p><p> <img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201106122817.png"></p><blockquote><p>这里注意：要修改成为bin下面的bash.exe文件<br>直接复制路径可能会不存在，我不知道为什么，我这里用的everything复制的完整路径才可以，注意，原来的路径的<code>\</code>要改成<code>\\</code></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> 实用小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常</title>
      <link href="posts/23a3bd72.html"/>
      <url>posts/23a3bd72.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>什么是异常？Java代码在运行时期发生的问题就是异常。</p><p>在Java中，把异常信息封装成了一个类。当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）</p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常的根类是Throwable，其下有两个子类：Error与Exception，平常所说的异常指Exception。</p><h2 id="异常的继承体系"><a href="#异常的继承体系" class="headerlink" title="异常的继承体系"></a>异常的继承体系</h2><p>在Java中使用Exception类来描述异常。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103233939.png"></p><p>查看API中Exception的描述，Exception 类及其子类是 Throwable 的一种形式，它用来表示java程序中可能会产生的异常，并要求对产生的异常进行合理的异常处理。</p><p>继续观察，我们可以发现Exception有继承关系，它的父类是Throwable。Throwable是Java 语言中所有错误或异常的超类，即祖宗类。</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103234138.png" style="zoom:80%;" /><p>另外，在异常Exception类中，有一个子类要特殊说明一下，RuntimeException子类，RuntimeException及其它的子类只能在Java程序运行过程中出现。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103234257.png"></p><p>我们再来观察Throwable类，能够发现与异常Exception平级的有一个Error，它是Throwable的子类，它用来表示java程序中可能会产生的严重错误。解决办法只有一个，修改代码避免Error错误的产生。</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201103234358.png"></p><p><strong>异常继承体系总结：</strong></p><blockquote><p>Throwable: 它是所有错误与异常的超类（祖宗类）</p><blockquote><p>Error 错误</p><p>Exception 编译期异常,进行编译JAVA程序时出现的问题</p><blockquote><p>RuntimeException 运行期异常, JAVA程序运行过程中出现的问题</p></blockquote></blockquote></blockquote><h2 id="异常与错误的区别"><a href="#异常与错误的区别" class="headerlink" title="异常与错误的区别"></a>异常与错误的区别</h2><p><strong>异常</strong>：指程序在编译、运行期间发生了某种异常(XxxException)，我们可以对异常进行具体的处理。若不处理异常，程序将会结束运行。</p><ul><li><p>异常的产生演示如下:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">    System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">    System.out.println(arr[<span class="number">3</span>]);<span class="comment">//该句运行时发生了数组索引越界异常ArrayIndexOutOfBoundsException，由于没有处理异常，导致程序无法继续执行，程序结束。</span></span><br><span class="line">    System.out.println(<span class="string">&quot;over&quot;</span>); <span class="comment">// 由于上面代码发生了异常，此句代码不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>错误</strong>：指程序在运行期间发生了某种错误(XxxError)，Error错误通常没有具体的处理方式，程序将会结束运行。Error错误的发生往往都是系统级别的问题，都是jvm所在系统发生的，并反馈给jvm的。我们无法针对处理，只能修正代码。</p><ul><li><p>错误的产生演示如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">100</span>];<span class="comment">//该句运行时发生了内存溢出错误OutOfMemoryError，开辟了过大的数组空间，导致JVM在分配数组空间时超出了JVM内存空间，直接发生错误。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常的产生过程解析"><a href="#异常的产生过程解析" class="headerlink" title="异常的产生过程解析"></a>异常的产生过程解析</h2><p>先运行下面的程序，程序会产生一个数组索引越界异常ArrayIndexOfBoundsException。我们通过图解来解析下异常产生的过程。</p><p>工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对给定的数组通过给定的角标获取元素。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> element = arr[index];</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> num = ArrayTools.getElement(arr,<span class="number">4</span>)</span><br><span class="line">System.out.println(<span class="string">&quot;num=&quot;</span>+num);</span><br><span class="line">System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台会显示</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201104000508.png"></p><p>分析：</p><p>程序正常运行到<code>        int num = ArrayTools.getElement(arr,4)</code>这里，由于没有找到4索引，导致运行发生了异常。java虚拟机能够检测到出现数组的越界问题，</p><p>随后，JVM会做两件事，</p><p>第一件事情：创建了异常的对象，new ArrayIndexOutOfBoundsException(4)</p><p>第二件事情：将异常的对象进行抛出，扔出去理论，抛给方法的调用者</p><p>main接收到了这个异常，main也没有对数组越界异常进行处理，将异常对象继续抛出，抛给main的调用者（JVM）</p><p>当JVM收到异常后做了两件事，</p><p>第一件事：将异常信息以红色字体输出控制台</p><p>第二件事：将程序停止，结束</p><p><strong>注意：一旦异常背抛出了，后面的所有程序，都不再执行</strong></p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201104001614.png"></p><h2 id="抛出异常关键字throw"><a href="#抛出异常关键字throw" class="headerlink" title="抛出异常关键字throw"></a>抛出异常关键字throw</h2><p>在编写程序时，我们必须要考虑程序出现问题的情况。比如，在定义方法时，方法需要接受参数。那么，当调用方法使用接受到的参数时，首先需要先对参数数据进行合法的判断，数据若不合法，就应该告诉调用者，传递合法的数据进来。这时需要使用抛出异常的方式来告诉调用者。</p><p>在java中，提供了一个throw关键字，它用来抛出一个指定的异常对象。那么，抛出一个异常具体如何操作呢？</p><ol><li><p>创建一个异常对象。封装一些提示信息(信息可以自己编写)。</p></li><li><p>需要将这个异常对象告知给调用者。怎么告知呢？怎么将这个异常对象传递到调用者处呢？通过关键字throw就可以完成。throw 异常对象；</p></li></ol><p>throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。</p><p><em><font color=red>throw ,在方法内部，抛出异常对象，必须是exception，throw 后面必须写new 对象，必须是异常的对象或者是子类</font></em></p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> 异常类名(参数);</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;要访问的arr数组不存在&quot;</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;该索引在数组中不存在，已超出范围&quot;</span>);</span><br></pre></td></tr></table></figure><hr><p>下面是异常类ArrayIndexOutOfBoundsException与NullPointerException的构造方法</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201104114038.png"></p><p>学习完抛出异常的格式后，我们通过下面程序演示下throw的使用。</p><p>编写工具类，提供获取数组指定索引处的元素值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayTools</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过给定的数组，返回给定的索引对应的元素值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 若程序出了异常，JVM它会打包异常对象并抛出。但是它所提供的信息不够给力。想要更清晰，需要自己抛出异常信息。</span></span><br><span class="line"><span class="comment">         * 下面判断条件如果满足，当执行完throw抛出异常对象后，方法已经无法继续运算。这时就会结束当前方法的执行，并将异常告知给调用者。这时就需要通过异常来解决。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;arr指向的数组不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;错误的角标，&quot;</span> + index + <span class="string">&quot;索引在数组中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">34</span>,<span class="number">12</span>,<span class="number">67</span>&#125;; <span class="comment">//创建数组</span></span><br><span class="line"><span class="keyword">int</span> num = ArrayTools.getElement(<span class="keyword">null</span>,<span class="number">2</span>);<span class="comment">// 调用方法，获取数组中指定索引处元素</span></span><br><span class="line"><span class="comment">//int num = ArrayTools.getElement(arr,5);// 调用方法，获取数组中指定索引处元素</span></span><br><span class="line">System.out.println(<span class="string">&quot;num=&quot;</span>+num);<span class="comment">//打印获取到的元素值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="声明异常关键字throws"><a href="#声明异常关键字throws" class="headerlink" title="声明异常关键字throws"></a>声明异常关键字throws</h2><p>声明：将问题标识出来，报告给调用者。如果方法内通过throw抛出了编译时异常，而没有捕获处理（稍后讲解该方式），那么必须通过throws进行声明，让调用者去处理。</p><p>声明异常格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数) <span class="keyword">throws</span> 异常类名<span class="number">1</span>,异常类名<span class="number">2</span>… &#123;   &#125;</span><br></pre></td></tr></table></figure><p>声明异常的代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   如果定义功能时有问题发生需要报告给调用者。可以通过在方法上使用throws关键字进行声明。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;show run&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throws用于进行异常类的声明，若该方法可能有多种异常情况产生，那么在throws后面可以写多个异常类，用逗号隔开。</p><p>多个异常的情况，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> <span class="keyword">throws</span> NullPointerException, ArrayIndexOutOfBoundsException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;arr指向的数组不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">&quot;错误的角标，&quot;</span> + index + <span class="string">&quot;索引在数组中不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> element = arr[index];</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="捕获异常try…catch…finally"><a href="#捕获异常try…catch…finally" class="headerlink" title="捕获异常try…catch…finally"></a>捕获异常try…catch…finally</h2><p>捕获：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理</p><p>捕获异常格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//需要被检测的语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类 变量) &#123; <span class="comment">//参数。</span></span><br><span class="line"><span class="comment">//异常的处理语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//一定会被执行的语句。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>try：</strong>该代码块中编写可能产生异常的代码。</p><p><strong>catch：</strong>用来进行某种异常的捕获，实现对捕获到的异常进行处理。</p><p><strong>finally</strong>：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">//throws ArrayIndexOutOfBoundsException</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">                System.out.println(arr[<span class="number">5</span>]);<span class="comment">// 会抛出ArrayIndexOutOfBoundsException</span></span><br><span class="line">                <span class="comment">//当产生异常时，必须有处理方式。要么捕获，要么声明。</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123; <span class="comment">//括号中需要定义什么呢？try中抛出的是什么异常，在括号中就定义什么异常类型。</span></span><br><span class="line">                System.out.println(<span class="string">&quot;异常发生了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                arr = <span class="keyword">null</span>; <span class="comment">//把数组指向null，通过垃圾回收器，进行内存垃圾的清除</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;程序运行结果&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="try…catch…finally异常处理的组合方式"><a href="#try…catch…finally异常处理的组合方式" class="headerlink" title="try…catch…finally异常处理的组合方式"></a>try…catch…finally异常处理的组合方式</h2><p><strong>try catch finally组合：</strong>检测异常，并传递给catch处理，并在finally中进行资源释放。</p><p><strong>try catch组合</strong> : 对代码进行异常检测，并对检测的异常传递给catch处理。对异常进行捕获处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//不用throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//产生异常，直接捕获处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>一个try 多个catch组合</strong> : 对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123; <span class="comment">//不用throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//产生异常，直接捕获处理</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(XxxException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(YyyException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(ZzzException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:这种异常处理方式，要求多个catch中的异常不能相同，<strong>并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理</strong>,如果是平级异常，也就是抛出的异常类之间，没有继承关系，那就没有顺序，上下随便写。</p><p><strong>try finally 组合</strong>: 对代码进行异常检测，检测到异常后因为没有catch，所以一样会被默认jvm抛出。异常是没有捕获处理的。但是功能所开启资源需要进行关闭，所有finally。只为关闭资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//需要throws </span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行时期异常"><a href="#运行时期异常" class="headerlink" title="运行时期异常"></a>运行时期异常</h2><p>异常其实分为编译异常和运行时期异常</p><p>编译异常：调用了抛出异常的方法，不处理编译失败（try/throws）</p><p>运行异常：抛出的异常是RuntimeException类，或者是他的子类</p><hr><p>RuntimeException和他的所有子类异常,都属于运行时期异常。NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常.</p><p>运行异常的特点: 方法中抛出运行时期异常,方法定义中<strong>无需throws声明</strong>,调用者也无需处理此异常</p><p>设计原因：运行异常，不能发生，但是如果发生了，请修改源代码，因为运行代码一旦发生，后面的代码没有执行的意义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">         method();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常在方法重写中细节"><a href="#异常在方法重写中细节" class="headerlink" title="异常在方法重写中细节"></a>异常在方法重写中细节</h2><ol><li><p>子类覆盖父类方法时，如果父类的方法声明异常，<strong>子类只能声明父类异常或者该异常的子类，或者不声明。</strong>（声明不声明都可以）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> RuntimeException </span>&#123; &#125;  <span class="comment">//抛出父类一样的异常</span></span><br><span class="line">        <span class="comment">//public void method() throws NullPointerException&#123; &#125; //抛出父类子异常</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>当父类方法声明多个异常时，子类覆盖时只能声明多个异常的子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span> <span class="keyword">throws</span> NullPointerException, ClassCastException</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span><span class="keyword">throws</span> NullPointerException, ClassCastException </span>&#123; &#125;  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException</span>&#123; &#125; <span class="comment">//抛出父类异常中的一部分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> ClassCastException </span>&#123; &#125; <span class="comment">//抛出父类异常中的一部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当被覆盖的方法没有异常声明时，子类覆盖时无法声明异常的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span> <span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; &#125;<span class="comment">//错误的方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例：父类中会存在下列这种情况，接口也有这种情况</p><p>问题：接口中没有声明异常，而实现的子类覆盖方法时发生了异常，怎么办？</p><p>答：无法进行throws声明，只能catch的捕获。万一问题处理不了呢？catch中继续throw抛出，但是只能将异常转换成RuntimeException子类抛出。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123; <span class="comment">//无法声明 throws Exception</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//只能捕获处理</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;哥们，你定义的数组arr是空的!&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;父方法中没有异常抛出，子类中不能抛出Exception异常&quot;</span>);</span><br><span class="line">                <span class="comment">//我们把异常对象e，采用RuntimeException异常方式抛出</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="异常中常用方法"><a href="#异常中常用方法" class="headerlink" title="异常中常用方法"></a>异常中常用方法</h2><p>在Throwable类中为我们提供了很多操作异常对象的方法，常用的如下：</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201104132631.png"></p><ul><li><p>getMessage方法：返回该异常的详细信息字符串，即异常提示信息</p></li><li><p>toString方法：返回该异常的名称与详细信息字符串</p></li><li><p>printStackTrace：在控制台输出该异常的名称与详细信息字符串、异常出现的代码位置，JVM默认调用方法也是这个方法</p><p>异常的常用方法代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Person p= <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (p==<span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(“出现空指针异常了，请检查对象是否为<span class="keyword">null</span>”);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">String message = e.getMesage();</span><br><span class="line">System.out.println(message ); </span><br><span class="line"></span><br><span class="line">String result = e.toString();</span><br><span class="line">System.out.println(result);</span><br><span class="line"></span><br><span class="line">e.printStackTrace(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>在上述代码中，发现这些异常都是JDK内部定义好的，并且这些异常不好找。书写时也很不方便，那么能不能自己定义异常呢？</p><p>之前的几个异常都是java通过类进行的描述。并将问题封装成对象，异常就是将问题封装成了对象。这些异常不好认，书写也很不方便，能不能定义一个符合我的程序要求的异常名称。既然JDK中是使用类在描述异常信息，那么我们也可以模拟Java的这种机制，我们自己定义异常的信息，异常的名字，让异常更符合自己程序的阅读。准确对自己所需要的异常进行类的描述。</p><h2 id="自定义异常类的定义"><a href="#自定义异常类的定义" class="headerlink" title="自定义异常类的定义"></a>自定义异常类的定义</h2><p>通过阅读异常源代码：发现java中所有的异常类，都是继承Throwable，或者继承Throwable的子类。这样该异常才可以被throw抛出。</p><p>说明这个异常体系具备一个特有的特性：可抛性：即可以被throw关键字操作。</p><p>并且查阅异常子类源码，发现每个异常中都调用了父类的构造方法，把异常描述信息传递给了父类，让父类帮我们进行异常信息的封装。</p><p>例如NullPointerException异常类源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NullPointerException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullPointerException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//调用父类构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NullPointerException</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s);<span class="comment">//调用父类具有异常信息的构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们来定义个自己的异常，即自定义异常。</p><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class 异常名 extends Exception&#123; <span class="comment">//或继承RuntimeException</span></span><br><span class="line"><span class="keyword">public</span> 异常名()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> 异常名(String s)&#123; </span><br><span class="line"><span class="keyword">super</span>(s); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>自定义异常继承Exception演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(message);<span class="comment">// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义异常继承RuntimeException演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么要定义构造函数，因为看到Java中的异常描述类中有提供对异常对象的初始化方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MyException()&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line">MyException(String message)&#123;</span><br><span class="line"><span class="keyword">super</span>(message);<span class="comment">// 如果自定义异常需要异常信息，可以通过调用父类的带有字符串参数的构造函数即可。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="自定义异常的练习"><a href="#自定义异常的练习" class="headerlink" title="自定义异常的练习"></a>自定义异常的练习</h2><p>定义Person类，包含name与age两个成员变量。</p><p>在Person类的有参数构造方法中，进行年龄范围的判断，若年龄为负数或大于200岁，则抛出NoAgeException异常，异常提示信息“年龄数值非法”。</p><p>要求：在测试类中，调用有参数构造方法，完成Person对象创建，并进行异常的处理。</p><p>自定义异常类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoAgeException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">NoAgeException() &#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NoAgeException(String message)&#123;</span><br><span class="line"><span class="keyword">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">Person(String name,<span class="keyword">int</span> age) <span class="keyword">throws</span> NoAgeException&#123;</span><br><span class="line"><span class="comment">//加入逻辑判断。</span></span><br><span class="line"><span class="keyword">if</span>(age&lt;<span class="number">0</span> || age&gt;<span class="number">200</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NoAgeException(age+<span class="string">&quot;,年龄数值非法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义Person对象对应的字符串表现形式。覆盖Object中的toString方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Person[name=&quot;</span>+name+<span class="string">&quot;,age=&quot;</span>+age+<span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">&quot;xiaoming&quot;</span>,<span class="number">20</span>);</span><br><span class="line">System.out.println(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoAgeException ex)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;年龄异常啦&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;over&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，构造函数到底抛出这个NoAgeException是继承Exception呢？还是继承RuntimeException呢？</p><ul><li>继承Exception，必须要throws声明，一声明就告知调用者进行捕获，一旦问题处理了调用者的程序会继续执行。</li><li>继承RuntimeExcpetion,不需要throws声明的，这时调用是不需要编写捕获代码的，因为调用根本就不知道有问题。一旦发生NoAgeException，调用者程序会停掉，并有jvm将信息显示到屏幕，让调用者看到问题，修正代码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码块</title>
      <link href="posts/57224242.html"/>
      <url>posts/57224242.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="局部代码块"><a href="#局部代码块" class="headerlink" title="局部代码块"></a>局部代码块</h1><p>局部代码块是定义在方法或语句中</p><p>特点：</p><ul><li>以”{}”划定的代码区域，此时只需要关注作用域的不同即可</li><li>方法和类都是以代码块的方式划定边界的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">         <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块&quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">99</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;代码块之外&quot;</span> + x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>​        普通代码块1</p><p>​        代码块之外99</p><h1 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h1><p>构造代码块是定义在类中成员位置的代码块</p><p>特点：</p><ul><li><code>优先于构造方法</code>执行，构造代码块用于执行所有对象均需要的初始化动作</li><li><code>每创建一个对象均会执行一次构造代码块</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//构造代码块</span></span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;构造代码块执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person()&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Person无参数的构造函数执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">System.out.println(<span class="string">&quot;Person（age）参数的构造函数执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>构造代码块执行了</p><p>Person无参数的构造函数执行</p><p>Person（age）参数的构造函数执行”</p><blockquote><p>构造代码块是优先于构造方法，所以就算构造代码块放在后面，他也先执行构造代码块的方法，和顺序没有关系</p></blockquote><h1 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h1><p>静态代码块是定义在成员位置，使用static修饰的代码块。</p><p>特点：</p><ul><li>它<code>优先于主方法执行</code>、<code>优先于构造代码块执行</code>，当以任意形式第一次使用到该类时执行。</li><li>该类不管创建多少对象，静态代码块<code>只执行一次</code>。</li><li>可用于给静态变量赋值，用来给类进行初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">     <span class="comment">//静态代码块</span></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;静态代码块执行了&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四大访问权限修饰符</title>
      <link href="posts/f941d9b7.html"/>
      <url>posts/f941d9b7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限，以下表来说明不同权限的访问能力：</p><table><thead><tr><th align="left"></th><th align="center">public</th><th align="center">protected</th><th align="center">default</th><th align="center">private</th></tr></thead><tbody><tr><td align="left">同一类中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="left">同一包中</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="left">不同包的子类</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">不同包中的无关类</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p>​     归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问</p><ul><li>要想仅能在本类中访问使用private修饰；</li><li>要想本包中的类都可以访问不加修饰符即可；</li><li>要想本包中的类与其他包中的子类可以访问使用protected修饰</li><li>要想所有包中的所有类都可以访问使用public修饰。</li><li>注意：如果类用public修饰，则类名必须与文件名相同。一个文件中只能有一个public修饰的类。</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>匿名对象与内部类</title>
      <link href="posts/307f30e5.html"/>
      <url>posts/307f30e5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>匿名对象是指创建对象时，只有创建对象的语句，却没有把对象地址值赋值给某个变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个普通对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();<span class="comment">//这种对象可以反复使用</span></span><br></pre></td></tr></table></figure><p>创建一个匿名对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person();<span class="comment">//这种对象只能使用一次</span></span><br></pre></td></tr></table></figure><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li><p>创建匿名对象直接使用，没有变量名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person().eat()  <span class="comment">//eat方法被一个没有名字的Person对象调用了。</span></span><br></pre></td></tr></table></figure></li><li><p>匿名对象在没有指定其引用变量时，只能使用一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person().eat(); 创建一个匿名对象，调用eat方法</span><br><span class="line"><span class="keyword">new</span> Person().eat(); 想再次调用eat方法，重新创建了一个匿名对象</span><br></pre></td></tr></table></figure></li><li><p>匿名对象可以作为方法接收的参数、方法返回值使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">getPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//普通方式</span></span><br><span class="line"><span class="comment">//Person p = new Person();</span></span><br><span class="line"><span class="comment">//return p;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//匿名对象作为方法返回值</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Person(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Person p)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//调用getPerson方法，得到一个Person对象</span></span><br><span class="line">Person person = Demo.getPerson();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用method方法</span></span><br><span class="line">Demo.method(person);</span><br><span class="line"><span class="comment">//匿名对象作为方法接收的参数</span></span><br><span class="line">Demo.method(<span class="keyword">new</span> Person());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ol><li><p>什么是内部类</p><p>将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。</p></li><li><p>什么时候使用内部类</p><p>在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，这时发动机就可以使用内部类来描述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 汽车 </span>&#123; <span class="comment">//外部类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 发动机 </span>&#123; <span class="comment">//内部类</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内部类的分类</p><p>内部类分为成员内部类与局部内部类。</p><p>我们定义内部类时，就是一个正常定义类的过程，同样包含各种修饰符、继承与实现关系等。在内部类中可以直接访问外部类的所有成员。</p></li></ol><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>成员内部类，定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问</p><ol><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123; </span><br><span class="line">修饰符 <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line"><span class="comment">//其他代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 变量名 = <span class="keyword">new</span> 外部类名().new 内部类名();</span><br></pre></td></tr></table></figure></li><li><p>成员内部类代码演示</p><p>定义类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> </span>&#123;<span class="comment">//外部类，身体</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> life= <span class="keyword">true</span>; <span class="comment">//生命状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heart</span> </span>&#123; <span class="comment">//内部类，心脏</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;心脏噗通噗通的跳&quot;</span>)</span><br><span class="line">                System.out.println(<span class="string">&quot;生命状态&quot;</span> + life); <span class="comment">//访问外部类成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建内部类对象</span></span><br><span class="line">Body.Heart bh = <span class="keyword">new</span> Body().<span class="function">new <span class="title">Heart</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//调用内部类中的方法</span></span><br><span class="line">bh.jump();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用规则</p><p>内部类，可以使用外部类成员，包括私有</p><p>外部类要使用内部类的成员，必须建立内部类对象</p></li><li><p>成员内部类的同名变量调用</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//System.out.println(i);//输出3</span></span><br><span class="line">            <span class="comment">//System.out.println(this.i);//输出2</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.i);<span class="comment">//输出1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Outer.Inner in = <span class="keyword">new</span> Outer().<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">        in.inner(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>局部内部类，定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问</p><ol><li><p>定义格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123; </span><br><span class="line">修饰符 返回值类型 方法名(参数) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">            <span class="comment">//其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>访问方式</p><p>在外部类方法中，创建内部类对象，进行访问</p></li><li><p>局部内部类代码演示</p><p>定义类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Party</span> </span>&#123;<span class="comment">//外部类，聚会</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">puffBall</span><span class="params">()</span></span>&#123;<span class="comment">// 吹气球方法</span></span><br><span class="line">         <span class="class"><span class="keyword">class</span> <span class="title">Ball</span> </span>&#123;<span class="comment">// 内部类，气球</span></span><br><span class="line">             <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">puff</span><span class="params">()</span></span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;气球膨胀了&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">//创建内部类对象，调用puff方法</span></span><br><span class="line">        <span class="keyword">new</span> Ball().puff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>访问内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//创建外部类对象</span></span><br><span class="line">Party p = <span class="keyword">new</span> Party();</span><br><span class="line"><span class="comment">//调用外部类中的puffBall方法</span></span><br><span class="line">p.puffBall();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="内部类的实际使用——匿名内部类"><a href="#内部类的实际使用——匿名内部类" class="headerlink" title="内部类的实际使用——匿名内部类"></a>内部类的实际使用——匿名内部类</h2><h3 id="匿名内部类概念"><a href="#匿名内部类概念" class="headerlink" title="匿名内部类概念"></a>匿名内部类概念</h3><p>内部类是为了应对更为复杂的类间关系。查看源代码中会涉及到，而在日常业务中很难遇到，这里不做赘述。</p><p>最常用到的内部类就是匿名内部类，它是局部内部类的一种。</p><p>定义的匿名内部类有两个含义：</p><ul><li>临时定义某一指定类型的子类</li><li>定义后即刻创建刚刚定义的这个子类的对象</li></ul><blockquote><p>概念解读：</p><p>以前我们实现类的时候，都是先定义一个类Fu，然后让Zi继承Fu，然后重现Fu类的抽象方法，接着创建实现类对象在调用重写方法</p><p>而匿名内部类就是用于简化这种问题，一步来完成，将<code>定义实现类</code>，<code>重写方法</code>，<code>建立实现类</code>，合而为一</p></blockquote><h3 id="定义匿名内部类的作用与格式"><a href="#定义匿名内部类的作用与格式" class="headerlink" title="定义匿名内部类的作用与格式"></a>定义匿名内部类的作用与格式</h3><ol><li><p>作用</p><p>匿名内部类是创建某个类型子类对象的快捷方式。</p></li><li><p>格式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类或接口()&#123;</span><br><span class="line"><span class="comment">//进行方法重写</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>代码演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//已经存在的父类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义并创建该父类的子类对象，并用多态的方式赋值给父类引用变量</span></span><br><span class="line">Person  p = <span class="keyword">new</span> Person()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“我吃了”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用eat方法</span></span><br><span class="line">p.eat();</span><br></pre></td></tr></table></figure><p>使用匿名对象的方式，将定义子类与创建子类对象两个步骤由一个格式一次完成，。虽然是两个步骤，但是两个步骤是连在一起完成的。</p><p>匿名内部类如果不定义变量引用，则也是匿名对象。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Person()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(“我吃了”);</span><br><span class="line">&#125;</span><br><span class="line">&#125;.eat();</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static关键字</title>
      <link href="posts/ce244871.html"/>
      <url>posts/ce244871.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？</p><p>可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。</p><hr><p>概念解读：</p><p>比如有个学生类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    String name;</span><br><span class="line">    String schoolName = “淮南师范学院”;   <span class="comment">//学校名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学生的年龄和姓名可能都不一样，但是学生都属于同一个学校，我们每次创建一个学生的时候，内存就会开辟一个空间，成员变量也会随之进来，，比如创建五个对象，学校名字变量也会创建五次，都是一样的，这就会照成浪费</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201101163257.png"></p><p>解决的方法:</p><p>变量schoolName从堆内存拿出来，放到一个地方去，让所有的学生对象共享一个schoolName变量</p><p>name，age属于对象自己的属性，对象自己特有的数据</p><p>schoolName应该作为对象的共享数据出现</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201101163625.png"></p><p>如何实现对象的共享数据？</p><p>在数据的前面加上static修饰</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><ol><li><p>被static修饰的成员变量属于类，不属于这个类的某个对象。</p><p><font color = "red">也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量</font></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo d1 = <span class="keyword">new</span> Demo();</span><br><span class="line">        Demo d2 = <span class="keyword">new</span> Demo();</span><br><span class="line">        d1.num = <span class="number">200</span>;</span><br><span class="line">        System.out.println(d1.num); <span class="comment">//结果为200</span></span><br><span class="line">        System.out.println(d2.num); <span class="comment">//结果为200</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>被static修饰的成员可以并且建议通过类名直接访问。</p></li></ol><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ol><li><p>静态内容是优先于对象存在，只能访问静态（原因是因为，生命周期不同，静态优先于非静态存在内存中，静态出现的时候，非静态还没有出现），不能使用this/super（this代表本类引用，静态优于对象，没有对象，this就没有用，super同理）。静态修饰的内容存于静态区。</p></li><li><p>同一个类中，静态成员只能访问静态成员</p></li><li><p>main方法为静态方法仅仅为程序执行入口，它不属于任何一个对象，可以定义在任意类中。</p><blockquote><p>问题：</p><p>static修饰到底什么时候使用，应用场景</p><p>static修饰成员变量，成员方法</p><blockquote><p>成员变量加static，根据具体事物，具体分析问题</p><p>定义事物的时候，多个事物之间是否有共性的数据</p><p>请你将共性的数据定义为静态的成员变量</p></blockquote><blockquote><p>成员方法加static，跟着变量走</p><p>如果方法，没有调用过非静态成员，将方法定义为静态</p></blockquote></blockquote></li><li><p>多态调用中，编译运行都看“=”左边的父类，</p><p> 父类有，编译成功，父类没有，编译失败。</p><p> <strong>运行，静态方法，运行父类中的静态方法</strong></p><p> 运行，非静态方法，运行子类的重写方法</p><p> 成员变量，编译运行全是父类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.printf(<span class="string">&quot;父类的静态方法show&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">       System.out.printf(<span class="string">&quot;子类的静态方法show&quot;</span>) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Fu f  =<span class="keyword">new</span> Zi();<span class="comment">//多态调用</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用还是父类的静态方法，原因：静态属于类，不属于对象</span></span><br><span class="line">      <span class="comment">//对象的多态性，静态和对象无关，父类的引用，静态方法</span></span><br><span class="line">        f.show(); <span class="comment">//打印会输出父类的方法show</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="定义静态常量"><a href="#定义静态常量" class="headerlink" title="定义静态常量"></a>定义静态常量</h1><p>开发中，我们想在类中定义一个静态常量，通常使用<code>public static final修饰的变量</code>来完成定义。此时变量名用全部大写，多个单词使用下划线连接。</p><p>格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure><p>注意：</p><p>接口中的每个成员变量都默认使用public static final修饰。</p><p>所有接口中的成员变量已是静态常量，由于接口没有构造方法，所以必须显示赋值。可以直接用接口名访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Inter</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方位接口中的静态变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Inter.COUNT</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final关键字</title>
      <link href="posts/af55167d.html"/>
      <url>posts/af55167d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>继承的出现提高了代码的复用性，并方便开发。但随之也有问题，有些类在描述完之后，不想被继承，或者有些类中的部分方法功能是固定的，不想让子类重写。可是当子类继承了这些特殊类之后，就可以对其中的方法进行重写，那怎么解决呢？</p><p>要解决上述的这些问题，需要使用到一个关键字final，final的意思为最终，不可变。final是个修饰符，它可以用来修饰类，类的成员，以及局部变量。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><h2 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h2><p>final修饰类不可以被继承，但是可以继承其他类。这种类在使用方式上没有任何变化，包括创建对象，调用方法，和之前没有区别，只是他不能被继承</p><h2 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h2><p>final修饰的方法不可以被覆盖,但父类中没有被final修饰方法，子类覆盖后可以加final。</p><h2 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h2><h3 id="普通变量"><a href="#普通变量" class="headerlink" title="普通变量"></a>普通变量</h3><p>final修饰的变量称为常量，这些变量只能赋值一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">20</span>;</span><br><span class="line">i = <span class="number">30</span>; <span class="comment">//赋值报错，final修饰的变量只能赋值一次</span></span><br></pre></td></tr></table></figure><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>final还可以修饰引用变量</p><p>引用类型的变量值为对象地址值，地址值不能更改，但是地址内的对象属性值可以修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">p = p2; <span class="comment">//final修饰的变量p，所记录的地址值不能改变</span></span><br><span class="line">p.name = <span class="string">&quot;小明&quot;</span>;<span class="comment">//可以更改p对象中name属性值</span></span><br></pre></td></tr></table></figure><p>p不能为别的对象，而p对象中的name或age属性值可更改。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>修饰成员变量，需要在创建对象前赋值，否则报错。(当没有显式赋值时，多个构造方法的均需要为其赋值。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">final 修饰成员变量</span></span><br><span class="line"><span class="comment">成员变量，在堆内存，具有默认值</span></span><br><span class="line"><span class="comment">final修饰的成员变量，固定的不是内存的默认值</span></span><br><span class="line"><span class="comment">固定的是，成员变量的手动赋值，绝对不是内存的默认</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果手动不赋值，可以在构造器利用构造器赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以采用手动直接赋值，或者构造器的方法都可以，只要保证，<code>被final修饰的成员变量，只能被赋值一次</code>，<strong>在创建对象前赋值</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【操作系统】第二章：操作系统基础操作</title>
      <link href="posts/39515ecd.html"/>
      <url>posts/39515ecd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h1><ol><li><p>CPU, I/O, 内存通过总线连接</p></li><li><p>DISK（硬盘）: 存放OS</p><p>BIOS：基本I/O处理系统</p><p>Bootloader: 加载OS到内存中</p></li><li><p>当电脑通电时，段寄存器CS和指令寄存器IP<code>合在一起</code>能够确定一个内存地址，例如CS:IP = 0xf000:fff0。刚开始加电，以x86为例，bios会从0xf000:fff0这个地址开始执行，然后会执行接下来的一系列工作，包括第四点的自检</p></li><li><p>POST(加电自检)，寻找显卡和执行BIOS。(显示器，键盘…是否正常)</p></li><li><p>步骤：</p><ul><li><p>BIOS：将Bootloader从磁盘的磁盘的引导扇区(在硬盘的第一个扇区，也就是512字节)加载到0x7c00，跳转到CS:IP=0000:7c00的内存区域(以便下一步)，这个时候cpu的控制权已经交给Bootloader了</p></li><li><p>Bootloader：将操作系统的代码和数据从硬盘加载到内存中；跳转到操作系统的起始地址，这个时候cpu的控制权已经交给os了</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201031225845.png"></p></li></ul></li><li><p>系统调用：(来源于应用程序)应用程序主动向操作系统发出服务请求</p></li><li><p>异常：(来源于不良的应用程序)非法指令或其它花的处理状态(如：内存出错)</p></li><li><p>中断：(来源于外设)来自不同的硬件设备的计时器和网络的中断</p></li><li><p>为什么应用程序不能直接访问硬件而是通过操作系统？</p><ul><li>计算机运行时，内核是被信任的第三方</li><li>只有内核可以执行特权指令</li><li>为了方便应用程序</li></ul></li><li><p>讨论的问题：操作系统如何设计和实现中断/异常和系统调用；他们三者的区别和特点。</p><ol><li><p>产生的源头：</p><ul><li>中断：外设(键盘/鼠标/网卡/声卡/显卡，可以产生各种事件)</li><li>异常：应用程序意想不到的行为(例：异常，恶意程序，应用程序需要的资源未得到满足)</li><li>系统调用(system call)：应用程序请求操作提供服务(例：打开/关闭/读写文件，发送网络包)</li></ul></li><li><p>处理时间</p><ul><li>中断：异步（当这个事件产生的时候，我们的应用程序不知道他什么时候会产生，无法预测）</li><li>异常：同步</li><li>系统调用：同步或异步</li></ul><blockquote><p>异步同步我没有理解，弹幕上说，异步不可预知，同步可以预知</p></blockquote></li><li><p>响应</p><ul><li>中断：持续，对用户应用程序时透明的（因为操作系统把中断过程完成了，我们感知不到）</li><li>异常：杀死或者重新执行意想不到的应用程序指令</li><li>系统调用：等待和持续</li></ul></li></ol></li></ol><h1 id="中断-异常和系统调用"><a href="#中断-异常和系统调用" class="headerlink" title="中断/异常和系统调用"></a>中断/异常和系统调用</h1><ol><li><p>中断/异常处理机制</p><p>中断是外设的事件</p><p>异常是CPU的事件</p><p>中断/异常迫使CPU访问一些被中断和异常服务访问的功能</p></li><li><p>中断处理机制</p><p>硬件：设置中断标记(CPU初始化)</p><ul><li>将内部/外部事件设置中断标记；</li><li>中断事件的ID(程序访问的中断向量地址)</li></ul><p>软件(操作系统)：</p><ul><li>保存当前处理状态</li><li>中断服务程序处理</li><li>清除中断标记</li><li>恢复之前保存的处理状态</li></ul></li><li><p>异常处理机制</p><p>异常：异常编号</p><ul><li>保存现场</li><li>异常处理：杀死产生异常的程序；重新执行异常指令</li><li>恢复现场</li></ul></li><li><p>系统调用</p><ul><li>一条指令会触发一个系统调用</li><li>程序访问主要是通过高层次的API接口而不是直接进行系统调用。</li><li>通常情况下，存在与每个系统调用相关的序号，系统调用接口根据这些序号来维护表的索引</li><li>系统调用接口调用内核态中预期的系统调用，并返回系统调用的状态和其它任何返回值</li><li>用户不需要知道系统调用是如何实现的，只需要获取API和了解操作新系统将什么作为返回结果。操作系统接口的细节大部分都隐藏在API中，并通过运行程序支持的库来管理</li><li>用户态：应用程序在执行的过程中，CPU执行的特权级的状态(很低，不能访问特殊机器指令和IO)</li><li>内核态：应用程序在执行的过程中，CPU执行的特权级的状态(高，操作系统可以执行CPU任何一条指令)</li><li>系统调用时涉及到特权级从用户态到内核态的转换，应用程序和操作系统有各自的堆栈，这两个变化比函数调用的开销更大，但更安全和可靠。(而程序调用是在一个栈空间实现参数的调用和返回)</li></ul></li><li><p>跨越操作系统边界的开销</p><ul><li><p>在执行时间上的开销超过程序调用</p></li><li><p>开销包括：</p><p>建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销；<br>建立内核堆栈(操作系统和应用程序的堆栈不一样)；<br>验证参数(操作系统会检查数据)；<br>内核态映射到用户态的地址空间，更新页面映射权限(内存拷贝开销)；<br>内核态独立地址空间TLB。</p></li></ul></li></ol><blockquote><p>参考：<a href="https://blog.csdn.net/iwanderu/article/details/103934399">https://blog.csdn.net/iwanderu/article/details/103934399</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类与接口的区别</title>
      <link href="posts/4a128e89.html"/>
      <url>posts/4a128e89.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>举例：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">犬：</span><br><span class="line">    行为：</span><br><span class="line">        吼叫；</span><br><span class="line">        吃饭；</span><br><span class="line">缉毒犬：</span><br><span class="line">    行为：</span><br><span class="line">        吼叫；</span><br><span class="line">        吃饭；</span><br><span class="line">        缉毒；</span><br></pre></td></tr></table></figure></li><li><p>思考</p><p> 由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。</p><p> 可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。</p><p> 代码演示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 缉毒</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 缉毒();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义犬科的这个提醒的共性功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 吃饭();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 吼叫();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，</span></span><br><span class="line"><span class="comment">//由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 缉毒犬 <span class="keyword">extends</span> 犬科 <span class="keyword">implements</span> 缉毒</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 缉毒() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 吃饭() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 吼叫() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 缉毒猪 <span class="keyword">implements</span> 缉毒</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 缉毒() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>通过上面的例子总结：</p><p> <strong>相同点:</strong></p><ul><li><p>都位于继承的顶端,用于被其他类实现或继承;</p></li><li><p>都不能直接实例化对象;</p></li><li><p>都包含抽象方法,其子类都必须覆写这些抽象方法;</p></li></ul><p> <strong>区别:</strong></p><ul><li><p>抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;</p></li><li><p>一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)</p></li><li><p>抽象类是这个事物中应该具备的你内容, 共性</p></li><li><p>接口是这个事物中的额外内容,</p><blockquote><p>抽象类是同一个事物的共性，</p><p>而接口就是额外多出来的功能，他有你没有，你有我没有，并不是大家都有的功能</p></blockquote></li></ul><p> <strong>二者的选用</strong>：</p><ul><li><p>优先选用接口,尽量少用抽象类;</p></li><li><p>需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>instanceof关键字</title>
      <link href="posts/15b3e85e.html"/>
      <url>posts/15b3e85e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java中有个关键字叫<code>instanceof</code>，返回值是true或者false</p><p>它是用来比较引用数据类型的关键字，一个引用类型的变量,是不是这个类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;学生在休息睡觉&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;老师在休息&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，建立一个抽象类Person，定义抽象方法sleep（），再建立学生类与老师类继承Person类，重写抽象方法</p><p>建立对象的时候，利用多态性，可以这样写</p><p><code>Person p = new Student();</code>也可以<code>Person p = new Teacher();</code>，</p><p>而instanceof就可以用来比较这个p是是Student类型对象,还是Teacher类型对象</p><p>写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用变量 <span class="keyword">instanceof</span> 类名</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p <span class="keyword">instanceof</span> Student  <span class="comment">//比较,p是不是Student类型的对象,如果是,intanceof返回true</span></span><br></pre></td></tr></table></figure><p>附上test类代码以及结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = p <span class="keyword">instanceof</span> Student;</span><br><span class="line">System.out.println(b);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> c = p <span class="keyword">instanceof</span> Teacher;        </span><br><span class="line">    System.out.println(c);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中还有前提条件就是，老师和学生一定要继承Person类才可以用instanceof关键字，否则会编译报错</p><p>用代码解释就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再添加一个动物抽象类，测试类中这样写到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">b = p <span class="keyword">instanceof</span> Animal;  <span class="comment">//这样写错误的，编译不能通过</span></span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instanceof比较的两个变量一定要有关系才可以用</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>super关键字</title>
      <link href="posts/f6ea766.html"/>
      <url>posts/f6ea766.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>和this一样，<code>super.</code>的方式，是用来引用父类的变量与方法的</p><p>除此之外，super还可以调用父类的构造方法</p><p> <code>super()</code>调用的是父类的空参数构造</p><p><code>super(参数)</code> 调用的是父类的有参数构造方法</p><p>其中要注意的是，子类的构造方法, 有一个默认添加的构造方法，子类构造方法中的第一行,有一个隐式代码 super()，<font color=brown>（注：这里说一下，子类的<strong>所有构造方法</strong>，无论重载多少个，第一行都是 super()）</font></p><p>即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的构造方法第一行super语句,调用父类的构造方法</p><p>代码理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台会输出<code>父类构造方法</code>字样，意思就是我上面说的那样，子类的构造方法, 有一个默认添加的构造方法，子类构造方法的第一行,有一个隐式代码 super()</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？</p><p>这时是没有的，因为this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。</p><p> super(参数) 与 this(参数) 不能同时在构造方法中存在</p><p>小结论: 无论如何,子类的所有构造方法,直接,间接必须调用到父类构造方法</p><hr><blockquote><p>这里吐槽一下，这些东西我早忘记了….一点印象都没有…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this关键字</title>
      <link href="posts/75f5b5c3.html"/>
      <url>posts/75f5b5c3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>this.的方式</code>，区分局部变量和成员变量同名情况</p><p>除此之外，this还可以在构造方法之间调用，语法格式是<code>this()</code>,而且<strong>只能写在构造方法的第一行</strong></p><p>代码理解：</p><p>创建一个人，出生的时候如果不初始化，默认给一个name和age代码，不是null和0，是指定的数字</p><p>如果不用this，代码可以这样表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getset省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到无论是有参构造器还是无参构造器，两个方法的作用都是给对象的成员变量初始化，所以如果一个方法调用另一个方法，可以使代码减少很多</p><p>正确的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//调用了有参数的构造方法</span></span><br><span class="line"><span class="comment">//参数李四,20传递给了变量name,age</span></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  构造方法,传递String,int</span></span><br><span class="line"><span class="comment"> *  在创建对象的同时为成员变量赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getset省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立对象的时候，如果没有指定参数，就会默认调用无参构造器，其中的<code>this(&quot;李四&quot;,20);</code>调用有参构造，然后给成员变量初始化，就会达到，建立对象的同时给成员变量赋值的效果</p><p>注意：<strong>调用其他构造方法的语句必须<font color=red>定义在构造方法的第一行</font>，原因是初始化动作要最先执行。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于构造方法</title>
      <link href="posts/7b749a13.html"/>
      <url>posts/7b749a13.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>构造方法的作用就是: 在new 的同时对成员变量赋值, 给对象的属性初始化赋值  new Person 对属性 name,age赋值</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限  方法名(参数列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>方法的名字,必须和类的名字完全一致</p><p>构造方法不允许写返回值类型  , void 也不能写</p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>构造方法在new 的时候,自动执行，而且只允许一次</p><p>每个类必须拥有构造方法，不写也有，编译的时候，javac, 会自动检查类中是否有构造方法，如果有,就这样的，如果没有,编译器就会自动添加一个构造方法</p><p> 编译器自动添加的构造方法: public Person(){}</p><p>自己手写了构造方法,编译的时候,不会自动添加构造方法!</p><h1 id="内存详解"><a href="#内存详解" class="headerlink" title="内存详解"></a>内存详解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person的构造方法，拥有参数列表</span></span><br><span class="line">Person(<span class="keyword">int</span> age, String name) &#123;</span><br><span class="line"><span class="comment">// 接受到创建对象时传递进来的值，将值赋给成员属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">set/get省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建Person对象，并明确对象的年龄和姓名</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序最开始，main方法压栈运行，执行<code>Person p = new Person(23, &quot;张三&quot;);</code>,堆内存会出现一块空间给Person，成员变量 跟随对象 创建进入堆内存，并且初始化默认值，0与null,，然后接着<strong>对象会调用自己的构造方法</strong>，构造方法会进入栈内存运行</p><p>构造方法压栈运行，对象会将最初的<code>张三</code>与<code>23</code>传给构造方法，将自己的内存地址传给this关键字，然后赋值成员变量，构造方法运行完成后，弹栈死亡，<strong>构造方法运行结束了，整个对象才算建立完成</strong>，然后p指向对象地址</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201024160045.png"></p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><ol><li>一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的,根据自己需求</li><li>构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。<em>这个应该就是应对考试的，记一下吧</em></li></ol><h1 id="构造方法和一般方法区别"><a href="#构造方法和一般方法区别" class="headerlink" title="构造方法和一般方法区别"></a>构造方法和一般方法区别</h1><ol><li>构造方法在对象创建时就执行了，而且只执行一次。<strong>是对象调用的</strong></li><li>一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。<strong>是我们自己调用的</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态向上与向下转型</title>
      <link href="posts/fc8e9806.html"/>
      <url>posts/fc8e9806.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h1><p>多态中特有的体现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类的引用 变量 = new 子类的对象();</span><br></pre></td></tr></table></figure><p>java是一门强制数据类型的语言，参数运算的数据，保证类型的统一性，</p><p>如果数据类型不一致的时候，只有两种情况，一种是<code>自动类型提升</code>，一种是<code>强制类型转换</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fu f = new Zi();</span><br></pre></td></tr></table></figure><p>这条语句明显左右两边类型不一样，但是编译运行的时候，却不受影响，只有上面说的两种情况，但是我没有参与，也就是强制转换其他类型，它只有一种解释，就是<code>自动类型提升</code>, </p><p>所谓自动类型提升就是，将取值范围小的自动提升为取值范围大的，而引用数据类型没有取值范围这个概念，但是原理都是一样的，范围小的看成是子类，范围大的看成是父类，<code>Fu f = new Zi();</code>这行代码，f就是父类类型，将子类提升为了父类类型，这个提升就是<code>向上转型</code>。</p><p><strong>实际上，当new 子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。</strong></p><p>向上转型的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：Person p = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><p>向上转型只能调用子类和父类的公有内容，这也是多态的一个好处，但是也有弊端，就是不能调用子类的特有方法，但是可以向下转型</p><h1 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h1><p>多态调用，如果要调用子类的特有内容，可以向下转型，父类类型强制转换子类类型，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fu f = <span class="keyword">new</span> Zi();<span class="comment">//多态调用，f向上转型，现在下一步我要调用子类特有方法</span></span><br><span class="line">Zi z = (Zi)f;    <span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><p>一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！</p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类类型的变量;</span><br><span class="line">如:Student stu = (Student) p;  </span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>什么时候使用向上转型</p><p>当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。</p></li><li><p>什么时候使用向下转型</p><p>当要使用子类特有功能时，就需要使用向下转型。</p></li><li><p>向下转型的好处：可以使用子类特有功能。</p></li><li><p>弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。</p><p>如：if( !a instanceof Dog){…}</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态概述以及成员特点</title>
      <link href="posts/47b88999.html"/>
      <url>posts/47b88999.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多态概述"><a href="#多态概述" class="headerlink" title="多态概述"></a>多态概述</h1><p>我理解的多态就是<code>同一种事物的多种形态</code></p><p>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。</p><p>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</p><p>Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。</p><p>如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。</p><h1 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h1><ul><li>父类引用变量可以指向子类对象</li><li>多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。</li><li>在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</li></ul><h1 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h1><ol><li><p>先看成员变量</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 建立一个测试类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(f.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 控制台会显示1,也就是父类的成员变量值，他没有走子类的</p></li><li><p>如果是方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        f.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 控制台会显示zi,也就是子类的重写方法</p></li></ol><blockquote><p>总结</p><ol><li><p>成员变量:</p><p> 编译的时候, 参考父类中有没有这个变量,如果有,编译成功,没有编译失败</p><p> 运行的时候, 运行的是父类中的变量值<br><font color=#b33b63> <strong><em>编译运行全看父类</em></strong></font></p></li></ol><ol start="2"><li><p>成员方法:</p><p>   编译的时候, 参考父类中有没有这个方法,如果有,编译成功,没有编译失败</p><p>   运行的时候, 运行的是子类的重写方法</p><p>   <font color=#b33b63><strong><em>编译看父类，运行看子类</em></strong></font></p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo绑定个人域名</title>
      <link href="posts/d026edc8.html"/>
      <url>posts/d026edc8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h1><ol><li><p>先进入桌面, <code>cd 你的hexo本地目录</code>, <code>cd source</code>, <code>touch CNAME</code>创建CNAME文件，写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shuigwh.cn</span><br></pre></td></tr></table></figure></li><li><p>保存,部署远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li></ol><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>www是<code>xxxx.github.io</code></p><p>@对应的是<code>xxxx.github.io</code>的IP，可以ping拿到IP</p><p>即</p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>记录值</th></tr></thead><tbody><tr><td>www</td><td>CNAME</td><td>xxxx.github.io</td></tr><tr><td>@</td><td>A</td><td>xxx.xxx.xxx.xxx</td></tr></tbody></table><p>然后保存，这个时候等一会就可以访问了，但是只能访问http://的形式</p><p>到远程库的设置里面，<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201023142757.png"></p><p>将这个https勾选，保存即可</p><p>过一会就可以访问https://的形式了</p><blockquote><p>参考：<a href="https://blog.csdn.net/yucicheung/article/details/79560027">https://blog.csdn.net/yucicheung/article/details/79560027</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承，实现总结</title>
      <link href="posts/1eedea8a.html"/>
      <url>posts/1eedea8a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p><code>类与类</code>之间是继承关系，只能单继承，子类自动继承父类的所有数据，即成员变量和方法</p><blockquote><p> 注意：抽象类，其中可以包含抽象方法，也可以包含具体的方法，但是如果有抽象方法，这个类一定是抽象类</p><p> 类继承抽象类，要重写抽象类里面的所有抽象方法</p></blockquote><blockquote><p>接口，里面只能包含常量（默认public static final）与抽象方法(默认public abstract),就算不写修饰符，也就是public static final abstract 这些，也是可以的</p></blockquote></li><li><p><code>类与接口</code>的之间是实现关系(implement)，可以多实现接口，一旦类实现接口，必须要重写接口里面的所有抽象方法</p></li><li><p><code>接口与接口</code>之间是继承(extends)，支持多继承（因为都是抽象方法，所以不像类只能单继承，存在安全隐患）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于接口与继承的理解</title>
      <link href="posts/18276965.html"/>
      <url>posts/18276965.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="继承的弊端"><a href="#继承的弊端" class="headerlink" title="继承的弊端"></a>继承的弊端</h1><p>在Java中，继承不能多继承，也就是一个类只能继承一个类，不能继承多个类，举个列子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bbbb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在来一个类叫C，c同时继承A 和B类，当实例化c的时候，调用父类的function方法时候,这个时候就不知道应该调用那个类中的function方法了，这也是继承的局限性</p><h1 id="接口的好处"><a href="#接口的好处" class="headerlink" title="接口的好处"></a>接口的好处</h1><p>所以就有了接口，Java中，一个类可以实现多个接口，也可以理解同时继承多个接口，但是和继承不同的是，接口里面的方法全是抽象方法，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是两个接口，里面的方法都是一样的，建立一个C类，实现这两个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口要重写里面的抽象方法，由于抽象方法名字都是一样的，所以写一次就可以了，接口的里面的方法全都是抽象的，即使名字一样也不要紧，由实现接口的类自己定，所以它和继承不一样</p><blockquote><p>总结：类的多继承，当多个父类中有相同功能时，子类调用会产生不确定性，所以会存在安全隐患，<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口的多实现，没有安全隐患，原因在于接口中的方法全是抽象，没有主体</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用数据类型传参</title>
      <link href="posts/626c8828.html"/>
      <url>posts/626c8828.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引用数据类型传参会涉及到堆内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        System.out.println(p.name);<span class="comment">//张三</span></span><br><span class="line">        function(p);</span><br><span class="line">        System.out.println(p.name);<span class="comment">//李四</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> statc <span class="keyword">void</span> <span class="title">function</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        p.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序开始运行，main方法先压栈执行，<code>Person p = new Person();</code>堆内存会开辟一块内存空间，Person对象，成员变量name随着对象建立一起进入堆内存，并且赋初值null,此内存地址假设是0x01，c变量会指向堆内存的0x01地址，<code>p.name = &quot;张三&quot;;</code>null被<code>张三</code>覆盖，接着打印p.name,会显示张三</p><p>运行<code>function(p)；</code>,function方法会压栈执行，传参给的其实p中保存的地址，所以function方法中的p也指向堆内存的内存地址0x01,此时两个变量p都指向了同一片内存空间地址，function方法中<code>p.name=&quot;李四&quot;</code>,原来的张三又被李四覆盖，function方法运行完毕，function方法就会弹出栈内存死亡，main方法继续运行<code> System.out.println(p.name);</code>，控制台会显示李四</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021140357.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成员变量和局部变量区别</title>
      <link href="posts/40dd4c9d.html"/>
      <url>posts/40dd4c9d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>定义位置上的区别</p><p>成员变量，定义在类中，方法外</p><p>局部变量，方法内，语句外</p></li><li><p>作用域不同</p><p>成员变量，作用范围是整个类</p><p>局部变量，方法内，语句内</p></li><li><p><font color=green><strong>默认值不同</strong></font></p><p>成员变量有自己的默认值（对象在内存中的理解说过）</p><p><font color = red><strong>局部变量，没有默认值，不赋值不能使用</strong></font></p></li><li><p><font color=green><strong>内存位置不同（对象在内存中的理解说过）</strong></font></p><p>成员变量，跟随对象进入堆内存存储</p><p>局部变量，跟随自己的方法，进入栈内存</p></li><li><p><font color=green><strong>生命周期不同</strong></font></p><p>成员变量，跟随对象，在堆内存中存储，等待JVM（虚拟机）清理          生命周期较长</p><p>局部变量，跟随方法，方法出栈                                                                                    生命周期较短</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象在内存中的理解</title>
      <link href="posts/576f6a89.html"/>
      <url>posts/576f6a89.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中有栈内存和堆内存</p><p><code>栈内存</code>是运行方法用的，<code>堆内存</code>是存储容器用的</p><p><del>一个完整的Java程序如果要运行，先从main方法进行，main先压栈，new出来的对象实力，在堆内存里面</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小汽车在跑&quot;</span>+color+<span class="string">&quot;..&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Car c = <span class="keyword">new</span> Car();</span><br><span class="line">        c.color = <span class="string">&quot;无色&quot;</span>;</span><br><span class="line">        c.count = <span class="number">5</span>;</span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一个完整的Java程序,一个car类，一个测试类</p><p>程序开始运行</p><p>main先压栈，运行第一行代码<code>Car c = new Car();</code>，Java虚拟机会在堆内存开辟一快空间，有了空间，就会有属于自己的内存地址</p><p>例如这个地址是<code>0x001</code>,这块空间是new car 创建的</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021123430.png" style="zoom: 80%;" /><p>对象在对内存创建后，类的成员变量，会跟随对象进入到堆内存中，并且会赋值默认值，这个默认值是更加成员变量的类型而定的，就比如<code>Car c = new Car()</code>,如果后面没有赋值，那么他的成员变量的默认值就是<code>null</code>和<code>0</code>，即下图：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021124434.jpg" style="zoom: 67%;" /><p>这就是<code>new Car();</code>在堆内存中的执行时的示意图</p><p>此时对象就建立完成了，然后Java虚拟机就会将这个对象内存地址传送给引用变量c,c就会指向这片内存空间，即</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021125009.jpg" style="zoom:80%;" /><p>所以，真正的对象是new出来的，而c保存的其实是对象内存的地址，所以，直接把c叫做car类的变量也没有问题</p><p>接着，main开始运行下一条代码，<code>c.color = &quot;无色&quot;;</code>，相应的，堆内存中的<code>null</code>会被<code>无色</code>覆盖，<code>c.count = 5;</code>堆内存中的<code>0</code>会被<code>5</code>覆盖</p><p>当程序执行<code>c.run();</code>，类中的方法run就会进栈执行，虚拟机会再次开辟空间是run方法压栈运行</p><p>run方法中只有一句<code>System.out.println(&quot;小汽车在跑&quot;+color+&quot;..&quot;+count);</code>,其中的color与count可以这样理解，方法run是对象c调用，那么其中的color和count指的就是对象c的成员变量，所以<code>无色</code>和<code>5</code>就会被打印到控制台上，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021131215.jpg" style="zoom: 80%;" /><p>打印完成后，run方法就会结束，run方法就要出栈死亡，这个过程叫弹栈，弹出栈内存死亡，死亡了，内存就会被释放</p><p>main也随即运行完成了，也会弹出栈内存死亡，释放内存</p><p>main死亡之后，变量c将不会再指向堆内存的对象地址，所以这个对象在内存中也会变成垃圾    </p><blockquote><p> 这里要说一下，栈内存中的方法用完了就会释放，空间就会出来了，而堆内存中的对象或者是数组，它自己不会释放，他要等着虚拟机清理，而虚拟机清理垃圾是不需要我们考虑的，它属于自动行为</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---定状同从句</title>
      <link href="posts/c9325fa6.html"/>
      <url>posts/c9325fa6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131032.png"></p><p>以下这些词都可以用同位语从句进行解释</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131122.png" style="zoom:67%;" /><p>例句：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131347.png" style="zoom:80%;" /><blockquote><p>同位语从句有很多连接词，但是百分之99都是that</p></blockquote><h1 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h1><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131753.png" style="zoom: 80%;" /><h2 id="连词"><a href="#连词" class="headerlink" title="连词"></a>连词</h2><h3 id="修饰人-who-whom"><a href="#修饰人-who-whom" class="headerlink" title="修饰人(who/whom)"></a>修饰人(who/whom)</h3><ol><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132039.png" style="zoom:67%;" /></li><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132137.png" style="zoom:67%;" /></li></ol><h3 id="修饰物（that-which）"><a href="#修饰物（that-which）" class="headerlink" title="修饰物（that/which）"></a>修饰物（that/which）</h3><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019140350.png" style="zoom:67%;" /><p>其中that和which不能乱用</p><p>这种情况只能用that，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132706.png" style="zoom:67%;" /><blockquote><p> 先行词就是被修饰的那个名词</p></blockquote><h3 id="修饰句，表示总结（which）"><a href="#修饰句，表示总结（which）" class="headerlink" title="修饰句，表示总结（which）"></a>修饰句，表示总结（which）</h3><p>这种情况只能用which，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132929.png" style="zoom:67%;" /><h4 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h4><p><strong><font color='green'><em>修饰句，表示总结</em></font></strong></p><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019133201.png" style="zoom:67%;" /><p>这就是修饰的前面整句话，所以必须用which，必须用<code>,</code></p><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019134710.png" style="zoom:67%;" /><p>这句话，如果不用定语从句，这句话是这样翻译的：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019134757.png" style="zoom:80%;" /><p>这是两个简单句，完全可以。</p><p>如果用定语从句可以这样</p><p>分析：</p><p><code>这</code>修饰前面的<code>中国的经济正迅速发展</code>这句话，所以是定语从句，所以也可以这样写，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135028.png" style="zoom:80%;" /><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135509.png" style="zoom:67%;" /><h2 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h2><ul><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135729.png" style="zoom:80%;" /></li><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019140523.png" style="zoom: 80%;" /></li></ul><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><blockquote><p>做阅读可能会遇到下面的几个情况</p></blockquote><p><strong><em><font color='green'>介词+which</font></em></strong></p><p>这也是定语从句，翻译方法：</p><ol><li>介词先砍掉，</li><li>然后把介词放到从句里面去</li></ol><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141059.png"></p><p>分析：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141152.png"></p><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141234.png"></p><p>分析：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141333.png" style="zoom:80%;" /><hr><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019142136.png" style="zoom:80%;" /><blockquote><p><font color='brown'><strong>连词如果在定语从句中做宾语是可以省略的</strong></font>，这里要注意，可能阅读会有陷阱</p></blockquote><h1 id="状语从句"><a href="#状语从句" class="headerlink" title="状语从句"></a>状语从句</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019143906.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度云在线视频加速方法</title>
      <link href="posts/9ced7ac.html"/>
      <url>posts/9ced7ac.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>网页版百度网盘视频今天看着有点慢，想加速，搜了一下，防止遗忘，在此记录一下</p></blockquote><p>打开网页版，然后打开控制台，输入以下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">videojs.getPlayers(<span class="string">&quot;video-player&quot;</span>).html5player.tech_.setPlaybackRate(<span class="number">1.5</span>) </span><br></pre></td></tr></table></figure><p>这是1.5倍播放，需要多少，直接在后面改参数就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 实用小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百度网盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---主宾表从句</title>
      <link href="posts/ca22eae1.html"/>
      <url>posts/ca22eae1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="从句概念"><a href="#从句概念" class="headerlink" title="从句概念"></a>从句概念</h1><p>一句话做定语=定语从句</p><p>一句话做宾语=宾语从句</p><p>一句话做表语=表语从句</p><h1 id="主从句之间的连接"><a href="#主从句之间的连接" class="headerlink" title="主从句之间的连接"></a>主从句之间的连接</h1><p>桥梁：连词</p><h2 id="连词一（从句完整）"><a href="#连词一（从句完整）" class="headerlink" title="连词一（从句完整）"></a>连词一（从句完整）</h2><p><strong><em>that/whether/if</em></strong></p><p>从句完整的时候用that连接</p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225156.png" style="zoom:50%;" /><p>有时候也用whether或者if</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225331.png" style="zoom:50%;" /><p>注意，不能使用if的情况</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225431.png" style="zoom:67%;" /><p>所以为了方便，一直用whether就可以了</p><h2 id="连词二（从句缺人）"><a href="#连词二（从句缺人）" class="headerlink" title="连词二（从句缺人）"></a>连词二（从句缺人）</h2><p><strong><em>who/ whom</em></strong></p><ul><li><p>who是在从句中做主语</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225926.png" style="zoom: 80%;" /></li><li><p>whom是在从句中做宾语</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230129.png" style="zoom:80%;" /></li></ul><p>举例：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230343.png" style="zoom:80%;" /><h2 id="连词三（从句缺物）"><a href="#连词三（从句缺物）" class="headerlink" title="连词三（从句缺物）"></a>连词三（从句缺物）</h2><p><strong><em>what</em></strong></p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201018122713.png" style="zoom:67%;" /><h2 id="连词四（从句需状语）"><a href="#连词四（从句需状语）" class="headerlink" title="连词四（从句需状语）"></a>连词四（从句需状语）</h2><p><strong><em>when(时间)/where（地点）/why（原因）/how（方式）</em></strong></p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230758.png" style="zoom: 80%;" /><h1 id="翻译从句的方法"><a href="#翻译从句的方法" class="headerlink" title="翻译从句的方法"></a>翻译从句的方法</h1><p>先把连词放在句子的空缺处，然后从左往右翻译</p><h1 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h1><h2 id="特殊主语从句"><a href="#特殊主语从句" class="headerlink" title="特殊主语从句"></a>特殊主语从句</h2><p>有道题是这样的</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232551.png" style="zoom: 80%;" /><p>这种情况是错误的，出现了两个动词</p><p>解决方法：</p><p>可以加个that</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232717.png"></p><p>但是前面有点长，要避免头重脚轻，把that引动的从句放到后面，前面加个形式主语it</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232847.png"></p><h1 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h1><h2 id="在及物动词后作宾语"><a href="#在及物动词后作宾语" class="headerlink" title="在及物动词后作宾语"></a>在及物动词后作宾语</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233317.png"></p><h2 id="在介词后面作宾语"><a href="#在介词后面作宾语" class="headerlink" title="在介词后面作宾语"></a>在介词后面作宾语</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233423.png"></p><p>宾从例句：</p><p>​    <img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233754.png" style="zoom: 67%;" /></p><h1 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234424.png"></p><p>这是个简单句，不是表语从句</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234452.png"></p><p>表语从句</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234929.png" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---句子成分</title>
      <link href="posts/92acea72.html"/>
      <url>posts/92acea72.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="主语"><a href="#主语" class="headerlink" title="主语"></a>主语</h1><p> 动作发出者</p><h2 id="找主语的方法"><a href="#找主语的方法" class="headerlink" title="找主语的方法"></a>找主语的方法</h2><ol><li>谓语动词的前面</li></ol><h1 id="宾语"><a href="#宾语" class="headerlink" title="宾语"></a>宾语</h1><p>动作承受者  名词类（及物动词后面的全是宾语）</p><p>动词不能直接做宾语，要修改成名词</p><p>动词 —&gt; 名词  的方法</p><pre><code>                                   1. to do                                                        2. doing</code></pre><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015132831.png"></p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015133020.png"></p><h2 id="找宾语的方法："><a href="#找宾语的方法：" class="headerlink" title="找宾语的方法："></a>找宾语的方法：</h2><ol><li>介词后面的</li><li>及物动词后面的</li></ol><h2 id="介宾结构"><a href="#介宾结构" class="headerlink" title="介宾结构"></a>介宾结构</h2><p>介词只能加，名词/doing/宾格，其他都是错的</p><h1 id="表语"><a href="#表语" class="headerlink" title="表语"></a>表语</h1><p>修饰主语, 名词或者形容词类</p><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015170014.png"></p><blockquote><p>改变世界还没有完成，所以用to do </p></blockquote><p>这里为什么要加个the</p><p>the的用法：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015170453.png"></p><h2 id="找表语的方法"><a href="#找表语的方法" class="headerlink" title="找表语的方法"></a>找表语的方法</h2><p>​    系动词后面的</p><p>​    凡是能用be动词替换的，包括be本身，都是主系表结构</p><h1 id="定语"><a href="#定语" class="headerlink" title="定语"></a>定语</h1><p>概念： 修饰名词的</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015171502.png"></p><p>当动词是doing，修饰名词，这个doing代表一个功能</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015171902.png"></p><p>定于可以在前面也可以在后面，当在前面的时候很简单，很短，</p><p>当在后面的时候一般都很复杂，要么是<code>to do</code>要么是<code>介词短语</code></p><h1 id="状语"><a href="#状语" class="headerlink" title="状语"></a>状语</h1><p>修饰形容词，动词，句子</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015172558.png" style="zoom:50%;" /><h1 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a>同位语</h1><p>修饰且等于名词</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015173540.png" style="zoom: 80%;" /><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015174440.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---句子结构</title>
      <link href="posts/5d143ecd.html"/>
      <url>posts/5d143ecd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="三个基本结构"><a href="#三个基本结构" class="headerlink" title="三个基本结构"></a>三个基本结构</h1><ol><li>主谓宾</li><li>主谓</li><li>主系表</li></ol><h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><ol><li><p>及物动词（有对象）</p></li><li><p>不及物动词</p><p>1和2叫实义动词</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014164711.png"></p></li><li><p>系动词（能用be替换）</p><p>​    例如：<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201014160925.png">，<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201014161100.png">，</p><p>​    <strong><em>凡是能用be动词替换的，包括be本身，都是主系表结构</em></strong></p></li><li><p>助词</p><p>时态，情态，否定</p></li></ol><hr><p>及物动词引导主谓宾，不及物动词引导主谓，系动词引导主系表</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014165529.png"></p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014165749.png"></p><p>判断结构</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014170701.png"></p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>可以先将代表修饰的词删掉<img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014170508.png"></p><h1 id="三大特殊结构"><a href="#三大特殊结构" class="headerlink" title="三大特殊结构"></a>三大特殊结构</h1><ol><li><p>主谓宾宾</p></li><li><p>主谓宾补</p></li><li><p>强调句</p><p>1和2  宾宾和宾补可以在中间加个be动词进行连接，可以连接的是宾补，不能的就是宾宾<br><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014173513.png"></p></li></ol><h2 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h2><p>格式：</p><p>​        强调主语：it is  + 人 +   who<br>​        强调状语：it is  + 物 +   that</p><hr><p>强调谁，就把谁放在前面，剩下的部分原封不动放在后面</p><p>举例：</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014174507.png"></p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git命令</title>
      <link href="posts/f2b26283.html"/>
      <url>posts/f2b26283.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这几个命令怕以后忘记了，单独开个博文记录一下</p></blockquote><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="添加暂存区"><a href="#添加暂存区" class="headerlink" title="添加暂存区"></a>添加暂存区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;信息&quot;</span></span><br></pre></td></tr></table></figure><h2 id="推送远程库"><a href="#推送远程库" class="headerlink" title="推送远程库"></a>推送远程库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;远程地址&gt;</span><br><span class="line">git branch -M origin main</span><br><span class="line">git push -u origin &lt;main&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git status  //查看状态</span><br><span class="line">git reset //可以撤回git add的内容</span><br><span class="line">git reset --soft HEAD^ //可以撤销git commit的内容，但是写的代码仍然保留</span><br></pre></td></tr></table></figure><p>如果commit注释写错了，只是想改一下注释，只需要：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>此时会进入默认vim编辑器，修改注释完毕后保存就好了。</p><h2 id="用于迁移"><a href="#用于迁移" class="headerlink" title="用于迁移"></a>用于迁移</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main //主分支和main分支合并</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git配置与仓库迁移</title>
      <link href="posts/2ad68004.html"/>
      <url>posts/2ad68004.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的账号不要了，上面的仓库需要迁移</p><p>于是….</p><p>就出现了很多问题，下面主要就记录下</p><h2 id="github加速"><a href="#github加速" class="headerlink" title="github加速"></a>github加速</h2><h3 id="有代理"><a href="#有代理" class="headerlink" title="有代理"></a>有代理</h3><p>我用的是v2rayn,查看端口号是<code>10808</code>,然后在<code>C:\Users\UserName\.gitconfig</code>文件添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">    proxy = http://127.0.0.1:10808</span><br><span class="line">[https]</span><br><span class="line">    proxy = http://127.0.0.1:10808</span><br></pre></td></tr></table></figure><p>，当然命令也可以，这里是直接打开文件添加，这是http的方式</p><p>ssh的方式是这样，打开<code>C:\Users\UserName\.ssh</code>,新建<code>config</code>文件填写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyCommand connect -S 127.0.0.1:10808 %h %p</span><br></pre></td></tr></table></figure><h3 id="无代理"><a href="#无代理" class="headerlink" title="无代理"></a>无代理</h3><p>我最先用的就是无代理，网上介绍代理全是ss,v2rayn我以为不可以，后来在一个<a href="https://www.youtube.com/watch?v=hKBhOXlQc4c&ab_channel=%E6%9D%9C%E8%BF%9C%E8%B6%85%E5%AE%98%E6%96%B9%E9%A2%91%E9%81%93">youtube</a>视频评论下残看到的原来端口号不一样</p><p>没有代理就在<code>C:\Windows\System32\drivers\etc</code>中host文件，写这两行</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009144812.png"></p><p>IP地址有时候会变，每次在这里<a href="https://www.ipaddress.com/%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%8B%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%9F%A5%E5%88%B0%E7%9A%84IP%E5%86%99%EF%BC%8C%E8%BF%99%E6%98%AFhttp%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86">https://www.ipaddress.com/查询一下，根据查到的IP写，这是http的方式，然后就可以了</a></p><p>实话实说，感觉利用梯子效果更好，这种改host文件的方法感觉没什么变化</p><h2 id="git的配置"><a href="#git的配置" class="headerlink" title="git的配置"></a>git的配置</h2><h3 id="添加key"><a href="#添加key" class="headerlink" title="添加key"></a>添加key</h3><p>清除之前的公钥和密钥文件，重新生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>一路回车</p><p>生成的公钥添加到github账号上面</p><p>然后验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 你的英文名     <span class="comment">#此英文名不需要跟GitHub账号保持一致</span></span><br><span class="line">git config --global user.email 你的邮箱      <span class="comment">#此邮箱不需要跟GitHub账号保持一致</span></span><br><span class="line">git config --global push.default matching</span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global core.editor <span class="string">&quot;vim&quot;</span></span><br></pre></td></tr></table></figure><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>因为我之前clone下的远程库有之前的地址，我要改一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:xxxxx.git</span><br></pre></td></tr></table></figure><p>master迁移到main分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main </span><br></pre></td></tr></table></figure><p>可以推送新的仓库了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main </span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/148110705?utm_source=qq&amp;utm_medium=social&amp;utm_oi=882705482219917312">https://zhuanlan.zhihu.com/p/148110705?utm_source=qq&amp;utm_medium=social&amp;utm_oi=882705482219917312</a></p><p><a href="https://zhuanlan.zhihu.com/p/48209762">https://zhuanlan.zhihu.com/p/48209762</a></p><p><a href="https://os.51cto.com/art/202009/627539.htm">https://os.51cto.com/art/202009/627539.htm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github图片，jsdelivr加速不能访问</title>
      <link href="posts/ed109295.html"/>
      <url>posts/ed109295.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>百度搜索关于cdn jsdelivr picgo github图床一堆，我这里就不重新写了，主要写遇到的问题，picgo配置好了，也可以正常上传，但是一旦用jsdelivr链接加速就是访问不了，百度上面连接都是这也写的</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn.jsdelivr.net/gh/用户名/仓库名</a></p></blockquote><p> 所以我最初写的也是<br><code>https://cdn.jsdelivr.net/gh/cloudvillager/cloud/img/20201009135759.png</code>看着没有问题，但是就是不对，一直访问是</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009140831.png"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>猜测是和github默认分支改成main的原因</p><p>github这个月开始，新建仓库都是<code>main</code>作为主分支，原来<code>master</code>已经不用了,可能不指定分支，默认访问的就是master</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在用jsdelivr加速的时候，指定一下main分支,格式是</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/%7BGithub%E7%94%A8%E6%88%B7%E5%90%8D%7D/%7BGithub%E4%BB%93%E5%BA%93%E5%90%8D%7D@%7B%E7%89%88%E6%9C%AC%E5%90%8D%7D/%7B%E4%BB%93%E5%BA%93%E4%B8%8B%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%7D">https://cdn.jsdelivr.net/gh/{Github用户名}/{Github仓库名}@{版本名}/{仓库下资源路径}</a></p></blockquote><p>例如： <a href="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009135759.png">https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009135759.png</a></p><p>就可以访问了</p><hr><p>参考：</p><blockquote><p><a href="https://www.dazhuanlan.com/2020/03/26/5e7c9c9250cb8/?__cf_chl_jschl_tk__=ef5bbb49c273a87d67426449fa2defbac0dfa6e7-1602224791-0-AYlVlW0tHM7FK5Qhf5aEkX6pJ7S5DHPQVpmNoGVMhVOnqXxWhsdpPA9auCrFSdnIkctDqUWuxA6FoL7wdAnceIQAR1wGVkhzYKXZPOhD9Yzu4AWYMr40e1N0qT05isp__Jxq01aqydGOL2FNQMogmatShYr3_IFtqmybF0eamnkLMq28fgCsy-DBU91oAt5PTSqqR7oZogV9J8-wNtpyWbH40mAjPVFsBckeQWHVOQNfAQCfnJeXUPTuPWFo50wshnJgyqHYmWrc0VtxXnz2jGaSi08cBy3BmVwnrmBPmKz7fdf1ZiuEElBT-9UmnsejAQ">https://www.dazhuanlan.com/2020/03/26/5e7c9c9250cb8/?__cf_chl_jschl_tk__=ef5bbb49c273a87d67426449fa2defbac0dfa6e7-1602224791-0-AYlVlW0tHM7FK5Qhf5aEkX6pJ7S5DHPQVpmNoGVMhVOnqXxWhsdpPA9auCrFSdnIkctDqUWuxA6FoL7wdAnceIQAR1wGVkhzYKXZPOhD9Yzu4AWYMr40e1N0qT05isp__Jxq01aqydGOL2FNQMogmatShYr3_IFtqmybF0eamnkLMq28fgCsy-DBU91oAt5PTSqqR7oZogV9J8-wNtpyWbH40mAjPVFsBckeQWHVOQNfAQCfnJeXUPTuPWFo50wshnJgyqHYmWrc0VtxXnz2jGaSi08cBy3BmVwnrmBPmKz7fdf1ZiuEElBT-9UmnsejAQ</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> jsdelivr </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 本地拒绝连接远程库问题 错误403</title>
      <link href="posts/9fcda5d2.html"/>
      <url>posts/9fcda5d2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下午本来想推送一下网站的<code>hexo d</code>然后一直报错</p><blockquote><p>On branch master<br>nothing to commit, working tree clean<br>remote: Permission to cloudvillager/cloudvillager.github.io.git denied to shuimqs.<br>fatal: unable to access ‘<a href="https://github.com/cloudvillager/cloudvillager.github.io.git/&#39;">https://github.com/cloudvillager/cloudvillager.github.io.git/&#39;</a>: The requested URL returned error: 403</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>报错信息大概意思就是，我之前登陆 了别的github账户，现在要推送到另一个账户，推不上去，拒绝访问，这不废话嘛，肯定推不了，找了好久，其实吧报错信息往谷歌里面一方，出来的就是答案，和我遇到的情况一样，<a href="https://stackoverflow.com/questions/47465644/github-remote-permission-denied%EF%BC%8C">https://stackoverflow.com/questions/47465644/github-remote-permission-denied，</a> 不过我看不懂，后来这里找到了答案， <a href="https://blog.csdn.net/klxh2009/article/details/76019742%EF%BC%8C">https://blog.csdn.net/klxh2009/article/details/76019742，</a> 然后看这不就是我之前看的那个链接吗，感觉一样，后来发现确实一样。。。</p><p>在看看下面评论都挺好的，再看看，之前那个国外网站是17年，这个csdn是19年发的。。英语太重要了。</p><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201007165000.png"></p><p>就是这里，普通凭据那里，找到<code>  git:https://github.com</code>删除就可以了，然后<code>hexo d</code>就可以推送成功了</p><p>参考：</p><blockquote><p><a href="https://blog.csdn.net/klxh2009/article/details/76019742">https://blog.csdn.net/klxh2009/article/details/76019742</a><br><a href="https://stackoverflow.com/questions/47465644/github-remote-permission-denied">https://stackoverflow.com/questions/47465644/github-remote-permission-denied</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="posts/d87f7e0c.html"/>
      <url>posts/d87f7e0c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>docker adf</p><blockquote><p>afd fasd</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>test</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
