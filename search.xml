<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>抽象类与接口的区别</title>
      <link href="posts/4a128e89.html"/>
      <url>posts/4a128e89.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>举例：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">犬：</span><br><span class="line">    行为：</span><br><span class="line">        吼叫；</span><br><span class="line">        吃饭；</span><br><span class="line">缉毒犬：</span><br><span class="line">    行为：</span><br><span class="line">        吼叫；</span><br><span class="line">        吃饭；</span><br><span class="line">        缉毒；</span><br></pre></td></tr></table></figure></li><li><p>思考</p><p> 由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。</p><p> 可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。</p><p> 代码演示：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 缉毒</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 缉毒();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义犬科的这个提醒的共性功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 犬科</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 吃饭();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> 吼叫();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，</span></span><br><span class="line"><span class="comment">//由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> 缉毒犬 <span class="keyword">extends</span> 犬科 <span class="keyword">implements</span> 缉毒</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 缉毒() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 吃饭() &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> 吼叫() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> 缉毒猪 <span class="keyword">implements</span> 缉毒</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> 缉毒() &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>通过上面的例子总结：</p><p> <strong>相同点:</strong></p><ul><li><p>都位于继承的顶端,用于被其他类实现或继承;</p></li><li><p>都不能直接实例化对象;</p></li><li><p>都包含抽象方法,其子类都必须覆写这些抽象方法;</p></li></ul><p> <strong>区别:</strong></p><ul><li><p>抽象类为部分方法提供实现,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;</p></li><li><p>一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)</p></li><li><p>抽象类是这个事物中应该具备的你内容, 共性</p></li><li><p>接口是这个事物中的额外内容,</p><blockquote><p>抽象类是同一个事物的共性，</p><p>而接口就是额外多出来的功能，他有你没有，你有我没有，并不是大家都有的功能</p></blockquote></li></ul><p> <strong>二者的选用</strong>：</p><ul><li><p>优先选用接口,尽量少用抽象类;</p></li><li><p>需要定义子类的行为,又要为子类提供共性功能时才选用抽象类;</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>instanceof关键字</title>
      <link href="posts/15b3e85e.html"/>
      <url>posts/15b3e85e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Java中有个关键字叫<code>instanceof</code>，返回值是true或者false</p><p>它是用来比较引用数据类型的关键字，一个引用类型的变量,是不是这个类型的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;学生在休息睡觉&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;老师在休息&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码，建立一个抽象类Person，定义抽象方法sleep（），再建立学生类与老师类继承Person类，重写抽象方法</p><p>建立对象的时候，利用多态性，可以这样写</p><p><code>Person p = new Student();</code>也可以<code>Person p = new Teacher();</code>，</p><p>而instanceof就可以用来比较这个p是是Student类型对象,还是Teacher类型对象</p><p>写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">引用变量 <span class="keyword">instanceof</span> 类名</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p <span class="keyword">instanceof</span> Student  <span class="comment">//比较,p是不是Student类型的对象,如果是,intanceof返回true</span></span><br></pre></td></tr></table></figure><p>附上test类代码以及结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = p <span class="keyword">instanceof</span> Student;</span><br><span class="line">System.out.println(b);<span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> c = p <span class="keyword">instanceof</span> Teacher;        </span><br><span class="line">    System.out.println(c);<span class="comment">//false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中还有前提条件就是，老师和学生一定要继承Person类才可以用instanceof关键字，否则会编译报错</p><p>用代码解释就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再添加一个动物抽象类，测试类中这样写到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">b = p <span class="keyword">instanceof</span> Animal;  <span class="comment">//这样写错误的，编译不能通过</span></span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>instanceof比较的两个变量一定要有关系才可以用</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>super关键字</title>
      <link href="posts/f6ea766.html"/>
      <url>posts/f6ea766.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>和this一样，<code>super.</code>的方式，是用来引用父类的变量与方法的</p><p>除此之外，super还可以调用父类的构造方法</p><p> <code>super()</code>调用的是父类的空参数构造</p><p><code>super(参数)</code> 调用的是父类的有参数构造方法</p><p>其中要注意的是，子类的构造方法, 有一个默认添加的构造方法，子类构造方法中的第一行,有一个隐式代码 super()，<font color=brown>（注：这里说一下，子类的<strong>所有构造方法</strong>，无论重载多少个，第一行都是 super()）</font></p><p>即</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类的构造方法第一行super语句,调用父类的构造方法</p><p>代码理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台会输出<code>父类构造方法</code>字样，意思就是我上面说的那样，子类的构造方法, 有一个默认添加的构造方法，子类构造方法的第一行,有一个隐式代码 super()</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>如果子类的构造方法第一行写了this调用了本类其他构造方法，那么super调用父类的语句还有吗？</p><p>这时是没有的，因为this()或者super(),只能定义在构造方法的第一行，因为初始化动作要先执行。</p><p> super(参数) 与 this(参数) 不能同时在构造方法中存在</p><p>小结论: 无论如何,子类的所有构造方法,直接,间接必须调用到父类构造方法</p><hr><blockquote><p>这里吐槽一下，这些东西我早忘记了….一点印象都没有…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this关键字</title>
      <link href="posts/75f5b5c3.html"/>
      <url>posts/75f5b5c3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><code>this.的方式</code>，区分局部变量和成员变量同名情况</p><p>除此之外，this还可以在构造方法之间调用，语法格式是<code>this()</code>,而且<strong>只能写在构造方法的第一行</strong></p><p>代码理解：</p><p>创建一个人，出生的时候如果不初始化，默认给一个name和age代码，不是null和0，是指定的数字</p><p>如果不用this，代码可以这样表示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">        age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getset省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到无论是有参构造器还是无参构造器，两个方法的作用都是给对象的成员变量初始化，所以如果一个方法调用另一个方法，可以使代码减少很多</p><p>正确的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//调用了有参数的构造方法</span></span><br><span class="line"><span class="comment">//参数李四,20传递给了变量name,age</span></span><br><span class="line"><span class="keyword">this</span>(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  构造方法,传递String,int</span></span><br><span class="line"><span class="comment"> *  在创建对象的同时为成员变量赋值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getset省略</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立对象的时候，如果没有指定参数，就会默认调用无参构造器，其中的<code>this(&quot;李四&quot;,20);</code>调用有参构造，然后给成员变量初始化，就会达到，建立对象的同时给成员变量赋值的效果</p><p>注意：<strong>调用其他构造方法的语句必须<font color=red>定义在构造方法的第一行</font>，原因是初始化动作要最先执行。</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于构造方法</title>
      <link href="posts/7b749a13.html"/>
      <url>posts/7b749a13.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>构造方法的作用就是: 在new 的同时对成员变量赋值, 给对象的属性初始化赋值  new Person 对属性 name,age赋值</p><h1 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限  方法名(参数列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>方法的名字,必须和类的名字完全一致</p><p>构造方法不允许写返回值类型  , void 也不能写</p><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><p>构造方法在new 的时候,自动执行，而且只允许一次</p><p>每个类必须拥有构造方法，不写也有，编译的时候，javac, 会自动检查类中是否有构造方法，如果有,就这样的，如果没有,编译器就会自动添加一个构造方法</p><p> 编译器自动添加的构造方法: public Person(){}</p><p>自己手写了构造方法,编译的时候,不会自动添加构造方法!</p><h1 id="内存详解"><a href="#内存详解" class="headerlink" title="内存详解"></a>内存详解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Person的构造方法，拥有参数列表</span></span><br><span class="line">Person(<span class="keyword">int</span> age, String name) &#123;</span><br><span class="line"><span class="comment">// 接受到创建对象时传递进来的值，将值赋给成员属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">set/get省略</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 创建Person对象，并明确对象的年龄和姓名</span></span><br><span class="line">Person p = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序最开始，main方法压栈运行，执行<code>Person p = new Person(23, &quot;张三&quot;);</code>,堆内存会出现一块空间给Person，成员变量 跟随对象 创建进入堆内存，并且初始化默认值，0与null,，然后接着<strong>对象会调用自己的构造方法</strong>，构造方法会进入栈内存运行</p><p>构造方法压栈运行，对象会将最初的<code>张三</code>与<code>23</code>传给构造方法，将自己的内存地址传给this关键字，然后赋值成员变量，构造方法运行完成后，弹栈死亡，<strong>构造方法运行结束了，整个对象才算建立完成</strong>，然后p指向对象地址</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201024160045.png"></p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><ol><li>一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的,根据自己需求</li><li>构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。<em>这个应该就是应对考试的，记一下吧</em></li></ol><h1 id="构造方法和一般方法区别"><a href="#构造方法和一般方法区别" class="headerlink" title="构造方法和一般方法区别"></a>构造方法和一般方法区别</h1><ol><li>构造方法在对象创建时就执行了，而且只执行一次。<strong>是对象调用的</strong></li><li>一般方法是在对象创建后，需要使用时才被对象调用，并可以被多次调用。<strong>是我们自己调用的</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态向上与向下转型</title>
      <link href="posts/fc8e9806.html"/>
      <url>posts/fc8e9806.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h1><p>多态中特有的体现</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类的引用 变量 = new 子类的对象();</span><br></pre></td></tr></table></figure><p>java是一门强制数据类型的语言，参数运算的数据，保证类型的统一性，</p><p>如果数据类型不一致的时候，只有两种情况，一种是<code>自动类型提升</code>，一种是<code>强制类型转换</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Fu f = new Zi();</span><br></pre></td></tr></table></figure><p>这条语句明显左右两边类型不一样，但是编译运行的时候，却不受影响，只有上面说的两种情况，但是我没有参与，也就是强制转换其他类型，它只有一种解释，就是<code>自动类型提升</code>, </p><p>所谓自动类型提升就是，将取值范围小的自动提升为取值范围大的，而引用数据类型没有取值范围这个概念，但是原理都是一样的，范围小的看成是子类，范围大的看成是父类，<code>Fu f = new Zi();</code>这行代码，f就是父类类型，将子类提升为了父类类型，这个提升就是<code>向上转型</code>。</p><p><strong>实际上，当new 子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。</strong></p><p>向上转型的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">如：Person p = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure><p>向上转型只能调用子类和父类的公有内容，这也是多态的一个好处，但是也有弊端，就是不能调用子类的特有方法，但是可以向下转型</p><h1 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h1><p>多态调用，如果要调用子类的特有内容，可以向下转型，父类类型强制转换子类类型，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fu f = <span class="keyword">new</span> Zi();<span class="comment">//多态调用，f向上转型，现在下一步我要调用子类特有方法</span></span><br><span class="line">Zi z = (Zi)f;    <span class="comment">//向下转型</span></span><br></pre></td></tr></table></figure><p>一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的！</p><p>使用格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">子类类型 变量名 = (子类类型) 父类类型的变量;</span><br><span class="line">如:Student stu = (Student) p;  </span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><p>什么时候使用向上转型</p><p>当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作，这时就可以使用向上转型。</p></li><li><p>什么时候使用向下转型</p><p>当要使用子类特有功能时，就需要使用向下转型。</p></li><li><p>向下转型的好处：可以使用子类特有功能。</p></li><li><p>弊端是：需要面对具体的子类对象；在向下转型时容易发生ClassCastException类型转换异常。在转换之前必须做类型判断。</p><p>如：if( !a instanceof Dog){…}</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态概述以及成员特点</title>
      <link href="posts/47b88999.html"/>
      <url>posts/47b88999.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="多态概述"><a href="#多态概述" class="headerlink" title="多态概述"></a>多态概述</h1><p>我理解的多态就是<code>同一种事物的多种形态</code></p><p>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。</p><p>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person。</p><p>Java中多态的代码体现在一个子类对象(实现类对象)既可以给这个子类(实现类对象)引用变量赋值，又可以给这个子类(实现类对象)的父类(接口)变量赋值。</p><p>如Student类可以为Person类的子类。那么一个Student对象既可以赋值给一个Student类型的引用，也可以赋值给一个Person类型的引用。</p><h1 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h1><ul><li>父类引用变量可以指向子类对象</li><li>多态的前提是必须有子父类关系或者类实现接口关系，否则无法完成多态。</li><li>在使用多态后的父类引用变量调用方法时，会调用子类重写后的方法。</li></ul><h1 id="成员特点"><a href="#成员特点" class="headerlink" title="成员特点"></a>成员特点</h1><ol><li><p>先看成员变量</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 建立一个测试类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(f.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 控制台会显示1,也就是父类的成员变量值，他没有走子类的</p></li><li><p>如果是方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        f.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 控制台会显示zi,也就是子类的重写方法</p></li></ol><blockquote><p>总结</p><ol><li><p>成员变量:</p><p> 编译的时候, 参考父类中有没有这个变量,如果有,编译成功,没有编译失败</p><p> 运行的时候, 运行的是父类中的变量值<br><font color=#b33b63> <strong><em>编译运行全看父类</em></strong></font></p></li></ol><ol start="2"><li><p>成员方法:</p><p>   编译的时候, 参考父类中有没有这个方法,如果有,编译成功,没有编译失败</p><p>   运行的时候, 运行的是子类的重写方法</p><p>   <font color=#b33b63><strong><em>编译看父类，运行看子类</em></strong></font></p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo绑定个人域名</title>
      <link href="posts/d026edc8.html"/>
      <url>posts/d026edc8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h1><ol><li><p>先进入桌面, <code>cd 你的hexo本地目录</code>, <code>cd source</code>, <code>touch CNAME</code>创建CNAME文件，写入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shuigwh.cn</span><br></pre></td></tr></table></figure></li><li><p>保存,部署远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></li></ol><h1 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h1><p>www是<code>xxxx.github.io</code></p><p>@对应的是<code>xxxx.github.io</code>的IP，可以ping拿到IP</p><p>即</p><table><thead><tr><th>主机记录</th><th>记录类型</th><th>记录值</th></tr></thead><tbody><tr><td>www</td><td>CNAME</td><td>xxxx.github.io</td></tr><tr><td>@</td><td>A</td><td>xxx.xxx.xxx.xxx</td></tr></tbody></table><p>然后保存，这个时候等一会就可以访问了，但是只能访问http://的形式</p><p>到远程库的设置里面，<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201023142757.png"></p><p>将这个https勾选，保存即可</p><p>过一会就可以访问https://的形式了</p><blockquote><p>参考：<a href="https://blog.csdn.net/yucicheung/article/details/79560027">https://blog.csdn.net/yucicheung/article/details/79560027</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>继承，实现总结</title>
      <link href="posts/1eedea8a.html"/>
      <url>posts/1eedea8a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p><code>类与类</code>之间是继承关系，只能单继承，子类自动继承父类的所有数据，即成员变量和方法</p><blockquote><p> 注意：抽象类，其中可以包含抽象方法，也可以包含具体的方法，但是如果有抽象方法，这个类一定是抽象类</p><p> 类继承抽象类，要重写抽象类里面的所有抽象方法</p></blockquote><blockquote><p>接口，里面只能包含常量（默认public static final）与抽象方法(默认public abstract),就算不写修饰符，也就是public static final abstract 这些，也是可以的</p></blockquote></li><li><p><code>类与接口</code>的之间是实现关系(implement)，可以多实现接口，一旦类实现接口，必须要重写接口里面的所有抽象方法</p></li><li><p><code>接口与接口</code>之间是继承(extends)，支持多继承（因为都是抽象方法，所以不像类只能单继承，存在安全隐患）</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于接口与继承的理解</title>
      <link href="posts/18276965.html"/>
      <url>posts/18276965.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="继承的弊端"><a href="#继承的弊端" class="headerlink" title="继承的弊端"></a>继承的弊端</h1><p>在Java中，继承不能多继承，也就是一个类只能继承一个类，不能继承多个类，举个列子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bbbb&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在来一个类叫C，c同时继承A 和B类，当实例化c的时候，调用父类的function方法时候,这个时候就不知道应该调用那个类中的function方法了，这也是继承的局限性</p><h1 id="接口的好处"><a href="#接口的好处" class="headerlink" title="接口的好处"></a>接口的好处</h1><p>所以就有了接口，Java中，一个类可以实现多个接口，也可以理解同时继承多个接口，但是和继承不同的是，接口里面的方法全是抽象方法，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是两个接口，里面的方法都是一样的，建立一个C类，实现这两个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口要重写里面的抽象方法，由于抽象方法名字都是一样的，所以写一次就可以了，接口的里面的方法全都是抽象的，即使名字一样也不要紧，由实现接口的类自己定，所以它和继承不一样</p><blockquote><p>总结：类的多继承，当多个父类中有相同功能时，子类调用会产生不确定性，所以会存在安全隐患，<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;接口的多实现，没有安全隐患，原因在于接口中的方法全是抽象，没有主体</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用数据类型传参</title>
      <link href="posts/626c8828.html"/>
      <url>posts/626c8828.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>引用数据类型传参会涉及到堆内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">        System.out.println(p.name);<span class="comment">//张三</span></span><br><span class="line">        function(p);</span><br><span class="line">        System.out.println(p.name);<span class="comment">//李四</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> statc <span class="keyword">void</span> <span class="title">function</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line">        p.name = <span class="string">&quot;李四&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>程序开始运行，main方法先压栈执行，<code>Person p = new Person();</code>堆内存会开辟一块内存空间，Person对象，成员变量name随着对象建立一起进入堆内存，并且赋初值null,此内存地址假设是0x01，c变量会指向堆内存的0x01地址，<code>p.name = &quot;张三&quot;;</code>null被<code>张三</code>覆盖，接着打印p.name,会显示张三</p><p>运行<code>function(p)；</code>,function方法会压栈执行，传参给的其实p中保存的地址，所以function方法中的p也指向堆内存的内存地址0x01,此时两个变量p都指向了同一片内存空间地址，function方法中<code>p.name=&quot;李四&quot;</code>,原来的张三又被李四覆盖，function方法运行完毕，function方法就会弹出栈内存死亡，main方法继续运行<code> System.out.println(p.name);</code>，控制台会显示李四</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021140357.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成员变量和局部变量区别</title>
      <link href="posts/40dd4c9d.html"/>
      <url>posts/40dd4c9d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>定义位置上的区别</p><p>成员变量，定义在类中，方法外</p><p>局部变量，方法内，语句外</p></li><li><p>作用域不同</p><p>成员变量，作用范围是整个类</p><p>局部变量，方法内，语句内</p></li><li><p><font color=green><strong>默认值不同</strong></font></p><p>成员变量有自己的默认值（对象在内存中的理解说过）</p><p><font color = red><strong>局部变量，没有默认值，不赋值不能使用</strong></font></p></li><li><p><font color=green><strong>内存位置不同（对象在内存中的理解说过）</strong></font></p><p>成员变量，跟随对象进入堆内存存储</p><p>局部变量，跟随自己的方法，进入栈内存</p></li><li><p><font color=green><strong>生命周期不同</strong></font></p><p>成员变量，跟随对象，在堆内存中存储，等待JVM（虚拟机）清理          生命周期较长</p><p>局部变量，跟随方法，方法出栈                                                                                    生命周期较短</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象在内存中的理解</title>
      <link href="posts/576f6a89.html"/>
      <url>posts/576f6a89.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Java中有栈内存和堆内存</p><p><code>栈内存</code>是运行方法用的，<code>堆内存</code>是存储容器用的</p><p><del>一个完整的Java程序如果要运行，先从main方法进行，main先压栈，new出来的对象实力，在堆内存里面</del></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    String color;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小汽车在跑&quot;</span>+color+<span class="string">&quot;..&quot;</span>+count);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCar</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Car c = <span class="keyword">new</span> Car();</span><br><span class="line">        c.color = <span class="string">&quot;无色&quot;</span>;</span><br><span class="line">        c.count = <span class="number">5</span>;</span><br><span class="line">        c.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这是一个完整的Java程序,一个car类，一个测试类</p><p>程序开始运行</p><p>main先压栈，运行第一行代码<code>Car c = new Car();</code>，Java虚拟机会在堆内存开辟一快空间，有了空间，就会有属于自己的内存地址</p><p>例如这个地址是<code>0x001</code>,这块空间是new car 创建的</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021123430.png" style="zoom: 80%;" /><p>对象在对内存创建后，类的成员变量，会跟随对象进入到堆内存中，并且会赋值默认值，这个默认值是更加成员变量的类型而定的，就比如<code>Car c = new Car()</code>,如果后面没有赋值，那么他的成员变量的默认值就是<code>null</code>和<code>0</code>，即下图：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021124434.jpg" style="zoom: 67%;" /><p>这就是<code>new Car();</code>在堆内存中的执行时的示意图</p><p>此时对象就建立完成了，然后Java虚拟机就会将这个对象内存地址传送给引用变量c,c就会指向这片内存空间，即</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021125009.jpg" style="zoom:80%;" /><p>所以，真正的对象是new出来的，而c保存的其实是对象内存的地址，所以，直接把c叫做car类的变量也没有问题</p><p>接着，main开始运行下一条代码，<code>c.color = &quot;无色&quot;;</code>，相应的，堆内存中的<code>null</code>会被<code>无色</code>覆盖，<code>c.count = 5;</code>堆内存中的<code>0</code>会被<code>5</code>覆盖</p><p>当程序执行<code>c.run();</code>，类中的方法run就会进栈执行，虚拟机会再次开辟空间是run方法压栈运行</p><p>run方法中只有一句<code>System.out.println(&quot;小汽车在跑&quot;+color+&quot;..&quot;+count);</code>,其中的color与count可以这样理解，方法run是对象c调用，那么其中的color和count指的就是对象c的成员变量，所以<code>无色</code>和<code>5</code>就会被打印到控制台上，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201021131215.jpg" style="zoom: 80%;" /><p>打印完成后，run方法就会结束，run方法就要出栈死亡，这个过程叫弹栈，弹出栈内存死亡，死亡了，内存就会被释放</p><p>main也随即运行完成了，也会弹出栈内存死亡，释放内存</p><p>main死亡之后，变量c将不会再指向堆内存的对象地址，所以这个对象在内存中也会变成垃圾    </p><blockquote><p> 这里要说一下，栈内存中的方法用完了就会释放，空间就会出来了，而堆内存中的对象或者是数组，它自己不会释放，他要等着虚拟机清理，而虚拟机清理垃圾是不需要我们考虑的，它属于自动行为</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---定状同从句</title>
      <link href="posts/c9325fa6.html"/>
      <url>posts/c9325fa6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131032.png"></p><p>以下这些词都可以用同位语从句进行解释</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131122.png" style="zoom:67%;" /><p>例句：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131347.png" style="zoom:80%;" /><blockquote><p>同位语从句有很多连接词，但是百分之99都是that</p></blockquote><h1 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h1><h2 id="引出"><a href="#引出" class="headerlink" title="引出"></a>引出</h2><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019131753.png" style="zoom: 80%;" /><h2 id="连词"><a href="#连词" class="headerlink" title="连词"></a>连词</h2><h3 id="修饰人-who-whom"><a href="#修饰人-who-whom" class="headerlink" title="修饰人(who/whom)"></a>修饰人(who/whom)</h3><ol><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132039.png" style="zoom:67%;" /></li><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132137.png" style="zoom:67%;" /></li></ol><h3 id="修饰物（that-which）"><a href="#修饰物（that-which）" class="headerlink" title="修饰物（that/which）"></a>修饰物（that/which）</h3><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019140350.png" style="zoom:67%;" /><p>其中that和which不能乱用</p><p>这种情况只能用that，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132706.png" style="zoom:67%;" /><blockquote><p> 先行词就是被修饰的那个名词</p></blockquote><h3 id="修饰句，表示总结（which）"><a href="#修饰句，表示总结（which）" class="headerlink" title="修饰句，表示总结（which）"></a>修饰句，表示总结（which）</h3><p>这种情况只能用which，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019132929.png" style="zoom:67%;" /><h4 id="非限定性定语从句"><a href="#非限定性定语从句" class="headerlink" title="非限定性定语从句"></a>非限定性定语从句</h4><p><strong><font color='green'><em>修饰句，表示总结</em></font></strong></p><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019133201.png" style="zoom:67%;" /><p>这就是修饰的前面整句话，所以必须用which，必须用<code>,</code></p><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019134710.png" style="zoom:67%;" /><p>这句话，如果不用定语从句，这句话是这样翻译的：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019134757.png" style="zoom:80%;" /><p>这是两个简单句，完全可以。</p><p>如果用定语从句可以这样</p><p>分析：</p><p><code>这</code>修饰前面的<code>中国的经济正迅速发展</code>这句话，所以是定语从句，所以也可以这样写，</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135028.png" style="zoom:80%;" /><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135509.png" style="zoom:67%;" /><h2 id="例句"><a href="#例句" class="headerlink" title="例句"></a>例句</h2><ul><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019135729.png" style="zoom:80%;" /></li><li><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019140523.png" style="zoom: 80%;" /></li></ul><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><blockquote><p>做阅读可能会遇到下面的几个情况</p></blockquote><p><strong><em><font color='green'>介词+which</font></em></strong></p><p>这也是定语从句，翻译方法：</p><ol><li>介词先砍掉，</li><li>然后把介词放到从句里面去</li></ol><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141059.png"></p><p>分析：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141152.png"></p><p>例如：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141234.png"></p><p>分析：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019141333.png" style="zoom:80%;" /><hr><p>例如：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019142136.png" style="zoom:80%;" /><blockquote><p><font color='brown'><strong>连词如果在定语从句中做宾语是可以省略的</strong></font>，这里要注意，可能阅读会有陷阱</p></blockquote><h1 id="状语从句"><a href="#状语从句" class="headerlink" title="状语从句"></a>状语从句</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201019143906.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度云在线视频加速方法</title>
      <link href="posts/9ced7ac.html"/>
      <url>posts/9ced7ac.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>网页版百度网盘视频今天看着有点慢，想加速，搜了一下，防止遗忘，在此记录一下</p></blockquote><p>打开网页版，然后打开控制台，输入以下内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">videojs.getPlayers(<span class="string">&quot;video-player&quot;</span>).html5player.tech_.setPlaybackRate(<span class="number">1.5</span>) </span><br></pre></td></tr></table></figure><p>这是1.5倍播放，需要多少，直接在后面改参数就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 实用小工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百度网盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---主宾表从句</title>
      <link href="posts/ca22eae1.html"/>
      <url>posts/ca22eae1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="从句概念"><a href="#从句概念" class="headerlink" title="从句概念"></a>从句概念</h1><p>一句话做定语=定语从句</p><p>一句话做宾语=宾语从句</p><p>一句话做表语=表语从句</p><h1 id="主从句之间的连接"><a href="#主从句之间的连接" class="headerlink" title="主从句之间的连接"></a>主从句之间的连接</h1><p>桥梁：连词</p><h2 id="连词一（从句完整）"><a href="#连词一（从句完整）" class="headerlink" title="连词一（从句完整）"></a>连词一（从句完整）</h2><p><strong><em>that/whether/if</em></strong></p><p>从句完整的时候用that连接</p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225156.png" style="zoom:50%;" /><p>有时候也用whether或者if</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225331.png" style="zoom:50%;" /><p>注意，不能使用if的情况</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225431.png" style="zoom:67%;" /><p>所以为了方便，一直用whether就可以了</p><h2 id="连词二（从句缺人）"><a href="#连词二（从句缺人）" class="headerlink" title="连词二（从句缺人）"></a>连词二（从句缺人）</h2><p><strong><em>who/ whom</em></strong></p><ul><li><p>who是在从句中做主语</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017225926.png" style="zoom: 80%;" /></li><li><p>whom是在从句中做宾语</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230129.png" style="zoom:80%;" /></li></ul><p>举例：</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230343.png" style="zoom:80%;" /><h2 id="连词三（从句缺物）"><a href="#连词三（从句缺物）" class="headerlink" title="连词三（从句缺物）"></a>连词三（从句缺物）</h2><p><strong><em>what</em></strong></p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201018122713.png" style="zoom:67%;" /><h2 id="连词四（从句需状语）"><a href="#连词四（从句需状语）" class="headerlink" title="连词四（从句需状语）"></a>连词四（从句需状语）</h2><p><strong><em>when(时间)/where（地点）/why（原因）/how（方式）</em></strong></p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017230758.png" style="zoom: 80%;" /><h1 id="翻译从句的方法"><a href="#翻译从句的方法" class="headerlink" title="翻译从句的方法"></a>翻译从句的方法</h1><p>先把连词放在句子的空缺处，然后从左往右翻译</p><h1 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h1><h2 id="特殊主语从句"><a href="#特殊主语从句" class="headerlink" title="特殊主语从句"></a>特殊主语从句</h2><p>有道题是这样的</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232551.png" style="zoom: 80%;" /><p>这种情况是错误的，出现了两个动词</p><p>解决方法：</p><p>可以加个that</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232717.png"></p><p>但是前面有点长，要避免头重脚轻，把that引动的从句放到后面，前面加个形式主语it</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017232847.png"></p><h1 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h1><h2 id="在及物动词后作宾语"><a href="#在及物动词后作宾语" class="headerlink" title="在及物动词后作宾语"></a>在及物动词后作宾语</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233317.png"></p><h2 id="在介词后面作宾语"><a href="#在介词后面作宾语" class="headerlink" title="在介词后面作宾语"></a>在介词后面作宾语</h2><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233423.png"></p><p>宾从例句：</p><p>​    <img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017233754.png" style="zoom: 67%;" /></p><h1 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h1><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234424.png"></p><p>这是个简单句，不是表语从句</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234452.png"></p><p>表语从句</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201017234929.png" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---句子成分</title>
      <link href="posts/92acea72.html"/>
      <url>posts/92acea72.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="主语"><a href="#主语" class="headerlink" title="主语"></a>主语</h1><p> 动作发出者</p><h2 id="找主语的方法"><a href="#找主语的方法" class="headerlink" title="找主语的方法"></a>找主语的方法</h2><ol><li>谓语动词的前面</li></ol><h1 id="宾语"><a href="#宾语" class="headerlink" title="宾语"></a>宾语</h1><p>动作承受者  名词类（及物动词后面的全是宾语）</p><p>动词不能直接做宾语，要修改成名词</p><p>动词 —&gt; 名词  的方法</p><pre><code>                                   1. to do                                                        2. doing</code></pre><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015132831.png"></p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015133020.png"></p><h2 id="找宾语的方法："><a href="#找宾语的方法：" class="headerlink" title="找宾语的方法："></a>找宾语的方法：</h2><ol><li>介词后面的</li><li>及物动词后面的</li></ol><h2 id="介宾结构"><a href="#介宾结构" class="headerlink" title="介宾结构"></a>介宾结构</h2><p>介词只能加，名词/doing/宾格，其他都是错的</p><h1 id="表语"><a href="#表语" class="headerlink" title="表语"></a>表语</h1><p>修饰主语, 名词或者形容词类</p><p>例子：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015170014.png"></p><blockquote><p>改变世界还没有完成，所以用to do </p></blockquote><p>这里为什么要加个the</p><p>the的用法：</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015170453.png"></p><h2 id="找表语的方法"><a href="#找表语的方法" class="headerlink" title="找表语的方法"></a>找表语的方法</h2><p>​    系动词后面的</p><p>​    凡是能用be动词替换的，包括be本身，都是主系表结构</p><h1 id="定语"><a href="#定语" class="headerlink" title="定语"></a>定语</h1><p>概念： 修饰名词的</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015171502.png"></p><p>当动词是doing，修饰名词，这个doing代表一个功能</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015171902.png"></p><p>定于可以在前面也可以在后面，当在前面的时候很简单，很短，</p><p>当在后面的时候一般都很复杂，要么是<code>to do</code>要么是<code>介词短语</code></p><h1 id="状语"><a href="#状语" class="headerlink" title="状语"></a>状语</h1><p>修饰形容词，动词，句子</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015172558.png" style="zoom:50%;" /><h1 id="同位语"><a href="#同位语" class="headerlink" title="同位语"></a>同位语</h1><p>修饰且等于名词</p><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015173540.png" style="zoom: 80%;" /><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><img src=" https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201015174440.png" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四级笔记---句子结构</title>
      <link href="posts/5d143ecd.html"/>
      <url>posts/5d143ecd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="三个基本结构"><a href="#三个基本结构" class="headerlink" title="三个基本结构"></a>三个基本结构</h1><ol><li>主谓宾</li><li>主谓</li><li>主系表</li></ol><h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><ol><li><p>及物动词（有对象）</p></li><li><p>不及物动词</p><p>1和2叫实义动词</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014164711.png"></p></li><li><p>系动词（能用be替换）</p><p>​    例如：<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201014160925.png">，<img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201014161100.png">，</p><p>​    <strong><em>凡是能用be动词替换的，包括be本身，都是主系表结构</em></strong></p></li><li><p>助词</p><p>时态，情态，否定</p></li></ol><hr><p>及物动词引导主谓宾，不及物动词引导主谓，系动词引导主系表</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014165529.png"></p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014165749.png"></p><p>判断结构</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014170701.png"></p><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>可以先将代表修饰的词删掉<img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014170508.png"></p><h1 id="三大特殊结构"><a href="#三大特殊结构" class="headerlink" title="三大特殊结构"></a>三大特殊结构</h1><ol><li><p>主谓宾宾</p></li><li><p>主谓宾补</p></li><li><p>强调句</p><p>1和2  宾宾和宾补可以在中间加个be动词进行连接，可以连接的是宾补，不能的就是宾宾<br><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014173513.png"></p></li></ol><h2 id="强调句"><a href="#强调句" class="headerlink" title="强调句"></a>强调句</h2><p>格式：</p><p>​        强调主语：it is  + 人 +   who<br>​        强调状语：it is  + 物 +   that</p><hr><p>强调谁，就把谁放在前面，剩下的部分原封不动放在后面</p><p>举例：</p><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201014174507.png"></p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 提交远程库命令</title>
      <link href="posts/f2b26283.html"/>
      <url>posts/f2b26283.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>这几个命令怕以后忘记了，单独开个博文记录一下</p></blockquote><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><h2 id="添加暂存区"><a href="#添加暂存区" class="headerlink" title="添加暂存区"></a>添加暂存区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;信息&quot;</span></span><br></pre></td></tr></table></figure><h2 id="推送远程库"><a href="#推送远程库" class="headerlink" title="推送远程库"></a>推送远程库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;远程地址&gt;</span><br><span class="line">git branch -M origin main</span><br><span class="line">git push -u origin &lt;main&gt;</span><br></pre></td></tr></table></figure><hr><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="查看本地库状态"><a href="#查看本地库状态" class="headerlink" title="查看本地库状态"></a>查看本地库状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="用于迁移"><a href="#用于迁移" class="headerlink" title="用于迁移"></a>用于迁移</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main //主分支和main分支合并</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git配置与仓库迁移</title>
      <link href="posts/2ad68004.html"/>
      <url>posts/2ad68004.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的账号不要了，上面的仓库需要迁移</p><p>于是….</p><p>就出现了很多问题，下面主要就记录下</p><h2 id="github加速"><a href="#github加速" class="headerlink" title="github加速"></a>github加速</h2><h3 id="有代理"><a href="#有代理" class="headerlink" title="有代理"></a>有代理</h3><p>我用的是v2rayn,查看端口号是<code>10808</code>,然后在<code>C:\Users\UserName\.gitconfig</code>文件添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[http]</span><br><span class="line">    proxy = http://127.0.0.1:10808</span><br><span class="line">[https]</span><br><span class="line">    proxy = http://127.0.0.1:10808</span><br></pre></td></tr></table></figure><p>，当然命令也可以，这里是直接打开文件添加，这是http的方式</p><p>ssh的方式是这样，打开<code>C:\Users\UserName\.ssh</code>,新建<code>config</code>文件填写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProxyCommand connect -S 127.0.0.1:10808 %h %p</span><br></pre></td></tr></table></figure><h3 id="无代理"><a href="#无代理" class="headerlink" title="无代理"></a>无代理</h3><p>我最先用的就是无代理，网上介绍代理全是ss,v2rayn我以为不可以，后来在一个<a href="https://www.youtube.com/watch?v=hKBhOXlQc4c&ab_channel=%E6%9D%9C%E8%BF%9C%E8%B6%85%E5%AE%98%E6%96%B9%E9%A2%91%E9%81%93">youtube</a>视频评论下残看到的原来端口号不一样</p><p>没有代理就在<code>C:\Windows\System32\drivers\etc</code>中host文件，写这两行</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009144812.png"></p><p>IP地址有时候会变，每次在这里<a href="https://www.ipaddress.com/%E6%9F%A5%E8%AF%A2%E4%B8%80%E4%B8%8B%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%9F%A5%E5%88%B0%E7%9A%84IP%E5%86%99%EF%BC%8C%E8%BF%99%E6%98%AFhttp%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E4%BA%86">https://www.ipaddress.com/查询一下，根据查到的IP写，这是http的方式，然后就可以了</a></p><p>实话实说，感觉利用梯子效果更好，这种改host文件的方法感觉没什么变化</p><h2 id="git的配置"><a href="#git的配置" class="headerlink" title="git的配置"></a>git的配置</h2><h3 id="添加key"><a href="#添加key" class="headerlink" title="添加key"></a>添加key</h3><p>清除之前的公钥和密钥文件，重新生成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>一路回车</p><p>生成的公钥添加到github账号上面</p><p>然后验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 你的英文名     <span class="comment">#此英文名不需要跟GitHub账号保持一致</span></span><br><span class="line">git config --global user.email 你的邮箱      <span class="comment">#此邮箱不需要跟GitHub账号保持一致</span></span><br><span class="line">git config --global push.default matching</span><br><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br><span class="line">git config --global core.editor <span class="string">&quot;vim&quot;</span></span><br></pre></td></tr></table></figure><h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><p>因为我之前clone下的远程库有之前的地址，我要改一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:xxxxx.git</span><br></pre></td></tr></table></figure><p>master迁移到main分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main </span><br></pre></td></tr></table></figure><p>可以推送新的仓库了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin main </span><br></pre></td></tr></table></figure><hr><p>参考：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/148110705?utm_source=qq&amp;utm_medium=social&amp;utm_oi=882705482219917312">https://zhuanlan.zhihu.com/p/148110705?utm_source=qq&amp;utm_medium=social&amp;utm_oi=882705482219917312</a></p><p><a href="https://zhuanlan.zhihu.com/p/48209762">https://zhuanlan.zhihu.com/p/48209762</a></p><p><a href="https://os.51cto.com/art/202009/627539.htm">https://os.51cto.com/art/202009/627539.htm</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github图片，jsdelivr加速不能访问</title>
      <link href="posts/ed109295.html"/>
      <url>posts/ed109295.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>百度搜索关于cdn jsdelivr picgo github图床一堆，我这里就不重新写了，主要写遇到的问题，picgo配置好了，也可以正常上传，但是一旦用jsdelivr链接加速就是访问不了，百度上面连接都是这也写的</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/%E7%94%A8%E6%88%B7%E5%90%8D/%E4%BB%93%E5%BA%93%E5%90%8D">https://cdn.jsdelivr.net/gh/用户名/仓库名</a></p></blockquote><p> 所以我最初写的也是<br><code>https://cdn.jsdelivr.net/gh/cloudvillager/cloud/img/20201009135759.png</code>看着没有问题，但是就是不对，一直访问是</p><p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009140831.png"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>猜测是和github默认分支改成main的原因</p><p>github这个月开始，新建仓库都是<code>main</code>作为主分支，原来<code>master</code>已经不用了,可能不指定分支，默认访问的就是master</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在用jsdelivr加速的时候，指定一下main分支,格式是</p><blockquote><p><a href="https://cdn.jsdelivr.net/gh/%7BGithub%E7%94%A8%E6%88%B7%E5%90%8D%7D/%7BGithub%E4%BB%93%E5%BA%93%E5%90%8D%7D@%7B%E7%89%88%E6%9C%AC%E5%90%8D%7D/%7B%E4%BB%93%E5%BA%93%E4%B8%8B%E8%B5%84%E6%BA%90%E8%B7%AF%E5%BE%84%7D">https://cdn.jsdelivr.net/gh/{Github用户名}/{Github仓库名}@{版本名}/{仓库下资源路径}</a></p></blockquote><p>例如： <a href="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009135759.png">https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201009135759.png</a></p><p>就可以访问了</p><hr><p>参考：</p><blockquote><p><a href="https://www.dazhuanlan.com/2020/03/26/5e7c9c9250cb8/?__cf_chl_jschl_tk__=ef5bbb49c273a87d67426449fa2defbac0dfa6e7-1602224791-0-AYlVlW0tHM7FK5Qhf5aEkX6pJ7S5DHPQVpmNoGVMhVOnqXxWhsdpPA9auCrFSdnIkctDqUWuxA6FoL7wdAnceIQAR1wGVkhzYKXZPOhD9Yzu4AWYMr40e1N0qT05isp__Jxq01aqydGOL2FNQMogmatShYr3_IFtqmybF0eamnkLMq28fgCsy-DBU91oAt5PTSqqR7oZogV9J8-wNtpyWbH40mAjPVFsBckeQWHVOQNfAQCfnJeXUPTuPWFo50wshnJgyqHYmWrc0VtxXnz2jGaSi08cBy3BmVwnrmBPmKz7fdf1ZiuEElBT-9UmnsejAQ">https://www.dazhuanlan.com/2020/03/26/5e7c9c9250cb8/?__cf_chl_jschl_tk__=ef5bbb49c273a87d67426449fa2defbac0dfa6e7-1602224791-0-AYlVlW0tHM7FK5Qhf5aEkX6pJ7S5DHPQVpmNoGVMhVOnqXxWhsdpPA9auCrFSdnIkctDqUWuxA6FoL7wdAnceIQAR1wGVkhzYKXZPOhD9Yzu4AWYMr40e1N0qT05isp__Jxq01aqydGOL2FNQMogmatShYr3_IFtqmybF0eamnkLMq28fgCsy-DBU91oAt5PTSqqR7oZogV9J8-wNtpyWbH40mAjPVFsBckeQWHVOQNfAQCfnJeXUPTuPWFo50wshnJgyqHYmWrc0VtxXnz2jGaSi08cBy3BmVwnrmBPmKz7fdf1ZiuEElBT-9UmnsejAQ</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
          <category> github </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> jsdelivr </tag>
            
            <tag> 图床 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 本地拒绝连接远程库问题 错误403</title>
      <link href="posts/9fcda5d2.html"/>
      <url>posts/9fcda5d2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>下午本来想推送一下网站的<code>hexo d</code>然后一直报错</p><blockquote><p>On branch master<br>nothing to commit, working tree clean<br>remote: Permission to cloudvillager/cloudvillager.github.io.git denied to shuimqs.<br>fatal: unable to access ‘<a href="https://github.com/cloudvillager/cloudvillager.github.io.git/&#39;">https://github.com/cloudvillager/cloudvillager.github.io.git/&#39;</a>: The requested URL returned error: 403</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>报错信息大概意思就是，我之前登陆 了别的github账户，现在要推送到另一个账户，推不上去，拒绝访问，这不废话嘛，肯定推不了，找了好久，其实吧报错信息往谷歌里面一方，出来的就是答案，和我遇到的情况一样，<a href="https://stackoverflow.com/questions/47465644/github-remote-permission-denied%EF%BC%8C">https://stackoverflow.com/questions/47465644/github-remote-permission-denied，</a> 不过我看不懂，后来这里找到了答案， <a href="https://blog.csdn.net/klxh2009/article/details/76019742%EF%BC%8C">https://blog.csdn.net/klxh2009/article/details/76019742，</a> 然后看这不就是我之前看的那个链接吗，感觉一样，后来发现确实一样。。。</p><p>在看看下面评论都挺好的，再看看，之前那个国外网站是17年，这个csdn是19年发的。。英语太重要了。</p><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><img src="https://gitee.com/shuimqs/blogimages/raw/master/img/20201007165000.png"></p><p>就是这里，普通凭据那里，找到<code>  git:https://github.com</code>删除就可以了，然后<code>hexo d</code>就可以推送成功了</p><p>参考：</p><blockquote><p><a href="https://blog.csdn.net/klxh2009/article/details/76019742">https://blog.csdn.net/klxh2009/article/details/76019742</a><br><a href="https://stackoverflow.com/questions/47465644/github-remote-permission-denied">https://stackoverflow.com/questions/47465644/github-remote-permission-denied</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="posts/d87f7e0c.html"/>
      <url>posts/d87f7e0c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>docker adf</p><blockquote><p>afd fasd</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>test</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
