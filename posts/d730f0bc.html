<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>集合(一) | shuigwh’s blog</title><meta name="keywords" content="java,集合"><meta name="author" content="水过无痕"><meta name="copyright" content="水过无痕"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="集合集合的介绍集合，集合是Java中提供的一种容器，可以用来存储多个数据 在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，他们有什么区别呢？  数组的长度是固定的，集合的长度是可变的。 集合中的存储的元素必须是引用类型数据  ArrayList集合存储元素我们先来回顾下，使用ArrayList集合存储元素并遍历的过程  A">
<meta property="og:type" content="article">
<meta property="og:title" content="集合(一)">
<meta property="og:url" content="https://shuigwh.cn/posts/d730f0bc.html">
<meta property="og:site_name" content="shuigwh’s blog">
<meta property="og:description" content="集合集合的介绍集合，集合是Java中提供的一种容器，可以用来存储多个数据 在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，他们有什么区别呢？  数组的长度是固定的，集合的长度是可变的。 集合中的存储的元素必须是引用类型数据  ArrayList集合存储元素我们先来回顾下，使用ArrayList集合存储元素并遍历的过程  A">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115192049.png">
<meta property="article:published_time" content="2021-01-15T02:29:08.000Z">
<meta property="article:modified_time" content="2021-01-15T12:03:25.467Z">
<meta property="article:author" content="水过无痕">
<meta property="article:tag" content="java">
<meta property="article:tag" content="集合">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115192049.png"><link rel="shortcut icon" href="/images/favicon.png"><link rel="canonical" href="https://shuigwh.cn/posts/d730f0bc.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: 水过无痕","link":"链接: ","source":"来源: shuigwh’s blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: {"text":"Java,C++,Python,html,css,JavaScript","fontSize":"15px"},
  lightbox: 'fancybox',
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-01-15 20:03:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {
  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }

  const autoChangeMode = 'false'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }
})()</script><meta name="referrer" content="no-referrer-when-downgrade" /><meta name="generator" content="Hexo 5.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201012231537.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">50</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">32</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">10</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book-open"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talking/"><i class="fa-fw fa fa-comments"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">1.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">集合的介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E9%9B%86%E5%90%88%E5%AD%98%E5%82%A8%E5%85%83%E7%B4%A0"><span class="toc-number">1.2.</span> <span class="toc-text">ArrayList集合存储元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E5%85%B3%E7%B3%BB"><span class="toc-number">1.3.</span> <span class="toc-text">集合的继承实现关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3%E6%A6%82%E8%BF%B0"><span class="toc-number">1.4.</span> <span class="toc-text">Collection接口概述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Iterator-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">Iterator 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">Iterator迭代器概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Iterator%E8%BF%AD%E4%BB%A3%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E5%8E%9F%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">Iterator迭代集合元素原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">集合元素的向下转型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.4.</span> <span class="toc-text">增强for循环</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">3.1.</span> <span class="toc-text">泛型的引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">泛型的定义与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E7%B1%BB"><span class="toc-number">3.2.1.</span> <span class="toc-text">含有泛型的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">含有泛型的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AB%E6%9C%89%E6%B3%9B%E5%9E%8B%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.3.</span> <span class="toc-text">含有泛型的接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">3.3.</span> <span class="toc-text">使用泛型的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">3.4.</span> <span class="toc-text">泛型通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%9A%84%E9%99%90%E5%AE%9A"><span class="toc-number">3.4.1.</span> <span class="toc-text">泛型的限定</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115192049.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">shuigwh’s blog</a></span><span id="menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-book-open"></i><span> 文章</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/talking/"><i class="fa-fw fa fa-comments"></i><span> 微语</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友人帐</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">集合(一)</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-01-15T02:29:08.000Z" title="发表于 2021-01-15 10:29:08">2021-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-15T12:03:25.467Z" title="更新于 2021-01-15 20:03:25">2021-01-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="集合的介绍"><a href="#集合的介绍" class="headerlink" title="集合的介绍"></a>集合的介绍</h2><p>集合，集合是Java中提供的一种容器，可以用来存储多个数据</p>
<p>在前面的学习中，我们知道数据多了，可以使用数组存放或者使用ArrayList集合进行存放数据。那么，集合和数组既然都是容器，他们有什么区别呢？</p>
<ul>
<li>数组的长度是固定的，集合的长度是可变的。</li>
<li>集合中的存储的元素必须是引用类型数据</li>
</ul>
<h2 id="ArrayList集合存储元素"><a href="#ArrayList集合存储元素" class="headerlink" title="ArrayList集合存储元素"></a>ArrayList集合存储元素</h2><p>我们先来回顾下，使用ArrayList集合存储元素并遍历的过程</p>
<ul>
<li><p>ArrayList集合存储五个int类型元素</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">array.add(<span class="number">11</span>);</span><br><span class="line">array.add(<span class="number">12</span>);</span><br><span class="line">array.add(<span class="number">13</span>);</span><br><span class="line">array.add(<span class="number">14</span>);</span><br><span class="line">array.add(<span class="number">15</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; array.size() ;i++)&#123;</span><br><span class="line">    System.out.println(array.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  控制台将会显示</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115104349.png"></p>
<blockquote>
<p>集合ArrayList,存储int类型数</p>
<p>集合本身不接受基本类,自动装箱存储</p>
</blockquote>
</li>
<li><p>ArrayList集合存储五个Person类型元素</p>
<p>  先定义一个person对象，里面保护，name,age属性</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Person&gt; arrayPer = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">arrayPer.add(<span class="keyword">new</span> Person(<span class="string">&quot;a&quot;</span>,<span class="number">20</span>));</span><br><span class="line">arrayPer.add(<span class="keyword">new</span> Person(<span class="string">&quot;b&quot;</span>,<span class="number">18</span>));</span><br><span class="line">arrayPer.add(<span class="keyword">new</span> Person(<span class="string">&quot;c&quot;</span>,<span class="number">22</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; arrayPer.size();i++)&#123;</span><br><span class="line">    <span class="comment">//get(0),取出的对象Person对象</span></span><br><span class="line">    <span class="comment">//打印的是一个对象,必须调用的toString()</span></span><br><span class="line">    System.out.println(arrayPer.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  运行结果</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115105222.png"></p>
<h2 id="集合的继承实现关系"><a href="#集合的继承实现关系" class="headerlink" title="集合的继承实现关系"></a>集合的继承实现关系</h2><p>查看ArrayList类发现它继承了抽象类AbstractList同时实现接口List，而LIst接口又继承了Collection接口。Collection接口为最顶层集合接口</p>
<p>源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">List</span> <span class="keyword">extends</span> <span class="title">Collection</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span> <span class="keyword">implements</span> <span class="title">List</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这说明我们在使用ArrayList类时，该类已经把所有抽象方法进行了重写，那么，实现Collection接口的所有子类都会进行方法重写</p>
<ul>
<li>Collection接口常用的子接口有：List接口，Set接口</li>
<li>List接口常用的子类有：ArrayList类、LinkeList类</li>
<li>Set接口常用的子类有：HashSet类、LinkedHashSet类</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115132713.png"></p>
<blockquote>
<p>集合是个很庞大的体系，我们可以先学习最上层的共有的接口，因为，作为子类，这些接口中的方法都必须要实现</p>
</blockquote>
<h2 id="Collection接口概述"><a href="#Collection接口概述" class="headerlink" title="Collection接口概述"></a>Collection接口概述</h2><p>既然collection接口是是集合中的顶层接口，那么它中定义的所有功能子类都可以使用。查阅API中描述的collection接口。collection层次结构中的根接口。collection表示一组对象，这些对象也称为collection的元素。一些collection是有序的，而另一些是无序的。</p>
<blockquote>
<p>这个概述是复制API中描述的一段话，我们看上面的图，</p>
<p>collection接口分为两个派系，分别是list和set</p>
<p>凡是list接口中集合类，它都允许存储重复的元素，并且是有序的（有序的意思是，存的时候是什么样子，输出还是什么样子）</p>
<p>而set接口中的集合类，不允许存储重复的元素，并且是无序的</p>
</blockquote>
<p>继续查阅API，发现collection接口中很多集合的操作方法，那么这些方法都具体能做什么呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115142110.png"></p>
<p>这里我们不关心具体创建的collection中的哪个子类对象，这里重点演示的是collection接口中的方法。</p>
<p>创建集合的格式：</p>
<ul>
<li><p>方式1创建的集合，只能存储&lt;&gt;中指定的元素类型，该方式为常用方式</p>
</li>
<li><p>方式2创建的集合，集合的元素类型默认为object类型，即任何类型的元素都可以存储</p>
</li>
</ul>
<p>演示collection接口中的方法</p>
<p>Collection接口中的方法,是集合中所有实现类必须拥有的方法,接口不能直接new，所以可以用arraylist来进行演示，因为ArrayList implements List，list又继承了collection，所以ArrayList方法的执行,都是实现的重写</p>
<ul>
<li><p>void clear() 清空集合中的所有元素</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口多态的方式调用</span></span><br><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;bcd&quot;</span>);</span><br><span class="line">system.out.println(coll);<span class="comment">//[abc, bcd]</span></span><br><span class="line">coll.clear();</span><br><span class="line">system.out.println(coll);<span class="comment">//[]   clear是清空集合中的元素，但是集合容器本身还是存在的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>boolean contains(Object o) 判断对象是否存在于集合中,对象存在返回true</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = coll.contains(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">System.out.println(b); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>int size()   返回集合容器的长度</p>
<p>这个不写代码了，另外说一下</p>
<p>Java中一共表示长度的就三种方式</p>
<ol>
<li>数组.length 属性  返回值 int</li>
<li>字符串.length() 方法,返回值int</li>
<li>集合.size()方法, 返回值int</li>
</ol>
</li>
<li><p>Object[] toArray() 集合中的元素,转成一个数组中的元素, 集合转成数组 </p>
<p>返回是一个存储对象的数组, 数组存储的数据类型是Object</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;52s&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"></span><br><span class="line">Object[] objs = coll.toArray();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; objs.length ; i++)&#123;</span><br><span class="line">    System.out.println(objs[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是将coll对象从集合对象转成数组，但是有一点要注意，转成数组之后，这个coll对象的长度就不能在变了</p>
</li>
<li><p>boolean remove(Object o)移除集合中指定的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;123&quot;</span>);	</span><br><span class="line">System.out.println(coll);<span class="comment">//[abc, money, 123]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = coll.remove(<span class="string">&quot;money&quot;</span>);</span><br><span class="line">System.out.println(b); <span class="comment">//true</span></span><br><span class="line">System.out.println(coll);<span class="comment">//[abc, 123]</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h1><h2 id="Iterator迭代器概述"><a href="#Iterator迭代器概述" class="headerlink" title="Iterator迭代器概述"></a>Iterator迭代器概述</h2><p>util包中有个接口，名字叫Iterator</p>
<p>java中提供了很多个集合，他们在存储元素时，采用的存储方式不同，我们要取出这些集合中的元素，可通过一种通用的获取方式来完成。</p>
<p>collection集合元素的通用获取方式：在取元素之前先要判断集合中有没有这个元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出来，一直把集合中的所有元素全部取出。这种取出方式的专业术语成为迭代。（实际上就是遍历）</p>
<p>集合中把这种取元素的方式描述在Iterator接口中。Iterator接口中的常用方法如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115150149.png"></p>
<ul>
<li>hasNext（）方法：判断集合中还有没有可以被取出的元素,如果有返回true</li>
<li>next（）方法：取出集合中的元素，并把指针向后移动一位</li>
</ul>
<p>由于Iterator接口的方法都是抽象的，所以不能直接使用，需要用实现类来演示</p>
<p>而实现类在哪里呢，查阅API，发现collection接口中有个方法是Iterator iterator()</p>
<p>而作为collection接口的实现类arraylist类，要重写方法iterator 返回Iterator接口的实现类的对象</p>
<p>所以，使用ArrayList集合的对象</p>
<p>Iterator it = array.iterator(),运行结果就是Iterator接口的实现类的对象</p>
<p>it是接口的实现类对象,调用方法 hasNext 和 next 集合元素迭代</p>
<blockquote>
<p>这种思想就是面向接口编程思想，我们不需要知道Iterator接口的实现类是谁，只需要知道array.iterator()返回的对象是Iterator接口的实现类就可以了，然后再用Iterator接口接收它</p>
</blockquote>
<p>代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc4&quot;</span>);</span><br><span class="line"><span class="comment">//迭代器,对集合ArrayList中的元素进行取出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用集合的方法iterator()获取出,Iterator接口的实现类的对象</span></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"><span class="comment">//接口实现类对象,调用方法hasNext()判断集合中是否有元素</span></span><br><span class="line"><span class="keyword">boolean</span> b = it.hasNext();</span><br><span class="line">System.out.println(b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接口的实现类对象,调用方法next()取出集合中的元素</span></span><br><span class="line">String s = it.next();</span><br><span class="line">System.out.println(s);<span class="comment">//abc1</span></span><br></pre></td></tr></table></figure>

<p>循环演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc1&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc2&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc3&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;abc4&quot;</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代是反复内容,使用循环实现,循环的条件,集合中没元素, hasNext()返回了false</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    String s = it.next();</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Iterator迭代集合元素原理"><a href="#Iterator迭代集合元素原理" class="headerlink" title="Iterator迭代集合元素原理"></a>Iterator迭代集合元素原理</h2><p>Iterator it = array.iterator();</p>
<p>这句方法一运行，在集合内部就会建立一个指针，指向容器的-1位置，比如有个容器，里面存了这些数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115155455.png"></p>
<p>循环语句while(it.hasNext())</p>
<p>当执行这个hasNext方法时，指针就会判断下一个位置有没有元素，有就返回真，但是指针位置不动</p>
<p>代码继续运行循环体中的代码<code>it.next()</code>，这个方法就会返回下一个位置的元素，并且指针会往后移动一个位置，然后继续走while循环，判断，以此循环迭代，直到指针移动到最后一个元素位置，判断下一个位置的元素为false，循环才停止</p>
<p>注意：如果指针到了最后一个元素，也就是循环体之后，再next获取集合元素，会 发生java.util.NoSuchElementException没有集合元素的错误</p>
<h2 id="集合元素的向下转型"><a href="#集合元素的向下转型" class="headerlink" title="集合元素的向下转型"></a>集合元素的向下转型</h2><p>学习到这里，基本知道了collection接口的简单使用。可是集合中可以存储任何对象，那么存放进去的数据都是还是远死了的类型吗？不是了，提升成了object</p>
<p>在使用集合时，我们需要注意以下几点：</p>
<ul>
<li>集合中存储其实都是对象的地址。</li>
<li>集合中可以存储基本数值吗？jdk1.5版本以后可以存储了。因为出现了基本类型包装类，它提供了自动装箱操作（基本类型-&gt;对象），这样，集合中的元素就是基本数值的包装类对象。</li>
<li>存储时提升了object。取出时要使用元素的特有内容，必须向下转型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//集合可以存储任意类型的对象</span></span><br><span class="line"><span class="comment">//集合中,可以不指定存储的数据类型, 这个时候的集合什么都存</span></span><br><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;uyjgtfd&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代器获取</span></span><br><span class="line">Iterator it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">//it.next()获取出来的是什么数据类型,Object类</span></span><br><span class="line">    <span class="comment">//Object obj = it.next();</span></span><br><span class="line">    <span class="comment">//System.out.println(obj);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用上面的方式也可以，但是如果我想将里面的字符串的长度打印出来，</span></span><br><span class="line">    <span class="comment">//也就是当需要使用子类对象的特有方法，需要向下转型</span></span><br><span class="line">    String s = (String)it.next();</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果集合中存放的是多个对象，这时进行向下转型会发生类型转换异常，虽然说也可以用Iterator接口的&lt;&gt;控制迭代元素的类型，但是最好在一开始创建集合的时候就指定要数据类型</p>
<h2 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h2><p>增强for循环是jdk1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。</p>
<p>JDK1.5版本后,出现新的接口 java.lang.Iterable, Collection开始继承Iterable,在api中可以看见这么一句</p>
<p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115170140.png"></p>
<p>这个接口的出现就是为了增强for而来的，它的作用就是增强for循环，凡是它的实现类都可以使用增强for，包括数组</p>
<p>增强for的内部其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</p>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量 ： Collection 集合 or 数组)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码演示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115170627.png"></p>
<p>看着很简洁，但是它也有弊端</p>
<p>当</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">    System.out.println(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行</p>
<p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115170924.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i : arr)&#123;</span><br><span class="line">    System.out.println(i+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115171059.png"></p>
<p>可以看到最后一行打印结果却是3</p>
<p>这个应该怎么理解呢</p>
<p>可以这样理解</p>
<p><img src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115172237.png"></p>
<p>增强for的好处与弊端</p>
<ul>
<li>好处: 代码少了,方便对容器遍历</li>
<li>弊端: 没有索引,不能操作容器里面的元素</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="泛型的引入"><a href="#泛型的引入" class="headerlink" title="泛型的引入"></a>泛型的引入</h2><p>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对戏那个存储集合中，那么这时他们都会被提升成object类型。当我们再取出每一个对象，并且进行相应的操作，这时必须采用类型转换。比如下面程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">coll.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;rtyg&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;43rt5yhju&quot;</span>);</span><br><span class="line">coll.add(<span class="number">1</span>);<span class="comment">//由于集合没有做任何限定，任何类型都可以给其中存放</span></span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; it = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">    <span class="comment">//需要打印每个字符串的长度，就要把迭代出来的对象转成String类型</span></span><br><span class="line">    String s = it.next();</span><br><span class="line">    System.out.println(s.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行这个代码，程序会抛出一个异常，java.lang.ClassCastException</p>
<p>为什么会发生类型转换异常呢，我们分析下</p>
<p>由于集合中什么类型的元素都可以存储。导致取出时，如果出现强转就会引发运行时ClassCastException。怎么来解决这个问题呢？使用集合时，必须明确集合中元素的类型。这种方式称为：泛型</p>
<h2 id="泛型的定义与使用"><a href="#泛型的定义与使用" class="headerlink" title="泛型的定义与使用"></a>泛型的定义与使用</h2><p>我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。</p>
<p>泛型是JDK1.5 出现新的安全机制,用来保证程序的安全性，指明了集合中存储数据的类型  &lt;数据类型&gt;</p>
<p>泛型，用来灵活的将数据类型应用到不同的类、方法、接口中。将数据类型作为参数进行传递。</p>
<blockquote>
<p>其实， Java中的泛型是伪泛型，就是是个假的</p>
<p>在IDE中加入泛型，比如ArrayList &lt; String&gt; 这只是个编译手段，下面的代码add如果是字符串就编译成功，如果不是string类，他就会编译失败</p>
<p>但是，在编译后的class文件，它是没有泛型的，那可以保证安全吗?答案是可以，因为不符合的数据类型在IDE中就提示错了错误，不允许被编译，既然都编译出来了class文件，那就说明编译通过了，编译通过了，就说明集合容器里面的类型就是统一的类型</p>
</blockquote>
<h3 id="含有泛型的类"><a href="#含有泛型的类" class="headerlink" title="含有泛型的类"></a>含有泛型的类</h3><p>定义格式：修饰符 class 类名&lt;代表泛型的变量&gt;｛｝</p>
<p>例如，ArrayList类</p>
<p>E: Element 元素, 实际思想就是一个变量而已 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Integer e)</span></span>&#123;</span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用格式：创建对象时，给一个具体的泛型类型，</p>
<p>例如，ArrayList<Integer>  array = new ArrayList<Integer> ();</p>
<p>此时，变量E的值就是Interger类型</p>
<h3 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h3><p>定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名（参数）｛ ｝</p>
<p>例如，ArrayList类中的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是用来把集合元素存储到指定数组类型的数组中，返回已存储集合元素的数组</p>
<p>使用格式：调用方法时，确定泛型的类型</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt;  array = <span class="keyword">new</span> ArrayList&lt;Integer&gt; ();</span><br><span class="line">array.add(<span class="number">123</span>);</span><br><span class="line">array.add(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer[] i = <span class="keyword">new</span> Integer[array.size()];</span><br><span class="line">Integer [] j = array.toArray(i);</span><br><span class="line"><span class="keyword">for</span>(Integer k : j)&#123;</span><br><span class="line">    System.out.println(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">123</span><br><span class="line">456</span><br></pre></td></tr></table></figure>

<p>这个方法不常用，就是举个例子说一下，如果指定了E的类型，那么它的方法中E全部都是这个类型</p>
<h3 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h3><p>顾名思义就是带有泛型的接口</p>
<p>list类的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span> &lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的实现类，ArrayList类，先实现接口,不理会泛型</p>
<p> public class ArrayList<E> implements List<E>{}</p>
<p>这样是对调用者有好处的，比如new ArrayList&lt; String&gt;() 后期创建集合对象的时候,可以指定数据类型，指定了String，那么里面的E全部都会变成String这个类型</p>
<p>当然也可以实现接口的同时，也指定好了数据类型</p>
<p>public class XXX implements List&lt; String&gt;{}</p>
<p>但是以后new这个类的时候就不能随便指定类型了，只能String</p>
<h2 id="使用泛型的好处"><a href="#使用泛型的好处" class="headerlink" title="使用泛型的好处"></a>使用泛型的好处</h2><ol>
<li>将运行时期的ClassCastException异常，转移到了编译时期，变成了编译失败。</li>
<li>避免了类型的强转的麻烦</li>
</ol>
<h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p>先定义两个集合容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; array = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    array.add(<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    array.add(<span class="string">&quot;456&quot;</span>);</span><br><span class="line"></span><br><span class="line">    set.add(<span class="number">789</span>);</span><br><span class="line">    set.add(<span class="number">890</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们如果需要定义一个方法，可以同时迭代2个集合，应该怎么实现呢</p>
<p>可以这样定义方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  定义方法,可以同时迭代2个集合</span></span><br><span class="line"><span class="comment"> *  参数: 怎么实现 , 不能写ArrayList,也不能写HashSet</span></span><br><span class="line"><span class="comment"> *  参数: 共同实现的接口</span></span><br><span class="line"><span class="comment"> *  泛型的通配符,匹配所有的数据类型  ?   这个符号就可以匹配所有的类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(Collection&lt;?&gt; coll)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; it = coll.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型的限定"><a href="#泛型的限定" class="headerlink" title="泛型的限定"></a>泛型的限定</h3><p>比如我们创建了一个员工类， 他有三个子类，分别是厨师，服务员，经理，他们分别都有自己的工作方法work()</p>
<p>我们现在需要酒店员工,厨师,服务员,经理,分别存储到3个集合中，接着定义方法,可以同时遍历3集合,遍历三个集合的同时,可以调用工作方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//创建3个集合对象</span></span><br><span class="line">	ArrayList&lt;ChuShi&gt; cs = <span class="keyword">new</span> ArrayList&lt;ChuShi&gt;();</span><br><span class="line">	ArrayList&lt;FuWuYuan&gt; fwy = <span class="keyword">new</span> ArrayList&lt;FuWuYuan&gt;();</span><br><span class="line">	ArrayList&lt;JingLi&gt; jl = <span class="keyword">new</span> ArrayList&lt;JingLi&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//每个集合存储自己的元素</span></span><br><span class="line">	cs.add(<span class="keyword">new</span> ChuShi(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;后厨001&quot;</span>));</span><br><span class="line">	cs.add(<span class="keyword">new</span> ChuShi(<span class="string">&quot;李四&quot;</span>, <span class="string">&quot;后厨002&quot;</span>));</span><br><span class="line">	</span><br><span class="line">	fwy.add(<span class="keyword">new</span> FuWuYuan(<span class="string">&quot;翠花&quot;</span>, <span class="string">&quot;服务部001&quot;</span>));</span><br><span class="line">	fwy.add(<span class="keyword">new</span> FuWuYuan(<span class="string">&quot;酸菜&quot;</span>, <span class="string">&quot;服务部002&quot;</span>));</span><br><span class="line">	</span><br><span class="line">	jl.add(<span class="keyword">new</span> JingLi(<span class="string">&quot;小名&quot;</span>, <span class="string">&quot;董事会001&quot;</span>, <span class="number">123456789.32</span>));</span><br><span class="line">	jl.add(<span class="keyword">new</span> JingLi(<span class="string">&quot;小强&quot;</span>, <span class="string">&quot;董事会002&quot;</span>, <span class="number">123456789.33</span>));</span><br><span class="line">	</span><br><span class="line">	ArrayList&lt;String&gt; arrayString = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    </span><br><span class="line">    iterator(jl);</span><br><span class="line">	iterator(fwy);</span><br><span class="line">	iterator(cs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不用限定泛型那么方法这样写，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(ArrayList&lt;?&gt; array)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; it = array.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        Employee e = it.next();</span><br><span class="line">        e.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法是错误的，因为集合中还有个String类型，String类型没有work方法，所以这里要限定一下泛型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iterator</span><span class="params">(ArrayList&lt;? extends Employee&gt; array)</span></span>&#123;</span><br><span class="line">    Iterator&lt;? extends Employee&gt; it = array.iterator();</span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        <span class="comment">//获取出的next() 数据类型,是Employee</span></span><br><span class="line">        Employee e = it.next();</span><br><span class="line">        e.work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>借这个案例，引出泛型的限定这个概念</p>
<p>? extends Employee 限制的是父类, 上限限定, 可以传递Employee,传递他的子类对象</p>
<p>? super   Employee 限制的是子类, 下限限定, 可以传递Employee,传递他的父类对象</p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">水过无痕</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://shuigwh.cn/posts/d730f0bc.html">https://shuigwh.cn/posts/d730f0bc.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://shuigwh.cn" target="_blank">shuigwh’s blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java/">java</a><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210115192049.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/images/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/images/wechatpay.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/images/alipay.png" target="_blank"><img class="post-qr-code-img" src="/images/alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/f28ce7c.html"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20210116150849.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">集合(二)(list、set)</div></div></a></div><div class="next-post pull-right"><a href="/posts/75da51a7.html"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/cloudvillager/cloud@main/img/20201114115816.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">GitCracken7.0.0破解</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></article></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 水过无痕</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const initData = {
      el: '#vcomment',
      appId: 'S9c6pAdzMOPgEpSm4qoShv7y-MdYXbMMI',
      appKey: '9BFBXptM89Li5miROCxtvT9b',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
    }

    if (true) { 
      initData.requiredFields= ('nick,mail'.split(','))
    }

    const valine = new Valine(initData)
  }

  if (typeof Valine === 'function') initValine() 
  else $.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.querySelector('#vcomment'),loadValine)
  else setTimeout(() => loadValine(), 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="false"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" async="async" mobile="false"></script></div></body></html>